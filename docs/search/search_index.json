{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Procedural Generation for Gazebo \u00b6 The Procedural Generation for Gazebo package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations. Purpose of the project \u00b6 This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262). Requirements \u00b6 Installation from source \u00b6 Clone the repository into your catkin workspace cd ~/ catkin_ws / src git clone https : // github . com / boschresearch / pcg_gazebo_pkgs . git then install the dependencies (replace kinetic for the ROS distribution you are using) cd ~/ catkin_ws rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y -r and then run catkin build . Installation of Python dependencies \u00b6 The Python dependencies for the pcg_gazebo library can be found in pcg_libraries / requirements . txt . Since some of them cannot be resolved using rosdep , the missing dependencies are going to be installed in pip using the default python version in the target system in the user space. License \u00b6 Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses.txt .","title":"Home"},{"location":"#procedural-generation-for-gazebo","text":"The Procedural Generation for Gazebo package is an Open Source Project extending the simulation capabilities of the robotics simulator Gazebo for automation and scripting of Gazebo simulations.","title":"Procedural Generation for Gazebo"},{"location":"#purpose-of-the-project","text":"This software is a research prototype. The software is not ready for production use. It has neither been developed nor tested for a specific use case. However, the license conditions of the applicable Open Source licenses allow you to adapt the software to your needs. Before using it in a safety relevant setting, make sure that the software fulfills your requirements and adjust it according to any applicable safety standards (e.g. ISO 26262).","title":"Purpose of the project"},{"location":"#requirements","text":"","title":"Requirements"},{"location":"#installation-from-source","text":"Clone the repository into your catkin workspace cd ~/ catkin_ws / src git clone https : // github . com / boschresearch / pcg_gazebo_pkgs . git then install the dependencies (replace kinetic for the ROS distribution you are using) cd ~/ catkin_ws rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y -r and then run catkin build .","title":"Installation from source"},{"location":"#installation-of-python-dependencies","text":"The Python dependencies for the pcg_gazebo library can be found in pcg_libraries / requirements . txt . Since some of them cannot be resolved using rosdep , the missing dependencies are going to be installed in pip using the default python version in the target system in the user space.","title":"Installation of Python dependencies"},{"location":"#license","text":"Procedural Generation for Gazebo is open-sourced under the Apache-2.0 license. See the LICENSE file for details. For a list of other open source components included in Procedural Generation for Gazebo package, see the file 3 rd -party-licenses.txt .","title":"License"},{"location":"license/","text":"Apache License Version 2 . 0 , January 2004 http : // www . apache . org / licenses / TERMS AND CONDITIONS FOR USE , REPRODUCTION , AND DISTRIBUTION 1 . Definitions . \" License \" shall mean the terms and conditions for use , reproduction , and distribution as defined by Sections 1 through 9 of this document . \" Licensor \" shall mean the copyright owner or entity authorized by the copyright owner that is granting the License . \" Legal Entity \" shall mean the union of the acting entity and all other entities that control , are controlled by , or are under common control with that entity . For the purposes of this definition , \" control \" means ( i ) the power , direct or indirect , to cause the direction or management of such entity , whether by contract or otherwise , or ( ii ) ownership of fifty percent ( 50 % ) or more of the outstanding shares , or ( iii ) beneficial ownership of such entity . \" You \" ( or \" Your \" ) shall mean an individual or Legal Entity exercising permissions granted by this License . \" Source \" form shall mean the preferred form for making modifications , including but not limited to software source code , documentation source , and configuration files . \" Object \" form shall mean any form resulting from mechanical transformation or translation of a Source form , including but not limited to compiled object code , generated documentation , and conversions to other media types . \" Work \" shall mean the work of authorship , whether in Source or Object form , made available under the License , as indicated by a copyright notice that is included in or attached to the work ( an example is provided in the Appendix below ) . \" Derivative Works \" shall mean any work , whether in Source or Object form , that is based on ( or derived from ) the Work and for which the editorial revisions , annotations , elaborations , or other modifications represent , as a whole , an original work of authorship . For the purposes of this License , Derivative Works shall not include works that remain separable from , or merely link ( or bind by name ) to the interfaces of , the Work and Derivative Works thereof . \" Contribution \" shall mean any work of authorship , including the original version of the Work and any modifications or additions to that Work or Derivative Works thereof , that is intentionally submitted to Licensor for inclusion in the Work by the copyright owner or by an individual or Legal Entity authorized to submit on behalf of the copyright owner . For the purposes of this definition , \" submitted \" means any form of electronic , verbal , or written communication sent to the Licensor or its representatives , including but not limited to communication on electronic mailing lists , source code control systems , and issue tracking systems that are managed by , or on behalf of , the Licensor for the purpose of discussing and improving the Work , but excluding communication that is conspicuously marked or otherwise designated in writing by the copyright owner as \" Not a Contribution. \" \" Contributor \" shall mean Licensor and any individual or Legal Entity on behalf of whom a Contribution has been received by Licensor and subsequently incorporated within the Work . 2 . Grant of Copyright License . Subject to the terms and conditions of this License , each Contributor hereby grants to You a perpetual , worldwide , non - exclusive , no - charge , royalty - free , irrevocable copyright license to reproduce , prepare Derivative Works of , publicly display , publicly perform , sublicense , and distribute the Work and such Derivative Works in Source or Object form . 3 . Grant of Patent License . Subject to the terms and conditions of this License , each Contributor hereby grants to You a perpetual , worldwide , non - exclusive , no - charge , royalty - free , irrevocable ( except as stated in this section ) patent license to make , have made , use , offer to sell , sell , import , and otherwise transfer the Work , where such license applies only to those patent claims licensable by such Contributor that are necessarily infringed by their Contribution ( s ) alone or by combination of their Contribution ( s ) with the Work to which such Contribution ( s ) was submitted . If You institute patent litigation against any entity ( including a cross - claim or counterclaim in a lawsuit ) alleging that the Work or a Contribution incorporated within the Work constitutes direct or contributory patent infringement , then any patent licenses granted to You under this License for that Work shall terminate as of the date such litigation is filed . 4 . Redistribution . You may reproduce and distribute copies of the Work or Derivative Works thereof in any medium , with or without modifications , and in Source or Object form , provided that You meet the following conditions : ( a ) You must give any other recipients of the Work or Derivative Works a copy of this License ; and ( b ) You must cause any modified files to carry prominent notices stating that You changed the files ; and ( c ) You must retain , in the Source form of any Derivative Works that You distribute , all copyright , patent , trademark , and attribution notices from the Source form of the Work , excluding those notices that do not pertain to any part of the Derivative Works ; and ( d ) If the Work includes a \" NOTICE \" text file as part of its distribution , then any Derivative Works that You distribute must include a readable copy of the attribution notices contained within such NOTICE file , excluding those notices that do not pertain to any part of the Derivative Works , in at least one of the following places : within a NOTICE text file distributed as part of the Derivative Works ; within the Source form or documentation , if provided along with the Derivative Works ; or, within a display generated by the Derivative Works , if and wherever such third - party notices normally appear . The contents of the NOTICE file are for informational purposes only and do not modify the License . You may add Your own attribution notices within Derivative Works that You distribute , alongside or as an addendum to the NOTICE text from the Work , provided that such additional attribution notices cannot be construed as modifying the License . You may add Your own copyright statement to Your modifications and may provide additional or different license terms and conditions for use , reproduction , or distribution of Your modifications , or for any such Derivative Works as a whole , provided Your use , reproduction , and distribution of the Work otherwise complies with the conditions stated in this License . 5 . Submission of Contributions . Unless You explicitly state otherwise , any Contribution intentionally submitted for inclusion in the Work by You to the Licensor shall be under the terms and conditions of this License , without any additional terms or conditions . Notwithstanding the above , nothing herein shall supersede or modify the terms of any separate license agreement you may have executed with Licensor regarding such Contributions . 6 . Trademarks . This License does not grant permission to use the trade names , trademarks , service marks , or product names of the Licensor , except as required for reasonable and customary use in describing the origin of the Work and reproducing the content of the NOTICE file . 7 . Disclaimer of Warranty . Unless required by applicable law or agreed to in writing , Licensor provides the Work ( and each Contributor provides its Contributions ) on an \" AS IS \" BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied , including , without limitation , any warranties or conditions of TITLE , NON - INFRINGEMENT , MERCHANTABILITY , or FITNESS FOR A PARTICULAR PURPOSE . You are solely responsible for determining the appropriateness of using or redistributing the Work and assume any risks associated with Your exercise of permissions under this License . 8 . Limitation of Liability . In no event and under no legal theory , whether in tort ( including negligence ) , contract , or otherwise , unless required by applicable law ( such as deliberate and grossly negligent acts ) or agreed to in writing , shall any Contributor be liable to You for damages , including any direct , indirect , special , incidental , or consequential damages of any character arising as a result of this License or out of the use or inability to use the Work ( including but not limited to damages for loss of goodwill , work stoppage , computer failure or malfunction , or any and all other commercial damages or losses ) , even if such Contributor has been advised of the possibility of such damages . 9 . Accepting Warranty or Additional Liability . While redistributing the Work or Derivative Works thereof , You may choose to offer , and charge a fee for , acceptance of support , warranty , indemnity , or other liability obligations and / or rights consistent with this License . However , in accepting such obligations , You may act only on Your own behalf and on Your sole responsibility , not on behalf of any other Contributor , and only if You agree to indemnify , defend , and hold each Contributor harmless for any liability incurred by , or claims asserted against , such Contributor by reason of your accepting any such warranty or additional liability . END OF TERMS AND CONDITIONS APPENDIX : How to apply the Apache License to your work . To apply the Apache License to your work , attach the following boilerplate notice , with the fields enclosed by brackets \" [] \" replaced with your own identifying information . ( Don ' t include the brackets ! ) The text should be enclosed in the appropriate comment syntax for the file format . We also recommend that a file or class name and description of purpose be included on the same \" printed page \" as the copyright notice for easier identification within third - party archives . Copyright 2019 Procedural Generation for Gazebo authors Licensed under the Apache License , Version 2 . 0 ( the \" License \" ) ; you may not use this file except in compliance with the License . You may obtain a copy of the License at http : // www . apache . org / licenses / LICENSE - 2 . 0 Unless required by applicable law or agreed to in writing , software distributed under the License is distributed on an \" AS IS \" BASIS , WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND , either express or implied . See the License for the specific language governing permissions and limitations under the License .","title":"License"},{"location":"python_api/pcg_gazebo.generators.constraints/","text":"pcg_gazebo.generators.constraints \u00b6 Spatial constraints for the placement of simulation entities into the world. create_constraint \u00b6 create_constraint ( tag , ** kwargs ) Constraint factory that returns the constraint according to its LABEL definition. It returns None if the constraint name is invalid. Input parameters tag ( type: str ): Name of the constraint class kwargs : Inputs for the constraint class constructor Constraint \u00b6 Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class. TangentConstraint \u00b6 TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented ) apply_constraint \u00b6 TangentConstraint . apply_constraint ( self , model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference WorkspaceConstraint \u00b6 WorkspaceConstraint ( self , geometry = None , frame = 'world' , holes = None ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace generate_geometry \u00b6 WorkspaceConstraint . generate_geometry ( self , type , description ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry get_bounds \u00b6 WorkspaceConstraint . get_bounds ( self ) Return the polygon bounds get_random_position \u00b6 WorkspaceConstraint . get_random_position ( self ) Return a random position that belongs to the workspace contains_point \u00b6 WorkspaceConstraint . contains_point ( self , point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy . ndarray ): 2D point contains_polygons \u00b6 WorkspaceConstraint . contains_polygons ( self , polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely . Polygon ): List of polygons get_geometry \u00b6 WorkspaceConstraint . get_geometry ( self ) Return the workspace geometry","title":"pcg_gazebo.generators.constraints"},{"location":"python_api/pcg_gazebo.generators.constraints/#pcg_gazebogeneratorsconstraints","text":"Spatial constraints for the placement of simulation entities into the world.","title":"pcg_gazebo.generators.constraints"},{"location":"python_api/pcg_gazebo.generators.constraints/#create_constraint","text":"create_constraint ( tag , ** kwargs ) Constraint factory that returns the constraint according to its LABEL definition. It returns None if the constraint name is invalid. Input parameters tag ( type: str ): Name of the constraint class kwargs : Inputs for the constraint class constructor","title":"create_constraint"},{"location":"python_api/pcg_gazebo.generators.constraints/#constraint","text":"Constraint ( self ) Abstract constraint class. Attributes LABEL ( type: str ): Name of the constraint class.","title":"Constraint"},{"location":"python_api/pcg_gazebo.generators.constraints/#tangentconstraint","text":"TangentConstraint ( self , reference , frame = 'world' ) Class that allows computation of the closes position for a model regarding a reference to have it placed tangent to the reference. Reference can be a plane or another model, at the moment. The input reference types that are supported are plane : To set a reference plane to which models will be placed tangently, the reference input must be provided as reference = dict ( type = 'plane' , args = dict ( normal = [ 0 , 0 , 1 ], # A 3 element unit vector normal to the plane origin = [ 0 , 0 , 0 ] # The 3D position of the origin of the plane ) ) Attributes LABEL ( type: str , value: 'tangent' ): Name of the constraint class _REFERENCE_TYPES ( type: list ): List of types of references that can be used for the computation _reference ( type: dict ): Arguments of the type of reference used. Input arguments reference ( type: dict ): Arguments for the reference used for the tangent computation frame ( type: str , default: world ): Name of the frame of reference with respect to which the poses are going to be generated ( not implemented )","title":"TangentConstraint"},{"location":"python_api/pcg_gazebo.generators.constraints/#apply_constraint","text":"TangentConstraint . apply_constraint ( self , model ) Compute and apply the tangent constraint for the provided model using the reference input. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Model entity to have its pose adapted so that it is placed tangent to the reference","title":"apply_constraint"},{"location":"python_api/pcg_gazebo.generators.constraints/#workspaceconstraint","text":"WorkspaceConstraint ( self , geometry = None , frame = 'world' , holes = None ) Class that represents the spatial workspace where models are allowed in. The geometry input is a dict containing all the arguments necessary to generate the workspace geometry. For now, only 2D workspaces are supported. The holes input is a list of dict with the same geometry description of the input geometry and describe exclusion areas inside the workspace. The supported geometry inputs to represent a workspace are area geometry = dict ( type = 'area' description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) ) line geometry = dict ( type = 'line' , description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) ) circle geometry = dict ( type = 'circle' description = dict ( radius = 0.0 , # Radius of the circle center = [ 0 , 0 , 0 ] # Center of the circle as a 3D point ) ) Others are still not implemented Attributes LABEL ( type: str , value: workspace ): Name of the constraint class GEOMETRIES ( type: list ): List of input geometries that can be used to set a workspace Input arguments geometry ( type: dict , default: None ): Input arguments of the geometry to be generated frame ( type: str , default: 'world' ): Name of the frame of reference of the workspace ( not implemented ) holes ( type: dict , default: None ): Geometries that represent exclusion areas inside the workspace","title":"WorkspaceConstraint"},{"location":"python_api/pcg_gazebo.generators.constraints/#generate_geometry","text":"WorkspaceConstraint . generate_geometry ( self , type , description ) Generate a shapely entity according to the geometry description provided. The input type containts the name of the geometry to be generated and the necessary arguments must be provided in the dict input description . Possible geometries according to the different input values in type are: area description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the vertices of the plane area ) line description = dict ( points = [ [ 0 , 0 , 0 ], [ 0 , 1 , 1 ], ... ] # List of 3D points that describe the line ) circle description = dict ( center = [ - 6.8 , - 6.8 , 0 ] # Center of the circle radius = 0.2 # Radius of the circle ) Others are still not implemented Input arguments type ( type: str ): Geometry type. Options are: line , area , volume , multi_line , multi_point , circle description ( type: dict ): Arguments to describe the geometry","title":"generate_geometry"},{"location":"python_api/pcg_gazebo.generators.constraints/#get_bounds","text":"WorkspaceConstraint . get_bounds ( self ) Return the polygon bounds","title":"get_bounds"},{"location":"python_api/pcg_gazebo.generators.constraints/#get_random_position","text":"WorkspaceConstraint . get_random_position ( self ) Return a random position that belongs to the workspace","title":"get_random_position"},{"location":"python_api/pcg_gazebo.generators.constraints/#contains_point","text":"WorkspaceConstraint . contains_point ( self , point ) Return True if point is part of the workspace. Input arguments point ( type: list or numpy . ndarray ): 2D point","title":"contains_point"},{"location":"python_api/pcg_gazebo.generators.constraints/#contains_polygons","text":"WorkspaceConstraint . contains_polygons ( self , polygons ) Return True if polygons in the polygons list are part of the workspace. Input arguments polygons ( type: list of shapely . Polygon ): List of polygons","title":"contains_polygons"},{"location":"python_api/pcg_gazebo.generators.constraints/#get_geometry","text":"WorkspaceConstraint . get_geometry ( self ) Return the workspace geometry","title":"get_geometry"},{"location":"python_api/pcg_gazebo.generators.engines/","text":"pcg_gazebo.generators.engines \u00b6 Pose generator engine definitions that compute the pose of the models according to pre-defined rules. create_engine \u00b6 create_engine ( tag , ** kwargs ) Engine factory that returns the engine according to its LABEL definition. It returns None if the engine name is invalid. Input parameters tag ( type: str ): Name of the engine class kwargs : Inputs for the engine class constructor Engine \u00b6 Engine ( self , callback_fcn_get_model , callback_fcn_get_constraint = None , models = None , constraints = None ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes. Input arguments callback_fcn_get_model ( type: callable ): Handle to a function or a lambda function that returns a pcg_gazebo . simulation . SimulationModel associated with a tag name. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo . constraints . Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. label \u00b6 str : Engine name identifier models \u00b6 List of str : List of model name tags regarding the engine's model assets poses \u00b6 dict : List of fixed poses associated with model names. add_local_constraint \u00b6 Engine . add_local_constraint ( self , model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition get_local_constraints_for_model \u00b6 Engine . get_local_constraints_for_model ( self , model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned. apply_local_constraints \u00b6 Engine . apply_local_constraints ( self , model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Model instance Returns pcg_gazebo . simulation . SimulationModel : Model with modified pose. add_model \u00b6 Engine . add_model ( self , model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model set_fixed_pose_models \u00b6 Engine . set_fixed_pose_models ( self , models ) Function description Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values run \u00b6 Engine . run ( self ) This function should be implemented by the derived classes. FixedPoseEngine \u00b6 FixedPoseEngine ( self , callback_fcn_get_model , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_model ( type: callable ): Handle to a function or a lambda function that returns a pcg_gazebo . simulation . SimulationModel associated with a tag name. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo . constraints . Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses. add_pose \u00b6 FixedPoseEngine . add_pose ( self , pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses. run \u00b6 FixedPoseEngine . run ( self ) Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo . simulation . SimulationModel : Model instances. PatternEngine \u00b6 PatternEngine ( self , callback_fcn_get_model , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], mode = None , args = None ) RandomPoseEngine \u00b6 RandomPoseEngine ( self , callback_fcn_get_model = None , callback_fcn_get_constraint = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments callback_fcn_get_model ( type: callable ): Handle to a function or a lambda function that returns a pcg_gazebo . simulation . SimulationModel associated with a tag name. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo . constraints . Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on workspaces, check the class definition for `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793 reset_counter \u00b6 RandomPoseEngine . reset_counter ( self ) Reset all model counters. increase_counter \u00b6 RandomPoseEngine . increase_counter ( self , name ) Increase the counter for a model. Input arguments name ( type: str ): Model name get_num_models \u00b6 RandomPoseEngine . get_num_models ( self , name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models get_max_num_models \u00b6 RandomPoseEngine . get_max_num_models ( self , name ) Return the defined maximum number of instances for a model. Input arguments name ( type: str ): Model name Returns int : Maximum number of instances choose_model \u00b6 RandomPoseEngine . choose_model ( self ) Select the next model instance to be placed in the world. This method is affected by the constructor input model_picker . In case the model_picker option was set as random , a random model will be chosen from the assets available. If it is area , the models will be ordered by footprint size and the models are chosen by an descending footprint size. Returns pcg_gazebo . simulation . SimulationModel : Chosen model is_model_in_workspace \u00b6 RandomPoseEngine . is_model_in_workspace ( self , footprint ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely . geometries . Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace get_list_of_footprint_polygons \u00b6 RandomPoseEngine . get_list_of_footprint_polygons ( self , footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely . geometries . Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely . geometry . Polygon : List of footprint polygons has_collision \u00b6 RandomPoseEngine . has_collision ( self , model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Returns bool : True , if any collision is detected run \u00b6 RandomPoseEngine . run ( self ) Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo . simulation . SimulationModel","title":"pcg_gazebo.generators.engines"},{"location":"python_api/pcg_gazebo.generators.engines/#pcg_gazebogeneratorsengines","text":"Pose generator engine definitions that compute the pose of the models according to pre-defined rules.","title":"pcg_gazebo.generators.engines"},{"location":"python_api/pcg_gazebo.generators.engines/#create_engine","text":"create_engine ( tag , ** kwargs ) Engine factory that returns the engine according to its LABEL definition. It returns None if the engine name is invalid. Input parameters tag ( type: str ): Name of the engine class kwargs : Inputs for the engine class constructor","title":"create_engine"},{"location":"python_api/pcg_gazebo.generators.engines/#engine","text":"Engine ( self , callback_fcn_get_model , callback_fcn_get_constraint = None , models = None , constraints = None ) Base class for model factory engines. The engines are responsible of computing poses for models in the world and performing collision checks within the scenario before the final world is generated. This class includes methods common to all derived engine classes. Input arguments callback_fcn_get_model ( type: callable ): Handle to a function or a lambda function that returns a pcg_gazebo . simulation . SimulationModel associated with a tag name. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo . constraints . Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets.","title":"Engine"},{"location":"python_api/pcg_gazebo.generators.engines/#label","text":"str : Engine name identifier","title":"label"},{"location":"python_api/pcg_gazebo.generators.engines/#models","text":"List of str : List of model name tags regarding the engine's model assets","title":"models"},{"location":"python_api/pcg_gazebo.generators.engines/#poses","text":"dict : List of fixed poses associated with model names.","title":"poses"},{"location":"python_api/pcg_gazebo.generators.engines/#add_local_constraint","text":"Engine . add_local_constraint ( self , model_name , constraint_name ) Add an association of a constraint definitions with an specific model tag to be taken into account when running the placement engine. Input arguments model_name ( type: str ): Name of the model constraint_name ( type: str ): Name of the constraint definition","title":"add_local_constraint"},{"location":"python_api/pcg_gazebo.generators.engines/#get_local_constraints_for_model","text":"Engine . get_local_constraints_for_model ( self , model_name ) Return the name of the local constraint definitions for a model. Input arguments model_name ( type: str ): Name of the model Returns List of str : List of constraint definition names associated with the model. If the model has no constraints, am empty list is returned.","title":"get_local_constraints_for_model"},{"location":"python_api/pcg_gazebo.generators.engines/#apply_local_constraints","text":"Engine . apply_local_constraints ( self , model ) Apply spatial constraints to model. This will modify the pose of the model if it violates the constraint. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Model instance Returns pcg_gazebo . simulation . SimulationModel : Model with modified pose.","title":"apply_local_constraints"},{"location":"python_api/pcg_gazebo.generators.engines/#add_model","text":"Engine . add_model ( self , model ) Add a model name to the list of model assets for this engine. Input arguments model ( type: str ): Name of the model","title":"add_model"},{"location":"python_api/pcg_gazebo.generators.engines/#set_fixed_pose_models","text":"Engine . set_fixed_pose_models ( self , models ) Function description Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"set_fixed_pose_models"},{"location":"python_api/pcg_gazebo.generators.engines/#run","text":"Engine . run ( self ) This function should be implemented by the derived classes.","title":"run"},{"location":"python_api/pcg_gazebo.generators.engines/#fixedposeengine","text":"FixedPoseEngine ( self , callback_fcn_get_model , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None ) Engine that just places models on pre-configured fixed poses. This engine only accepts one model asset. callback_fcn_get_model ( type: callable ): Handle to a function or a lambda function that returns a pcg_gazebo . simulation . SimulationModel associated with a tag name. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo . constraints . Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. poses ( type: list ): List of 6- (position and Euler angles) or 7 element (position and quaternion) poses.","title":"FixedPoseEngine"},{"location":"python_api/pcg_gazebo.generators.engines/#add_pose","text":"FixedPoseEngine . add_pose ( self , pose ) Add pose to the list of fixed-poses. Input arguments pose ( type: list ): 6- (position and Euler angles) or 7 element (position and quaternion) poses.","title":"add_pose"},{"location":"python_api/pcg_gazebo.generators.engines/#run_1","text":"FixedPoseEngine . run ( self ) Generate instances of the model asset for all the poses provided. If any local constraints were also provided, they will be applied to the model after its placement. Returns List of pcg_gazebo . simulation . SimulationModel : Model instances.","title":"run"},{"location":"python_api/pcg_gazebo.generators.engines/#patternengine","text":"PatternEngine ( self , callback_fcn_get_model , callback_fcn_get_constraint = None , models = None , poses = None , constraints = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], mode = None , args = None )","title":"PatternEngine"},{"location":"python_api/pcg_gazebo.generators.engines/#randomposeengine","text":"RandomPoseEngine ( self , callback_fcn_get_model = None , callback_fcn_get_constraint = None , is_ground_plane = False , models = None , max_num = None , no_collision = True , max_area = 1 , constraints = None , policies = None , model_picker = 'random' ) Placement engine that generates a random pose for its model assets respecting input local constraints, if any is provided, such as workspace constraint. This engine performs also a collision check with all models already placed in the scene (except for models flagged as ground plane) to ensure no models are overlapping each other. Input arguments callback_fcn_get_model ( type: callable ): Handle to a function or a lambda function that returns a pcg_gazebo . simulation . SimulationModel associated with a tag name. callback_fcn_get_constraint ( type: callable , default: None ): Handle to a function or a lambda function that returns a pcg_gazebo . constraints . Constraint associated with a tag name. models ( type: list , default: None ): List of models names as str relative to the models that the engine will have as assets. constraints ( type: list , default: None ): List of local constraint configurations that will be applied on to the engine's model assets. max_num ( type: dict , default: None ): Maximum number of instances of the model assets, the key being the model asset's name, and the value the maximum number. no_collision ( type: bool , default: True ): If True , the model instances are only added to the world if there are no collisions with the already existing models (except for models flagged as ground plane). max_area ( type: float , default: 1 ): Percentage of the allowed area to fill with the models. model_picker ( type: str , default: random ): Strategy for picking a model from the list of assets for the next placement in the world. Options are random (selecting a random model from the list of assets) or area (selecting the models for the biggest to the smallest). policies ( type: dict , default: None ): The rules for model generation associated with each degree of freedom. policies : - models : - model_1 - model_2 - model_3 config : - dofs : - x - y policy : name : workspace args : area_1 # For more information on workspaces, check the class definition for `pcg_gazebo.constraints.WorkspaceConstraint` - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : min : -3.141592653589793 max : 3.141592653589793","title":"RandomPoseEngine"},{"location":"python_api/pcg_gazebo.generators.engines/#reset_counter","text":"RandomPoseEngine . reset_counter ( self ) Reset all model counters.","title":"reset_counter"},{"location":"python_api/pcg_gazebo.generators.engines/#increase_counter","text":"RandomPoseEngine . increase_counter ( self , name ) Increase the counter for a model. Input arguments name ( type: str ): Model name","title":"increase_counter"},{"location":"python_api/pcg_gazebo.generators.engines/#get_num_models","text":"RandomPoseEngine . get_num_models ( self , name ) Return the current value for the model counter. Input arguments name ( type: str ): Model name Returns int : Number of models","title":"get_num_models"},{"location":"python_api/pcg_gazebo.generators.engines/#get_max_num_models","text":"RandomPoseEngine . get_max_num_models ( self , name ) Return the defined maximum number of instances for a model. Input arguments name ( type: str ): Model name Returns int : Maximum number of instances","title":"get_max_num_models"},{"location":"python_api/pcg_gazebo.generators.engines/#choose_model","text":"RandomPoseEngine . choose_model ( self ) Select the next model instance to be placed in the world. This method is affected by the constructor input model_picker . In case the model_picker option was set as random , a random model will be chosen from the assets available. If it is area , the models will be ordered by footprint size and the models are chosen by an descending footprint size. Returns pcg_gazebo . simulation . SimulationModel : Chosen model","title":"choose_model"},{"location":"python_api/pcg_gazebo.generators.engines/#is_model_in_workspace","text":"RandomPoseEngine . is_model_in_workspace ( self , footprint ) Verify if the model is in the allowed workspace Input arguments footprint ( type: dict or shapely . geometries . Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns bool : True if the polygon is entirely contained inside the workspace","title":"is_model_in_workspace"},{"location":"python_api/pcg_gazebo.generators.engines/#get_list_of_footprint_polygons","text":"RandomPoseEngine . get_list_of_footprint_polygons ( self , footprint ) Return the list of polygons contained in the footprint input. Input arguments footprint ( type: dict or shapely . geometries . Polygon ): A shapely polygon or a dictionary with the values being the footprints for different submodels. Returns List of shapely . geometry . Polygon : List of footprint polygons","title":"get_list_of_footprint_polygons"},{"location":"python_api/pcg_gazebo.generators.engines/#has_collision","text":"RandomPoseEngine . has_collision ( self , model ) Run the collision checker of the input model against the current scene of the simulation. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Returns bool : True , if any collision is detected","title":"has_collision"},{"location":"python_api/pcg_gazebo.generators.engines/#run_2","text":"RandomPoseEngine . run ( self ) Run the placement engine and generate a list of models placed according to the input policies and respecting spatial constraints. Returns List of pcg_gazebo . simulation . SimulationModel","title":"run"},{"location":"python_api/pcg_gazebo.generators/","text":"pcg_gazebo.generators \u00b6 The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints. pcg_gazebo.generators.collision_checker \u00b6 CollisionChecker \u00b6 CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. scene \u00b6 trimesh . scene . Scene : Collision check scenario reset_scenario \u00b6 CollisionChecker . reset_scenario ( self ) Remove all meshes from collision check scene. reset_to_fixed_model_scenario \u00b6 CollisionChecker . reset_to_fixed_model_scenario ( self ) Remove all meshes that were not generated by a fixed-pose engine. add_fixed_model \u00b6 CollisionChecker . add_fixed_model ( self , model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model structure add_model \u00b6 CollisionChecker . add_model ( self , model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model structure show \u00b6 CollisionChecker . show ( self ) Display the current collision check scenario using pyglet . check_collision_with_current_scene \u00b6 CollisionChecker . check_collision_with_current_scene ( self , model ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise. check_for_collisions \u00b6 CollisionChecker . check_for_collisions ( self ) Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise. SingletonCollisionChecker \u00b6 SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance () . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks. get_instance \u00b6 SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance pcg_gazebo.generators.creators \u00b6 Factory methods to create simulation models. box \u00b6 box ( size , mass = 0 , name = 'box' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None ) Factory method that returns a box-shaped model with one cuboid link. Input arguments size ( type: list or numpy . ndarray ): 3D vector with the size of the box for width, length and height, respectively, in meters. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns A box-shaped pcg_gazebo . simulation . SimulationModel instance. mesh \u00b6 mesh ( visual_mesh_filename , collision_mesh_filename = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], name = 'mesh' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' ) Create a model based on a mesh input. The options for visual and collision meshes are: visual_mesh_filename is provided and no collision_mesh_filename . The collision mesh is then set to be the same as the visual mesh. Both visual_mesh_filename and collision_mesh_filename are provided separately. visual_mesh_filename is provided and no collision_mesh_filename , but use_approximated_collision is True . In this case the collision geometry can be an approximated geometry fitted to the visual mesh. Options for the approximation methods are box , sphere or cylinder . The same is valid for the moments of inertia. For static models, mass can be set as 0. Otherwise, the following options are possible: inertia provided as inertia = dict ( ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) Set use_approximated_inertia to True and the inertia model will be computed for the model using the approximated_inertia_model input (options are box , sphere or cylinder ). In this case the approximated geometry will be computed from the visual mesh and its dimensions combined with the provided mass will be used to generate the model's moments of inertia. Input arguments visual_mesh_filename ( type: str ): Name of the visual mesh file collision_mesh_filename ( type: str , default: None ): Name of the collision mesh file. If None is provided, then the visual mesh file will be used as collision geometry use_approximated_collision ( type: bool , default: False ): Enable computing an approximated collision geometry from the visual mesh. approximated_collision_model ( type: str , default: 'box' ): Type of approximated collision geometry to be derived from the visual mesh. Options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling vector to be applied to the visual mesh collision_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling vector to be applied to the collision mesh name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. inertia ( type: dict , default: None ): Optional moments of inertia setting to the model in the form of inertia = dict ( ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) use_approximated_inertia ( type: bool , default: True ): Enable computation of moments of inertia based on the mass input and the approximated inertia model setting based on the dimensions of the mesh. approximated_inertia_model ( type: str , default: box ): Type of geometrical approximation to be computed from the visual mesh. The dimensions of the approximated geometry will be then used to compute the moments of inertia of the model. Options are box , cylinder or sphere . Returns A box-shaped pcg_gazebo . simulation . SimulationModel instance. sphere \u00b6 sphere ( radius , mass = 0 , name = 'sphere' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None ) Return a sphere-shaped simulation model. Input arguments radius ( type: float ): Radius of the sphere. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns A sphere-shaped pcg_gazebo . simulation . SimulationModel instance. cylinder \u00b6 cylinder ( length , radius , mass = 0 , name = 'cylinder' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None ) Return a cylinder-shaped simulation model with the rotation axis set per default as [ 0 , 0 , 1 ] . Input arguments radius ( type: float ): Radius of the cylinder. length ( type: float ): Length of the cylinder. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns A cylinder-shaped pcg_gazebo . simulation . SimulationModel instance. box_factory \u00b6 box_factory ( size , mass = None , name = 'box' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], use_permutation = True , color = None ) Factory function for box-shaped models. It parses the vector size to generate the boxes. The mass can be either a scalar or a vector. If mass is a scalar, all boxes will have the same mass. If the size of the vectors size and mass are the same, the boxes can be generated by associating a size vector with a mass by position in the array or they can be permutated. If the vectors size and mass have different lengths, only permutation can be performed. The size and mass inputs can also be provided as lambda functions as str , such as: size = \"__import__('numpy').random.random((4, 3))\" mass = \"__import__('numpy').arange(1, 10, 4)\" Input arguments size ( type: list or lambda function as str ): List of 3D size vectors mass ( type: float , list of float or lambda function as str , default: None ): Mass of the boxes. If mass is None , all boxes will be static models pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. use_permutation ( type: bool , default: True ): Enable use of permutation to associate the size elements with the mass inputs. If the sizes of the size and mass have different sizes, permutation will be used per default. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns List of pcg_gazebo . simulation . SimulationModel instances. sphere_factory \u00b6 sphere_factory ( radius , mass = None , name = 'sphere' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], use_permutation = True , color = None ) Factory function for sphere-shaped models. It parses the vector radius to generate the spheres. The mass can be either a scalar or a vector. If mass is a scalar, all spheres will have the same mass. If the size of the vectors radius and mass are the same, the spheres can be generated by associating a radius value with a mass by position in the array or they can be permutated. If the vectors radius and mass have different lengths, only permutation can be performed. The radius and mass inputs can also be provided as lambda functions as str , such as: radius = \"__import__('numpy').random.random(2)\" mass = \"__import__('numpy').arange(1, 4, 1)\" Input arguments radius ( type: list or lambda function as str ): List of radius values mass ( type: float , list of float or lambda function as str , default: None ): Mass of the boxes. If mass is None , all spheres will be static models pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. use_permutation ( type: bool , default: True ): Enable use of permutation to associate the radius elements with the mass inputs. If the sizes of the radius and mass have different sizes, permutation will be used per default. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns List of pcg_gazebo . simulation . SimulationModel instances. cylinder_factory \u00b6 cylinder_factory ( length , radius , mass = None , name = 'cylinder' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], use_permutation = True , color = None ) Factory function for cylinder-shaped models. It parses the vectors radius and length to generate the cylinders. The mass can be either a scalar or a vector. If mass is a scalar, all cylinders will have the same mass. If the size of the vectors length , radius and mass are the same, the cylinders can be generated by associating a radius and a length value with a mass by position in the array or they can be permutated. If the vectors radius and length have different lengths, only permutation can be performed. The length , radius and mass inputs can also be provided as lambda functions as str , such as: length = \"__import__('numpy').random.random(2)\" radius = \"__import__('numpy').random.random(2)\" mass = \"__import__('numpy').arange(1, 4, 1)\" Input arguments radius ( type: float , list of float or lambda function as str ): List of radius values length ( type: float , list of float or lambda function as str ): List of length values mass ( type: float , list of float or lambda function as str , default: None ): Mass of the cylinders. If mass is None , all cylinders will be static models pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. use_permutation ( type: bool , default: True ): Enable use of permutation to associate the size elements with the mass inputs. If the sizes of the length and radius have different sizes, permutation will be used per default. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns List of pcg_gazebo . simulation . SimulationModel instances. config2models \u00b6 config2models ( config ) Parse the input dict configuration and calls the respective model factory. Input arguments config ( type: dict ): Dictionary with the model generation rules Returns List of pcg_gazebo . simulation . SimulationModel instances. create_models_from_config \u00b6 create_models_from_config ( config , n_processes = None ) Creation of models from a dict configuration input using multi-processing. Input arguments config ( type: dict ): Dictionary with the model generation rules n_processes ( type: int , default: None ): Maximum number of processes. If None , then use the number of CPUs available. Returns List of pcg_gazebo . simulation . SimulationModel instances. pcg_gazebo.generators.occupancy \u00b6 pcg_gazebo.generators.patterns \u00b6 pcg_gazebo.generators.world_generator \u00b6 WorldGenerator \u00b6 WorldGenerator ( self , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo . task_manager . GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime. assets \u00b6 List of pcg_gazebo . simulation . SimulationModel : List of model assets that will be used of the world generation. constraints \u00b6 dict of pcg_gazebo . generators . constraints : Dictionary with the positioning constraints. engines \u00b6 dict of pcg_gazebo . generators . engines : Dictionary with the model creation engines. gazebo_proxy \u00b6 pcg_gazebo . task_manager . GazeboProxy : Internal instance of the GazeboProxy name \u00b6 str : Name of the generated world world \u00b6 pcg_gazebo . simulation . World : World abstraction instance init_gazebo_proxy \u00b6 WorldGenerator . init_gazebo_proxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server add_engine \u00b6 WorldGenerator . add_engine ( self , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine. add_constraint \u00b6 WorldGenerator . add_constraint ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created add_asset \u00b6 WorldGenerator . add_asset ( self , model ) Add a new model asset that can be used by the engines and added to the generated world. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model set_model_as_ground_plane \u00b6 WorldGenerator . set_model_as_ground_plane ( self , model_name ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments model_name ( type: str ): Name of the model asset get_asset \u00b6 WorldGenerator . get_asset ( self , name ) Return a simulation model asset. Input arguments name ( type: str ): Name of the model asset. Returns The model asset as pcg_gazebo . simulation . SimulationModel . None if name cannot be found in the list of model assets. get_constraint \u00b6 WorldGenerator . get_constraint ( self , name ) Return a positioning constraint configuration. Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values add_gazebo_model_as_asset \u00b6 WorldGenerator . add_gazebo_model_as_asset ( self , gazebo_model_name ) Create a model asset by importing a Gazebo model that already exists in the resources path of the catkin workspace. The model's SDF file will be parsed and converted into a pcg_gazebo . simulation . SimulationModel instance. Models that include lights can also be added, but will not be considered assets, they will just be included into the generated world SDF file. Input arguments gazebo_model_name ( type: str ): ID name from the Gazebo model to be imported Returns True if Gazebo model could be included in the assets list. is_asset \u00b6 WorldGenerator . is_asset ( self , name ) Return True if the model identified by the string name is part of the list of assets. Input arguments name ( type: str ): Name of the model add_model \u00b6 WorldGenerator . add_model ( self , model , poses ) Add an instance of pcg_gazebo . simulation . SimulationModel to the world in designed poses. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Parameter description poses ( type: list ): List of 6D pose vectors add_gazebo_model \u00b6 WorldGenerator . add_gazebo_model ( self , model_name , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Add an existent Gazebo model to the world in designed poses. Input arguments model_name ( type: str ): ID name of the Gazebo model pose ( type: list ): 6D pose vector remove_asset \u00b6 WorldGenerator . remove_asset ( self , name ) Remove model asset from the list of assets. Input arguments name ( type: str ): Name of the model Returns True , if model could be removed. delete_model \u00b6 WorldGenerator . delete_model ( self , model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation. add_lights_from_gazebo_model \u00b6 WorldGenerator . add_lights_from_gazebo_model ( self , model_name ) Add light models to the generated world from a Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns True if the lights could be parsed and added to the world. parse_configuration \u00b6 WorldGenerator . parse_configuration ( self , config , verbose = False ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values spawn_model \u00b6 WorldGenerator . spawn_model ( self , model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo . simulation . SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [ 0 , 0 , 0 ] ): Spawning position wrt reference frame rot ( type: list , default: [ 0 , 0 , 0 ] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned. get_physics_engine \u00b6 WorldGenerator . get_physics_engine ( self , engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo . simulation . physics . Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo . simulation . physics . Physics object. run_engines \u00b6 WorldGenerator . run_engines ( self , attach_models = False ) Run all the model placement engines and add the generated models in the internal instance of the world representation. Input arguments attach_models ( type: bool , default: False ): Attach the generated models to the existent list of models in the world Returns True if all engines ran successfully. reset_world \u00b6 WorldGenerator . reset_world ( self , name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [ 0 , 0 , - 9 . 8 ] ): Gravitational acceleration vector export_world \u00b6 WorldGenerator . export_world ( self , output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str plot_results \u00b6 WorldGenerator . plot_results ( self , fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"pcg_gazebo.generators"},{"location":"python_api/pcg_gazebo.generators/#pcg_gazebogenerators","text":"The tools in this modules allow the generation of models and worlds using policy rules for object placement and constraints.","title":"pcg_gazebo.generators"},{"location":"python_api/pcg_gazebo.generators/#pcg_gazebogeneratorscollision_checker","text":"","title":"pcg_gazebo.generators.collision_checker"},{"location":"python_api/pcg_gazebo.generators/#collisionchecker","text":"CollisionChecker ( self , ignore_ground_plane = True ) Mesh-based collision checker manager. The meshes can be added to the collision check scene and used to check any other object for collisions. Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks.","title":"CollisionChecker"},{"location":"python_api/pcg_gazebo.generators/#scene","text":"trimesh . scene . Scene : Collision check scenario","title":"scene"},{"location":"python_api/pcg_gazebo.generators/#reset_scenario","text":"CollisionChecker . reset_scenario ( self ) Remove all meshes from collision check scene.","title":"reset_scenario"},{"location":"python_api/pcg_gazebo.generators/#reset_to_fixed_model_scenario","text":"CollisionChecker . reset_to_fixed_model_scenario ( self ) Remove all meshes that were not generated by a fixed-pose engine.","title":"reset_to_fixed_model_scenario"},{"location":"python_api/pcg_gazebo.generators/#add_fixed_model","text":"CollisionChecker . add_fixed_model ( self , model ) Add a model as a fixed-pose model to the scene. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model structure","title":"add_fixed_model"},{"location":"python_api/pcg_gazebo.generators/#add_model","text":"CollisionChecker . add_model ( self , model ) Add model to collision checking scene. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model structure","title":"add_model"},{"location":"python_api/pcg_gazebo.generators/#show","text":"CollisionChecker . show ( self ) Display the current collision check scenario using pyglet .","title":"show"},{"location":"python_api/pcg_gazebo.generators/#check_collision_with_current_scene","text":"CollisionChecker . check_collision_with_current_scene ( self , model ) Check if there are any collisions between model and the meshes in the scene. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model structure Returns True , if any collision is detected. False , otherwise.","title":"check_collision_with_current_scene"},{"location":"python_api/pcg_gazebo.generators/#check_for_collisions","text":"CollisionChecker . check_for_collisions ( self ) Check if there are any collisions amongst the meshes in the scene. Returns True , if any collision is detected. False , otherwise.","title":"check_for_collisions"},{"location":"python_api/pcg_gazebo.generators/#singletoncollisionchecker","text":"SingletonCollisionChecker ( self , ignore_ground_plane = True ) Singleton collision checker that can be have one instance accessed by multiple clients. It facilitates sharing the collision managar amongst many engines, for example. Attributes INSTANCE ( type: SingletonCollisionChecker , value: None ): Instance of the singleton collision checker that is initialized by the first call of get_instance () . Input arguments ignore_ground_plane ( type: bool , value: True ): Ignores the meshes flagged as ground plane when performing collision checks.","title":"SingletonCollisionChecker"},{"location":"python_api/pcg_gazebo.generators/#get_instance","text":"SingletonCollisionChecker . get_instance ( ** kwargs ) Return a singleton instance of the collision checker. Input arguments kwargs ( type: dict ): Input arguments for the SingletonCollisionChecker instance. Returns A SingletonCollisionChecker instance","title":"get_instance"},{"location":"python_api/pcg_gazebo.generators/#pcg_gazebogeneratorscreators","text":"Factory methods to create simulation models.","title":"pcg_gazebo.generators.creators"},{"location":"python_api/pcg_gazebo.generators/#box","text":"box ( size , mass = 0 , name = 'box' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None ) Factory method that returns a box-shaped model with one cuboid link. Input arguments size ( type: list or numpy . ndarray ): 3D vector with the size of the box for width, length and height, respectively, in meters. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns A box-shaped pcg_gazebo . simulation . SimulationModel instance.","title":"box"},{"location":"python_api/pcg_gazebo.generators/#mesh","text":"mesh ( visual_mesh_filename , collision_mesh_filename = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], name = 'mesh' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' ) Create a model based on a mesh input. The options for visual and collision meshes are: visual_mesh_filename is provided and no collision_mesh_filename . The collision mesh is then set to be the same as the visual mesh. Both visual_mesh_filename and collision_mesh_filename are provided separately. visual_mesh_filename is provided and no collision_mesh_filename , but use_approximated_collision is True . In this case the collision geometry can be an approximated geometry fitted to the visual mesh. Options for the approximation methods are box , sphere or cylinder . The same is valid for the moments of inertia. For static models, mass can be set as 0. Otherwise, the following options are possible: inertia provided as inertia = dict ( ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) Set use_approximated_inertia to True and the inertia model will be computed for the model using the approximated_inertia_model input (options are box , sphere or cylinder ). In this case the approximated geometry will be computed from the visual mesh and its dimensions combined with the provided mass will be used to generate the model's moments of inertia. Input arguments visual_mesh_filename ( type: str ): Name of the visual mesh file collision_mesh_filename ( type: str , default: None ): Name of the collision mesh file. If None is provided, then the visual mesh file will be used as collision geometry use_approximated_collision ( type: bool , default: False ): Enable computing an approximated collision geometry from the visual mesh. approximated_collision_model ( type: str , default: 'box' ): Type of approximated collision geometry to be derived from the visual mesh. Options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling vector to be applied to the visual mesh collision_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling vector to be applied to the collision mesh name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. inertia ( type: dict , default: None ): Optional moments of inertia setting to the model in the form of inertia = dict ( ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) use_approximated_inertia ( type: bool , default: True ): Enable computation of moments of inertia based on the mass input and the approximated inertia model setting based on the dimensions of the mesh. approximated_inertia_model ( type: str , default: box ): Type of geometrical approximation to be computed from the visual mesh. The dimensions of the approximated geometry will be then used to compute the moments of inertia of the model. Options are box , cylinder or sphere . Returns A box-shaped pcg_gazebo . simulation . SimulationModel instance.","title":"mesh"},{"location":"python_api/pcg_gazebo.generators/#sphere","text":"sphere ( radius , mass = 0 , name = 'sphere' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None ) Return a sphere-shaped simulation model. Input arguments radius ( type: float ): Radius of the sphere. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns A sphere-shaped pcg_gazebo . simulation . SimulationModel instance.","title":"sphere"},{"location":"python_api/pcg_gazebo.generators/#cylinder","text":"cylinder ( length , radius , mass = 0 , name = 'cylinder' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None ) Return a cylinder-shaped simulation model with the rotation axis set per default as [ 0 , 0 , 1 ] . Input arguments radius ( type: float ): Radius of the cylinder. length ( type: float ): Length of the cylinder. mass ( type: float , default: 0 ): Mass of the model. If the mass is not greater than zero, the model is set as static. name ( type: str , default: 'box' ): Name of the model. pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns A cylinder-shaped pcg_gazebo . simulation . SimulationModel instance.","title":"cylinder"},{"location":"python_api/pcg_gazebo.generators/#box_factory","text":"box_factory ( size , mass = None , name = 'box' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], use_permutation = True , color = None ) Factory function for box-shaped models. It parses the vector size to generate the boxes. The mass can be either a scalar or a vector. If mass is a scalar, all boxes will have the same mass. If the size of the vectors size and mass are the same, the boxes can be generated by associating a size vector with a mass by position in the array or they can be permutated. If the vectors size and mass have different lengths, only permutation can be performed. The size and mass inputs can also be provided as lambda functions as str , such as: size = \"__import__('numpy').random.random((4, 3))\" mass = \"__import__('numpy').arange(1, 10, 4)\" Input arguments size ( type: list or lambda function as str ): List of 3D size vectors mass ( type: float , list of float or lambda function as str , default: None ): Mass of the boxes. If mass is None , all boxes will be static models pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. use_permutation ( type: bool , default: True ): Enable use of permutation to associate the size elements with the mass inputs. If the sizes of the size and mass have different sizes, permutation will be used per default. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns List of pcg_gazebo . simulation . SimulationModel instances.","title":"box_factory"},{"location":"python_api/pcg_gazebo.generators/#sphere_factory","text":"sphere_factory ( radius , mass = None , name = 'sphere' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], use_permutation = True , color = None ) Factory function for sphere-shaped models. It parses the vector radius to generate the spheres. The mass can be either a scalar or a vector. If mass is a scalar, all spheres will have the same mass. If the size of the vectors radius and mass are the same, the spheres can be generated by associating a radius value with a mass by position in the array or they can be permutated. If the vectors radius and mass have different lengths, only permutation can be performed. The radius and mass inputs can also be provided as lambda functions as str , such as: radius = \"__import__('numpy').random.random(2)\" mass = \"__import__('numpy').arange(1, 4, 1)\" Input arguments radius ( type: list or lambda function as str ): List of radius values mass ( type: float , list of float or lambda function as str , default: None ): Mass of the boxes. If mass is None , all spheres will be static models pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. use_permutation ( type: bool , default: True ): Enable use of permutation to associate the radius elements with the mass inputs. If the sizes of the radius and mass have different sizes, permutation will be used per default. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns List of pcg_gazebo . simulation . SimulationModel instances.","title":"sphere_factory"},{"location":"python_api/pcg_gazebo.generators/#cylinder_factory","text":"cylinder_factory ( length , radius , mass = None , name = 'cylinder' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], use_permutation = True , color = None ) Factory function for cylinder-shaped models. It parses the vectors radius and length to generate the cylinders. The mass can be either a scalar or a vector. If mass is a scalar, all cylinders will have the same mass. If the size of the vectors length , radius and mass are the same, the cylinders can be generated by associating a radius and a length value with a mass by position in the array or they can be permutated. If the vectors radius and length have different lengths, only permutation can be performed. The length , radius and mass inputs can also be provided as lambda functions as str , such as: length = \"__import__('numpy').random.random(2)\" radius = \"__import__('numpy').random.random(2)\" mass = \"__import__('numpy').arange(1, 4, 1)\" Input arguments radius ( type: float , list of float or lambda function as str ): List of radius values length ( type: float , list of float or lambda function as str ): List of length values mass ( type: float , list of float or lambda function as str , default: None ): Mass of the cylinders. If mass is None , all cylinders will be static models pose ( type: list or numpy . array , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Origin of the model. use_permutation ( type: bool , default: True ): Enable use of permutation to associate the size elements with the mass inputs. If the sizes of the length and radius have different sizes, permutation will be used per default. color ( type: str or list , default: None ): Color of the model. It can be provided as a RGBA vector, xkcd for a random XKCD color or a specific xkcd color name, and/or random for a random RGBA color. Returns List of pcg_gazebo . simulation . SimulationModel instances.","title":"cylinder_factory"},{"location":"python_api/pcg_gazebo.generators/#config2models","text":"config2models ( config ) Parse the input dict configuration and calls the respective model factory. Input arguments config ( type: dict ): Dictionary with the model generation rules Returns List of pcg_gazebo . simulation . SimulationModel instances.","title":"config2models"},{"location":"python_api/pcg_gazebo.generators/#create_models_from_config","text":"create_models_from_config ( config , n_processes = None ) Creation of models from a dict configuration input using multi-processing. Input arguments config ( type: dict ): Dictionary with the model generation rules n_processes ( type: int , default: None ): Maximum number of processes. If None , then use the number of CPUs available. Returns List of pcg_gazebo . simulation . SimulationModel instances.","title":"create_models_from_config"},{"location":"python_api/pcg_gazebo.generators/#pcg_gazebogeneratorsoccupancy","text":"","title":"pcg_gazebo.generators.occupancy"},{"location":"python_api/pcg_gazebo.generators/#pcg_gazebogeneratorspatterns","text":"","title":"pcg_gazebo.generators.patterns"},{"location":"python_api/pcg_gazebo.generators/#pcg_gazebogeneratorsworld_generator","text":"","title":"pcg_gazebo.generators.world_generator"},{"location":"python_api/pcg_gazebo.generators/#worldgenerator","text":"WorldGenerator ( self , gazebo_proxy = None , output_world_dir = None , output_model_dir = '/tmp/gazebo_models' ) Generation of full Gazebo worlds, including physics engine configuration, modes and lights. Input arguments gazebo_proxy ( type: pcg_gazebo . task_manager . GazeboProxy , default: None ): A GazeboProxy object to enable spawning of models and configuration of the simulation in runtime.","title":"WorldGenerator"},{"location":"python_api/pcg_gazebo.generators/#assets","text":"List of pcg_gazebo . simulation . SimulationModel : List of model assets that will be used of the world generation.","title":"assets"},{"location":"python_api/pcg_gazebo.generators/#constraints","text":"dict of pcg_gazebo . generators . constraints : Dictionary with the positioning constraints.","title":"constraints"},{"location":"python_api/pcg_gazebo.generators/#engines","text":"dict of pcg_gazebo . generators . engines : Dictionary with the model creation engines.","title":"engines"},{"location":"python_api/pcg_gazebo.generators/#gazebo_proxy","text":"pcg_gazebo . task_manager . GazeboProxy : Internal instance of the GazeboProxy","title":"gazebo_proxy"},{"location":"python_api/pcg_gazebo.generators/#name","text":"str : Name of the generated world","title":"name"},{"location":"python_api/pcg_gazebo.generators/#world","text":"pcg_gazebo . simulation . World : World abstraction instance","title":"world"},{"location":"python_api/pcg_gazebo.generators/#init_gazebo_proxy","text":"WorldGenerator . init_gazebo_proxy ( self , ros_host = 'localhost' , ros_port = 11311 , gazebo_host = 'localhost' , gazebo_port = 11345 , timeout = 30 , ignore_services = None ) Initialize a GazeboProxy instance to interface with a running instance of Gazebo. If a GazeboProxy already exists, it will be deleted before a new one is created. Input arguments ros_host ( type: str , default: localhost ): Address of the ROS host machine running roscore . ros_port ( type: int , default: 11311 ): Port number for roscore gazebo_host ( type: str , default: localhost ): Address of the Gazebo server gazebo_port ( type: int , default: 11345 ): Port number of the Gazebo server","title":"init_gazebo_proxy"},{"location":"python_api/pcg_gazebo.generators/#add_engine","text":"WorldGenerator . add_engine ( self , engine_name , models , ** kwargs ) Add a new model creator engine to the internal engines list. Input arguments engine_name ( type: str ): Name of the engine class to be created models ( type: list of str ): Name of the models that will be assets to the created engine kwargs ( type: dict ): Input arguments to the created engine.","title":"add_engine"},{"location":"python_api/pcg_gazebo.generators/#add_constraint","text":"WorldGenerator . add_constraint ( self , name , type , ** kwargs ) Add a new positioning constraint class to the internal constraints list. Input arguments name ( type: str ): ID name for the constraint class instance type ( type: str ): Name of the constraints class to be created kwargs ( type: dict ): Input arguments for the constraint class to be created","title":"add_constraint"},{"location":"python_api/pcg_gazebo.generators/#add_asset","text":"WorldGenerator . add_asset ( self , model ) Add a new model asset that can be used by the engines and added to the generated world. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model","title":"add_asset"},{"location":"python_api/pcg_gazebo.generators/#set_model_as_ground_plane","text":"WorldGenerator . set_model_as_ground_plane ( self , model_name ) Flag a model asset as part of the ground plane. This procedure will affect the collision checks during the automatic placement of models in the world using the placement engines. Input arguments model_name ( type: str ): Name of the model asset","title":"set_model_as_ground_plane"},{"location":"python_api/pcg_gazebo.generators/#get_asset","text":"WorldGenerator . get_asset ( self , name ) Return a simulation model asset. Input arguments name ( type: str ): Name of the model asset. Returns The model asset as pcg_gazebo . simulation . SimulationModel . None if name cannot be found in the list of model assets.","title":"get_asset"},{"location":"python_api/pcg_gazebo.generators/#get_constraint","text":"WorldGenerator . get_constraint ( self , name ) Return a positioning constraint configuration. Input arguments param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"get_constraint"},{"location":"python_api/pcg_gazebo.generators/#add_gazebo_model_as_asset","text":"WorldGenerator . add_gazebo_model_as_asset ( self , gazebo_model_name ) Create a model asset by importing a Gazebo model that already exists in the resources path of the catkin workspace. The model's SDF file will be parsed and converted into a pcg_gazebo . simulation . SimulationModel instance. Models that include lights can also be added, but will not be considered assets, they will just be included into the generated world SDF file. Input arguments gazebo_model_name ( type: str ): ID name from the Gazebo model to be imported Returns True if Gazebo model could be included in the assets list.","title":"add_gazebo_model_as_asset"},{"location":"python_api/pcg_gazebo.generators/#is_asset","text":"WorldGenerator . is_asset ( self , name ) Return True if the model identified by the string name is part of the list of assets. Input arguments name ( type: str ): Name of the model","title":"is_asset"},{"location":"python_api/pcg_gazebo.generators/#add_model_1","text":"WorldGenerator . add_model ( self , model , poses ) Add an instance of pcg_gazebo . simulation . SimulationModel to the world in designed poses. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Parameter description poses ( type: list ): List of 6D pose vectors","title":"add_model"},{"location":"python_api/pcg_gazebo.generators/#add_gazebo_model","text":"WorldGenerator . add_gazebo_model ( self , model_name , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Add an existent Gazebo model to the world in designed poses. Input arguments model_name ( type: str ): ID name of the Gazebo model pose ( type: list ): 6D pose vector","title":"add_gazebo_model"},{"location":"python_api/pcg_gazebo.generators/#remove_asset","text":"WorldGenerator . remove_asset ( self , name ) Remove model asset from the list of assets. Input arguments name ( type: str ): Name of the model Returns True , if model could be removed.","title":"remove_asset"},{"location":"python_api/pcg_gazebo.generators/#delete_model","text":"WorldGenerator . delete_model ( self , model_name ) Delete a model from the currently running Gazebo instance Input arguments model_name ( type: str ): Name of the model Returns True if the model could be deleted from the simulation.","title":"delete_model"},{"location":"python_api/pcg_gazebo.generators/#add_lights_from_gazebo_model","text":"WorldGenerator . add_lights_from_gazebo_model ( self , model_name ) Add light models to the generated world from a Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns True if the lights could be parsed and added to the world.","title":"add_lights_from_gazebo_model"},{"location":"python_api/pcg_gazebo.generators/#parse_configuration","text":"WorldGenerator . parse_configuration ( self , config , verbose = False ) Parse a configuration settings dict with all information on the list of model assets, engines, constraints and lights and instantiate the necessary objects. An example of a YAML file that can hold this kind of information can be seen below: name : world_name assets : - model_1 # This list holds only Gazebo models - model_2 - model_3 ground_plane : # Optional input - model_1 # If model_1 is part of the ground_plane, it should be flagged for collision checking constraints : - name : kitchen # Name identifier type : workspace # Name of the constraint class frame : world geometry : type : area description : points : - [ -6.54833 , -4.17127 , 0 ] - [ -3.24447 , -4.17127 , 0 ] - [ -3.24447 , 0.12423 , 0 ] - [ -6.54833 , 0.12423 , 0 ] - name : tangent_to_ground_plane # Name identifier type : tangent # Name of the constraint class frame : world reference : type : plane args : origin : [ 0 , 0 , 0 ] normal : [ 0 , 0 , 1 ] engines : - engine_name : fixed_pose models : - sll_room_empty poses : - [ 0 , 0 , 0 , 0 , 0 , 0 ] - engine_name : random_pose models : - sll_table_group_futura_seat - sll_table_group_futura model_picker : size max_area : 0.9 no_collision : false max_num : sll_table_group_futura_seat : 6 sll_table_group_futura : 1 policies : - models : - sll_table_group_futura_seat - sll_table_group_futura config : - dofs : - x - y policy : name : workspace args : dining_room - dofs : - z - roll - pitch policy : name : value args : 0 - dofs : - yaw policy : name : uniform args : mean : 0 min : -3.141592653589793 max : 3.141592653589793 constraints : - model : sll_table_group_futura constraint : tangent_to_ground_plane - model : sll_table_group_futura_seat constraint : tangent_to_ground_plane lights : - name : sun # Name of the Gazebo model with the light data Input arguments config ( type: dict ): Configuration settings for the world generator Returns Description of return values","title":"parse_configuration"},{"location":"python_api/pcg_gazebo.generators/#spawn_model","text":"WorldGenerator . spawn_model ( self , model , robot_namespace , pos = [ 0 , 0 , 0 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' , timeout = 30 , replace = False ) Spawn a pcg_gazebo . simulation . SimulationModel in a running instance of Gazebo. A GazeboProxy is required for this method to finish successfully. Input arguments model ( type: pcg_gazebo . simulation . SimulationModel ): Simulation model to be spawned robot_namespace ( type: str ): Name under which the robot should be spawned in Gazebo pos ( type: list , default: [ 0 , 0 , 0 ] ): Spawning position wrt reference frame rot ( type: list , default: [ 0 , 0 , 0 ] ): Roll-Pitch-Yaw angles in radians or a (w, i, j, k) quaternion vector. reference_frame ( type: str , default: world ): Reference frame for the spawning pose timeout ( type: float ): Timeout in seconds to wait for Gazebo to start replace ( type: bool , default: False ): Replace the model in the simulation in case a model with the same name already exists. Returns True if the model could be spawned.","title":"spawn_model"},{"location":"python_api/pcg_gazebo.generators/#get_physics_engine","text":"WorldGenerator . get_physics_engine ( self , engine = 'ode' ) Return an instance of a physics engine as pcg_gazebo . simulation . physics . Physics object. Input arguments engine ( type: str ): ID name of the physics engine, options are ode , bullet and simbody . Returns An pcg_gazebo . simulation . physics . Physics object.","title":"get_physics_engine"},{"location":"python_api/pcg_gazebo.generators/#run_engines","text":"WorldGenerator . run_engines ( self , attach_models = False ) Run all the model placement engines and add the generated models in the internal instance of the world representation. Input arguments attach_models ( type: bool , default: False ): Attach the generated models to the existent list of models in the world Returns True if all engines ran successfully.","title":"run_engines"},{"location":"python_api/pcg_gazebo.generators/#reset_world","text":"WorldGenerator . reset_world ( self , name , engine = 'ode' , gravity = [ 0 , 0 , - 9.8 ]) Reset the generated world instance to its default state and without any models. Input arguments name ( type: str ): Name of the world engine ( type: str , default: ode ): Name of the physics engine to be used. Options are ode , bullet or simbody . gravity ( type: list , default: [ 0 , 0 , - 9 . 8 ] ): Gravitational acceleration vector","title":"reset_world"},{"location":"python_api/pcg_gazebo.generators/#export_world","text":"WorldGenerator . export_world ( self , output_dir = None , filename = None , with_default_ground_plane = True , with_default_sun = True ) Export world to an SDF file that can be used by Gazebo. Input arguments output_dir ( type: str , default: None ): Path to output directory to store the world file. filename ( type: str , default: None ): Name of the SDF world file with_default_ground_plane ( type: bool , default: True ): Add the default ground plane model to the world before exporting it with_default_sun ( type: bool , default: True ): Add the default sun model to the world before exporting it Returns Full name of the exported SDF world file as a str","title":"export_world"},{"location":"python_api/pcg_gazebo.generators/#plot_results","text":"WorldGenerator . plot_results ( self , fig = None , fig_width = 1000 , fig_height = 800 , footprint_geometry = 'collision' , engine = 'bokeh' ) Plot the footprints of models included in the current world instance. Input arguments fig ( type: a bokeh or a matplotlib figure, default: None ): A figure object. If fig is None , a new figure will be created fig_width ( type: int , default: 1000 ): Width of the figure param ( type: data_type , default: data ): Parameter description Returns Description of return values","title":"plot_results"},{"location":"python_api/pcg_gazebo/","text":"pcg_gazebo \u00b6 Procedural generation package This module implements the client for the procedural generation plugins in Gazebo. This interface allows using Python to control the simulation state in runtime with the help of the specific plugins write in the pcg_gazebo_ros_plugins . Example: Attributes: module_level_variable1 (int): Todo: * For module TODOs pcg_gazebo.log \u00b6 pcg_gazebo.transformations \u00b6 Homogeneous Transformation Matrices and Quaternions. A library for calculating 4x4 matrices for translating, rotating, reflecting, scaling, shearing, projecting, orthogonalizing, and superimposing arrays of 3D homogeneous coordinates as well as for converting between rotation matrices, Euler angles, and quaternions. Also includes an Arcball control object and functions to decompose transformation matrices. :Authors: Christoph Gohlke < http : // www . lfd . uci . edu /~ gohlke /> __, Laboratory for Fluorescence Dynamics, University of California, Irvine :Version: 20090418 Requirements \u00b6 Python 2 . 6 < http : // www . python . org > __ Numpy 1 . 3 < http : // numpy . scipy . org > __ transformations . c 20090418 < http : // www . lfd . uci . edu /~ gohlke /> __ (optional implementation of some functions in C) Notes \u00b6 Matrices (M) can be inverted using numpy.linalg.inv(M), concatenated using numpy.dot(M0, M1), or used to transform homogeneous coordinates (v) using numpy.dot(M, v) for shape (4, *) \"point of arrays\", respectively numpy.dot(v, M.T) for shape (*, 4) \"array of points\". Calculations are carried out with numpy.float64 precision. This Python implementation is not optimized for speed. Vector, point, quaternion, and matrix function arguments are expected to be \"array like\", i.e. tuple, list, or numpy arrays. Return types are numpy arrays unless specified otherwise. Angles are in radians unless specified otherwise. Quaternions ix+jy+kz+w are represented as [x, y, z, w]. Use the transpose of transformation matrices for OpenGL glMultMatrixd(). A triple of Euler angles can be applied/interpreted in 24 ways, which can be specified using a 4 character string or encoded 4-tuple: Axes 4-string : e.g. 'sxyz' or 'ryxy' first character : rotations are applied to 's'tatic or 'r'otating frame remaining characters : successive rotation axis 'x', 'y', or 'z' Axes 4-tuple : e.g. (0, 0, 0, 0) or (1, 1, 1, 1) inner axis: code of axis ('x':0, 'y':1, 'z':2) of rightmost matrix. parity : even (0) if inner axis 'x' is followed by 'y', 'y' is followed by 'z', or 'z' is followed by 'x'. Otherwise odd (1). repetition : first and last axis are same (1) or different (0). frame : rotations are applied to static (0) or rotating (1) frame. References \u00b6 (1) Matrices and transformations. Ronald Goldman. In \"Graphics Gems I\", pp 472-475. Morgan Kaufmann, 1990. (2) More matrices and transformations: shear and pseudo-perspective. Ronald Goldman. In \"Graphics Gems II\", pp 320-323. Morgan Kaufmann, 1991. (3) Decomposing a matrix into simple transformations. Spencer Thomas. In \"Graphics Gems II\", pp 320-323. Morgan Kaufmann, 1991. (4) Recovering the data from the transformation matrix. Ronald Goldman. In \"Graphics Gems II\", pp 324-331. Morgan Kaufmann, 1991. (5) Euler angle conversion. Ken Shoemake. In \"Graphics Gems IV\", pp 222-229. Morgan Kaufmann, 1994. (6) Arcball rotation control. Ken Shoemake. In \"Graphics Gems IV\", pp 175-192. Morgan Kaufmann, 1994. (7) Representing attitude: Euler angles, unit quaternions, and rotation vectors. James Diebel. 2006. (8) A discussion of the solution for the best rotation to relate two sets of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828. (9) Closed-form solution of absolute orientation using unit quaternions. BKP Horn. J Opt Soc Am A. 1987. 4(4), 629-642. (10) Quaternions. Ken Shoemake. http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf (11) From quaternion to matrix and back. JMP van Waveren. 2005. http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm (12) Uniform random rotations. Ken Shoemake. In \"Graphics Gems III\", pp 124-132. Morgan Kaufmann, 1992. Examples \u00b6 alpha, beta, gamma = 0.123, -1.234, 2.345 origin, xaxis, yaxis, zaxis = (0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1) I = identity_matrix() Rx = rotation_matrix(alpha, xaxis) Ry = rotation_matrix(beta, yaxis) Rz = rotation_matrix(gamma, zaxis) R = concatenate_matrices(Rx, Ry, Rz) euler = euler_from_matrix(R, 'rxyz') numpy.allclose([alpha, beta, gamma], euler) True Re = euler_matrix(alpha, beta, gamma, 'rxyz') is_same_transform(R, Re) True al, be, ga = euler_from_matrix(Re, 'rxyz') is_same_transform(Re, euler_matrix(al, be, ga, 'rxyz')) True qx = quaternion_about_axis(alpha, xaxis) qy = quaternion_about_axis(beta, yaxis) qz = quaternion_about_axis(gamma, zaxis) q = quaternion_multiply(qx, qy) q = quaternion_multiply(q, qz) Rq = quaternion_matrix(q) is_same_transform(R, Rq) True S = scale_matrix(1.23, origin) T = translation_matrix((1, 2, 3)) Z = shear_matrix(beta, xaxis, origin, zaxis) R = random_rotation_matrix(numpy.random.rand(3)) M = concatenate_matrices(T, R, Z, S) scale, shear, angles, trans, persp = decompose_matrix(M) numpy.allclose(scale, 1.23) True numpy.allclose(trans, (1, 2, 3)) True numpy.allclose(shear, (0, math.tan(beta), 0)) True is_same_transform(R, euler_matrix(axes='sxyz', *angles)) True M1 = compose_matrix(scale, shear, angles, trans, persp) is_same_transform(M, M1) True identity_matrix \u00b6 identity_matrix () Return 4x4 identity/unit matrix. I = identity_matrix() numpy.allclose(I, numpy.dot(I, I)) True numpy.sum(I), numpy.trace(I) (4.0, 4.0) numpy.allclose(I, numpy.identity(4, dtype=numpy.float64)) True translation_matrix \u00b6 translation_matrix ( direction ) Return matrix to translate by direction vector. v = numpy.random.random(3) - 0.5 numpy.allclose(v, translation_matrix(v)[:3, 3]) True translation_from_matrix \u00b6 translation_from_matrix ( matrix ) Return translation vector from translation matrix. v0 = numpy.random.random(3) - 0.5 v1 = translation_from_matrix(translation_matrix(v0)) numpy.allclose(v0, v1) True reflection_matrix \u00b6 reflection_matrix ( point , normal ) Return matrix to mirror at plane defined by point and normal vector. v0 = numpy.random.random(4) - 0.5 v0[3] = 1.0 v1 = numpy.random.random(3) - 0.5 R = reflection_matrix(v0, v1) numpy.allclose(2., numpy.trace(R)) True numpy.allclose(v0, numpy.dot(R, v0)) True v2 = v0.copy() v2[:3] += v1 v3 = v0.copy() v2[:3] -= v1 numpy.allclose(v2, numpy.dot(R, v3)) True reflection_from_matrix \u00b6 reflection_from_matrix ( matrix ) Return mirror plane point and normal vector from reflection matrix. v0 = numpy.random.random(3) - 0.5 v1 = numpy.random.random(3) - 0.5 M0 = reflection_matrix(v0, v1) point, normal = reflection_from_matrix(M0) M1 = reflection_matrix(point, normal) is_same_transform(M0, M1) True rotation_matrix \u00b6 rotation_matrix ( angle , direction , point = None ) Return matrix to rotate about axis defined by point and direction. angle = (random.random() - 0.5) * (2*math.pi) direc = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 R0 = rotation_matrix(angle, direc, point) R1 = rotation_matrix(angle-2*math.pi, direc, point) is_same_transform(R0, R1) True R0 = rotation_matrix(angle, direc, point) R1 = rotation_matrix(-angle, -direc, point) is_same_transform(R0, R1) True I = numpy.identity(4, numpy.float64) numpy.allclose(I, rotation_matrix(math.pi*2, direc)) True numpy.allclose(2., numpy.trace(rotation_matrix(math.pi/2, ... direc, point))) True rotation_from_matrix \u00b6 rotation_from_matrix ( matrix ) Return rotation angle and axis from rotation matrix. angle = (random.random() - 0.5) * (2*math.pi) direc = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 R0 = rotation_matrix(angle, direc, point) angle, direc, point = rotation_from_matrix(R0) R1 = rotation_matrix(angle, direc, point) is_same_transform(R0, R1) True scale_matrix \u00b6 scale_matrix ( factor , origin = None , direction = None ) Return matrix to scale by factor around origin in direction. Use factor -1 for point symmetry. v = (numpy.random.rand(4, 5) - 0.5) * 20.0 v[3] = 1.0 S = scale_matrix(-1.234) numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3]) True factor = random.random() * 10 - 5 origin = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 S = scale_matrix(factor, origin) S = scale_matrix(factor, origin, direct) scale_from_matrix \u00b6 scale_from_matrix ( matrix ) Return scaling factor, origin and direction from scaling matrix. factor = random.random() * 10 - 5 origin = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 S0 = scale_matrix(factor, origin) factor, origin, direction = scale_from_matrix(S0) S1 = scale_matrix(factor, origin, direction) is_same_transform(S0, S1) True S0 = scale_matrix(factor, origin, direct) factor, origin, direction = scale_from_matrix(S0) S1 = scale_matrix(factor, origin, direction) is_same_transform(S0, S1) True projection_matrix \u00b6 projection_matrix ( point , normal , direction = None , perspective = None , pseudo = False ) Return matrix to project onto plane defined by point and normal. Using either perspective point, projection direction, or none of both. If pseudo is True, perspective projections will preserve relative depth such that Perspective = dot(Orthogonal, PseudoPerspective). P = projection_matrix((0, 0, 0), (1, 0, 0)) numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:]) True point = numpy.random.random(3) - 0.5 normal = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 persp = numpy.random.random(3) - 0.5 P0 = projection_matrix(point, normal) P1 = projection_matrix(point, normal, direction=direct) P2 = projection_matrix(point, normal, perspective=persp) P3 = projection_matrix(point, normal, perspective=persp, pseudo=True) is_same_transform(P2, numpy.dot(P0, P3)) True P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0)) v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0 v0[3] = 1.0 v1 = numpy.dot(P, v0) numpy.allclose(v1[1], v0[1]) True numpy.allclose(v1[0], 3.0-v1[1]) True projection_from_matrix \u00b6 projection_from_matrix ( matrix , pseudo = False ) Return projection plane and perspective point from projection matrix. Return values are same as arguments for projection_matrix function: point, normal, direction, perspective, and pseudo. point = numpy.random.random(3) - 0.5 normal = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 persp = numpy.random.random(3) - 0.5 P0 = projection_matrix(point, normal) result = projection_from_matrix(P0) P1 = projection_matrix(*result) is_same_transform(P0, P1) True P0 = projection_matrix(point, normal, direct) result = projection_from_matrix(P0) P1 = projection_matrix(*result) is_same_transform(P0, P1) True P0 = projection_matrix(point, normal, perspective=persp, pseudo=False) result = projection_from_matrix(P0, pseudo=False) P1 = projection_matrix(*result) is_same_transform(P0, P1) True P0 = projection_matrix(point, normal, perspective=persp, pseudo=True) result = projection_from_matrix(P0, pseudo=True) P1 = projection_matrix(*result) is_same_transform(P0, P1) True clip_matrix \u00b6 clip_matrix ( left , right , bottom , top , near , far , perspective = False ) Return matrix to obtain normalized device coordinates from frustrum. The frustrum bounds are axis-aligned along x (left, right), y (bottom, top) and z (near, far). Normalized device coordinates are in range [-1, 1] if coordinates are inside the frustrum. If perspective is True the frustrum is a truncated pyramid with the perspective point at origin and direction along z axis, otherwise an orthographic canonical view volume (a box). Homogeneous coordinates transformed by the perspective clip matrix need to be dehomogenized (devided by w coordinate). frustrum = numpy.random.rand(6) frustrum[1] += frustrum[0] frustrum[3] += frustrum[2] frustrum[5] += frustrum[4] M = clip_matrix(*frustrum, perspective=False) numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) array([-1., -1., -1., 1.]) numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0]) array([ 1., 1., 1., 1.]) M = clip_matrix(*frustrum, perspective=True) v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) v / v[3] array([-1., -1., -1., 1.]) v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0]) v / v[3] array([ 1., 1., -1., 1.]) shear_matrix \u00b6 shear_matrix ( angle , direction , point , normal ) Return matrix to shear by angle along direction vector on shear plane. The shear plane is defined by a point and normal vector. The direction vector must be orthogonal to the plane's normal vector. A point P is transformed by the shear matrix into P\" such that the vector P-P\" is parallel to the direction vector and its extent is given by the angle of P-P'-P\", where P' is the orthogonal projection of P onto the shear plane. angle = (random.random() - 0.5) * 4*math.pi direct = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 normal = numpy.cross(direct, numpy.random.random(3)) S = shear_matrix(angle, direct, point, normal) numpy.allclose(1.0, numpy.linalg.det(S)) True shear_from_matrix \u00b6 shear_from_matrix ( matrix ) Return shear angle, direction and plane from shear matrix. angle = (random.random() - 0.5) * 4*math.pi direct = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 normal = numpy.cross(direct, numpy.random.random(3)) S0 = shear_matrix(angle, direct, point, normal) angle, direct, point, normal = shear_from_matrix(S0) S1 = shear_matrix(angle, direct, point, normal) is_same_transform(S0, S1) True decompose_matrix \u00b6 decompose_matrix ( matrix ) Return sequence of transformations from transformation matrix. matrix : array_like Non-degenerative homogeneous transformation matrix Return tuple of: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix Raise ValueError if matrix is of wrong type or degenerative. T0 = translation_matrix((1, 2, 3)) scale, shear, angles, trans, persp = decompose_matrix(T0) T1 = translation_matrix(trans) numpy.allclose(T0, T1) True S = scale_matrix(0.123) scale, shear, angles, trans, persp = decompose_matrix(S) scale[0] 0.123 R0 = euler_matrix(1, 2, 3) scale, shear, angles, trans, persp = decompose_matrix(R0) R1 = euler_matrix(*angles) numpy.allclose(R0, R1) True compose_matrix \u00b6 compose_matrix ( scale = None , shear = None , angles = None , translate = None , perspective = None ) Return transformation matrix from sequence of transformations. This is the inverse of the decompose_matrix function. Sequence of transformations: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix scale = numpy.random.random(3) - 0.5 shear = numpy.random.random(3) - 0.5 angles = (numpy.random.random(3) - 0.5) * (2*math.pi) trans = numpy.random.random(3) - 0.5 persp = numpy.random.random(4) - 0.5 M0 = compose_matrix(scale, shear, angles, trans, persp) result = decompose_matrix(M0) M1 = compose_matrix(*result) is_same_transform(M0, M1) True orthogonalization_matrix \u00b6 orthogonalization_matrix ( lengths , angles ) Return orthogonalization matrix for crystallographic cell coordinates. Angles are expected in degrees. The de-orthogonalization matrix is the inverse. O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.)) numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10) True O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7]) numpy.allclose(numpy.sum(O), 43.063229) True superimposition_matrix \u00b6 superimposition_matrix ( v0 , v1 , scaling = False , usesvd = True ) Return matrix to transform given vector set into second vector set. v0 and v1 are shape (3, *) or (4, *) arrays of at least 3 vectors. If usesvd is True, the weighted sum of squared deviations (RMSD) is minimized according to the algorithm by W. Kabsch [8]. Otherwise the quaternion based algorithm by B. Horn [9] is used (slower when using this Python implementation). The returned matrix performs rotation, translation and uniform scaling (if specified). v0 = numpy.random.rand(3, 10) M = superimposition_matrix(v0, v0) numpy.allclose(M, numpy.identity(4)) True R = random_rotation_matrix(numpy.random.random(3)) v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1)) v1 = numpy.dot(R, v0) M = superimposition_matrix(v0, v1) numpy.allclose(v1, numpy.dot(M, v0)) True v0 = (numpy.random.rand(4, 100) - 0.5) * 20.0 v0[3] = 1.0 v1 = numpy.dot(R, v0) M = superimposition_matrix(v0, v1) numpy.allclose(v1, numpy.dot(M, v0)) True S = scale_matrix(random.random()) T = translation_matrix(numpy.random.random(3)-0.5) M = concatenate_matrices(T, R, S) v1 = numpy.dot(M, v0) v0[:3] += numpy.random.normal(0.0, 1e-9, 300).reshape(3, -1) M = superimposition_matrix(v0, v1, scaling=True) numpy.allclose(v1, numpy.dot(M, v0)) True M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) numpy.allclose(v1, numpy.dot(M, v0)) True v = numpy.empty((4, 100, 3), dtype=numpy.float64) v[:, :, 0] = v0 M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) numpy.allclose(v1, numpy.dot(M, v[:, :, 0])) True euler_matrix \u00b6 euler_matrix ( ai , aj , ak , axes = 'sxyz' ) Return homogeneous rotation matrix from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple R = euler_matrix(1, 2, 3, 'syxz') numpy.allclose(numpy.sum(R[0]), -1.34786452) True R = euler_matrix(1, 2, 3, (0, 1, 0, 1)) numpy.allclose(numpy.sum(R[0]), -0.383436184) True ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5) for axes in _AXES2TUPLE.keys(): ... R = euler_matrix(ai, aj, ak, axes) for axes in _TUPLE2AXES.keys(): ... R = euler_matrix(ai, aj, ak, axes) euler_from_matrix \u00b6 euler_from_matrix ( matrix , axes = 'sxyz' ) Return Euler angles from rotation matrix for specified axis sequence. axes : One of 24 axis sequences as string or encoded tuple Note that many Euler angle triplets can describe one matrix. R0 = euler_matrix(1, 2, 3, 'syxz') al, be, ga = euler_from_matrix(R0, 'syxz') R1 = euler_matrix(al, be, ga, 'syxz') numpy.allclose(R0, R1) True angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5) for axes in _AXES2TUPLE.keys(): ... R0 = euler_matrix(axes=axes, *angles) ... R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes)) ... if not numpy.allclose(R0, R1): print axes, \"failed\" euler_from_quaternion \u00b6 euler_from_quaternion ( quaternion , axes = 'sxyz' ) Return Euler angles from quaternion for specified axis sequence. angles = euler_from_quaternion([0.06146124, 0, 0, 0.99810947]) numpy.allclose(angles, [0.123, 0, 0]) True quaternion_from_euler \u00b6 quaternion_from_euler ( ai , aj , ak , axes = 'sxyz' ) Return quaternion from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple q = quaternion_from_euler(1, 2, 3, 'ryxz') numpy.allclose(q, [0.310622, -0.718287, 0.444435, 0.435953]) True quaternion_about_axis \u00b6 quaternion_about_axis ( angle , axis ) Return quaternion for rotation about axis. q = quaternion_about_axis(0.123, (1, 0, 0)) numpy.allclose(q, [0.06146124, 0, 0, 0.99810947]) True quaternion_matrix \u00b6 quaternion_matrix ( quaternion ) Return homogeneous rotation matrix from quaternion. R = quaternion_matrix([0.06146124, 0, 0, 0.99810947]) numpy.allclose(R, rotation_matrix(0.123, (1, 0, 0))) True quaternion_from_matrix \u00b6 quaternion_from_matrix ( matrix ) Return quaternion from rotation matrix. R = rotation_matrix(0.123, (1, 2, 3)) q = quaternion_from_matrix(R) numpy.allclose(q, [0.0164262, 0.0328524, 0.0492786, 0.9981095]) True quaternion_multiply \u00b6 quaternion_multiply ( quaternion1 , quaternion0 ) Return multiplication of two quaternions. q = quaternion_multiply([1, -2, 3, 4], [-5, 6, 7, 8]) numpy.allclose(q, [-44, -14, 48, 28]) True quaternion_conjugate \u00b6 quaternion_conjugate ( quaternion ) Return conjugate of quaternion. q0 = random_quaternion() q1 = quaternion_conjugate(q0) q1[3] == q0[3] and all(q1[:3] == -q0[:3]) True quaternion_inverse \u00b6 quaternion_inverse ( quaternion ) Return inverse of quaternion. q0 = random_quaternion() q1 = quaternion_inverse(q0) numpy.allclose(quaternion_multiply(q0, q1), [0, 0, 0, 1]) True quaternion_slerp \u00b6 quaternion_slerp ( quat0 , quat1 , fraction , spin = 0 , shortestpath = True ) Return spherical linear interpolation between two quaternions. q0 = random_quaternion() q1 = random_quaternion() q = quaternion_slerp(q0, q1, 0.0) numpy.allclose(q, q0) True q = quaternion_slerp(q0, q1, 1.0, 1) numpy.allclose(q, q1) True q = quaternion_slerp(q0, q1, 0.5) angle = math.acos(numpy.dot(q0, q)) numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) / angle) or numpy.allclose(2.0, math.acos(-numpy.dot(q0, q1)) / angle) True random_quaternion \u00b6 random_quaternion ( rand = None ) Return uniform random unit quaternion. rand: array like or None Three independent random variables that are uniformly distributed between 0 and 1. q = random_quaternion() numpy.allclose(1.0, vector_norm(q)) True q = random_quaternion(numpy.random.random(3)) q.shape (4,) random_rotation_matrix \u00b6 random_rotation_matrix ( rand = None ) Return uniform random rotation matrix. rnd: array like Three independent random variables that are uniformly distributed between 0 and 1 for each returned quaternion. R = random_rotation_matrix() numpy.allclose(numpy.dot(R.T, R), numpy.identity(4)) True Arcball \u00b6 Arcball ( self , initial = None ) Virtual Trackball Control. ball = Arcball() ball = Arcball(initial=numpy.identity(4)) ball.place([320, 320], 320) ball.down([500, 250]) ball.drag([475, 275]) R = ball.matrix() numpy.allclose(numpy.sum(R), 3.90583455) True ball = Arcball(initial=[0, 0, 0, 1]) ball.place([320, 320], 320) ball.setaxes([1,1,0], [-1, 1, 0]) ball.setconstrain(True) ball.down([400, 200]) ball.drag([200, 400]) R = ball.matrix() numpy.allclose(numpy.sum(R), 0.2055924) True ball.next() place \u00b6 Arcball . place ( self , center , radius ) Place Arcball, e.g. when window size changes. center : sequence[2] Window coordinates of trackball center. radius : float Radius of trackball in window coordinates. setaxes \u00b6 Arcball . setaxes ( self , * axes ) Set axes to constrain rotations. setconstrain \u00b6 Arcball . setconstrain ( self , constrain ) Set state of constrain to axis mode. getconstrain \u00b6 Arcball . getconstrain ( self ) Return state of constrain to axis mode. down \u00b6 Arcball . down ( self , point ) Set initial cursor window coordinates and pick constrain-axis. drag \u00b6 Arcball . drag ( self , point ) Update current cursor window coordinates. next \u00b6 Arcball . next ( self , acceleration = 0.0 ) Continue rotation in direction of last drag. matrix \u00b6 Arcball . matrix ( self ) Return homogeneous rotation matrix. arcball_map_to_sphere \u00b6 arcball_map_to_sphere ( point , center , radius ) Return unit sphere coordinates from window coordinates. arcball_constrain_to_axis \u00b6 arcball_constrain_to_axis ( point , axis ) Return sphere point perpendicular to axis. arcball_nearest_axis \u00b6 arcball_nearest_axis ( point , axes ) Return axis, which arc is nearest to point. vector_norm \u00b6 vector_norm ( data , axis = None , out = None ) Return length, i.e. eucledian norm, of ndarray along axis. v = numpy.random.random(3) n = vector_norm(v) numpy.allclose(n, numpy.linalg.norm(v)) True v = numpy.random.rand(6, 5, 3) n = vector_norm(v, axis=-1) numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2))) True n = vector_norm(v, axis=1) numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True v = numpy.random.rand(5, 4, 3) n = numpy.empty((5, 3), dtype=numpy.float64) vector_norm(v, axis=1, out=n) numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True vector_norm([]) 0.0 vector_norm([1.0]) 1.0 unit_vector \u00b6 unit_vector ( data , axis = None , out = None ) Return ndarray normalized by length, i.e. eucledian norm, along axis. v0 = numpy.random.random(3) v1 = unit_vector(v0) numpy.allclose(v1, v0 / numpy.linalg.norm(v0)) True v0 = numpy.random.rand(5, 4, 3) v1 = unit_vector(v0, axis=-1) v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2) numpy.allclose(v1, v2) True v1 = unit_vector(v0, axis=1) v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1) numpy.allclose(v1, v2) True v1 = numpy.empty((5, 4, 3), dtype=numpy.float64) unit_vector(v0, axis=1, out=v1) numpy.allclose(v1, v2) True list(unit_vector([])) [] list(unit_vector([1.0])) [1.0] random_vector \u00b6 random_vector ( size ) Return array of random doubles in the half-open interval [0.0, 1.0). v = random_vector(10000) numpy.all(v >= 0.0) and numpy.all(v < 1.0) True v0 = random_vector(10) v1 = random_vector(10) numpy.any(v0 == v1) False inverse_matrix \u00b6 inverse_matrix ( matrix ) Return inverse of square transformation matrix. M0 = random_rotation_matrix() M1 = inverse_matrix(M0.T) numpy.allclose(M1, numpy.linalg.inv(M0.T)) True for size in range(1, 7): ... M0 = numpy.random.rand(size, size) ... M1 = inverse_matrix(M0) ... if not numpy.allclose(M1, numpy.linalg.inv(M0)): print size concatenate_matrices \u00b6 concatenate_matrices ( * matrices ) Return concatenation of series of transformation matrices. M = numpy.random.rand(16).reshape((4, 4)) - 0.5 numpy.allclose(M, concatenate_matrices(M)) True numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T)) True is_same_transform \u00b6 is_same_transform ( matrix0 , matrix1 ) Return True if two matrices perform same transformation. is_same_transform(numpy.identity(4), numpy.identity(4)) True is_same_transform(numpy.identity(4), random_rotation_matrix()) False pcg_gazebo.visualization \u00b6","title":"pcg_gazebo"},{"location":"python_api/pcg_gazebo/#pcg_gazebo","text":"Procedural generation package This module implements the client for the procedural generation plugins in Gazebo. This interface allows using Python to control the simulation state in runtime with the help of the specific plugins write in the pcg_gazebo_ros_plugins . Example: Attributes: module_level_variable1 (int): Todo: * For module TODOs","title":"pcg_gazebo"},{"location":"python_api/pcg_gazebo/#pcg_gazebolog","text":"","title":"pcg_gazebo.log"},{"location":"python_api/pcg_gazebo/#pcg_gazebotransformations","text":"Homogeneous Transformation Matrices and Quaternions. A library for calculating 4x4 matrices for translating, rotating, reflecting, scaling, shearing, projecting, orthogonalizing, and superimposing arrays of 3D homogeneous coordinates as well as for converting between rotation matrices, Euler angles, and quaternions. Also includes an Arcball control object and functions to decompose transformation matrices. :Authors: Christoph Gohlke < http : // www . lfd . uci . edu /~ gohlke /> __, Laboratory for Fluorescence Dynamics, University of California, Irvine :Version: 20090418","title":"pcg_gazebo.transformations"},{"location":"python_api/pcg_gazebo/#requirements","text":"Python 2 . 6 < http : // www . python . org > __ Numpy 1 . 3 < http : // numpy . scipy . org > __ transformations . c 20090418 < http : // www . lfd . uci . edu /~ gohlke /> __ (optional implementation of some functions in C)","title":"Requirements"},{"location":"python_api/pcg_gazebo/#notes","text":"Matrices (M) can be inverted using numpy.linalg.inv(M), concatenated using numpy.dot(M0, M1), or used to transform homogeneous coordinates (v) using numpy.dot(M, v) for shape (4, *) \"point of arrays\", respectively numpy.dot(v, M.T) for shape (*, 4) \"array of points\". Calculations are carried out with numpy.float64 precision. This Python implementation is not optimized for speed. Vector, point, quaternion, and matrix function arguments are expected to be \"array like\", i.e. tuple, list, or numpy arrays. Return types are numpy arrays unless specified otherwise. Angles are in radians unless specified otherwise. Quaternions ix+jy+kz+w are represented as [x, y, z, w]. Use the transpose of transformation matrices for OpenGL glMultMatrixd(). A triple of Euler angles can be applied/interpreted in 24 ways, which can be specified using a 4 character string or encoded 4-tuple: Axes 4-string : e.g. 'sxyz' or 'ryxy' first character : rotations are applied to 's'tatic or 'r'otating frame remaining characters : successive rotation axis 'x', 'y', or 'z' Axes 4-tuple : e.g. (0, 0, 0, 0) or (1, 1, 1, 1) inner axis: code of axis ('x':0, 'y':1, 'z':2) of rightmost matrix. parity : even (0) if inner axis 'x' is followed by 'y', 'y' is followed by 'z', or 'z' is followed by 'x'. Otherwise odd (1). repetition : first and last axis are same (1) or different (0). frame : rotations are applied to static (0) or rotating (1) frame.","title":"Notes"},{"location":"python_api/pcg_gazebo/#references","text":"(1) Matrices and transformations. Ronald Goldman. In \"Graphics Gems I\", pp 472-475. Morgan Kaufmann, 1990. (2) More matrices and transformations: shear and pseudo-perspective. Ronald Goldman. In \"Graphics Gems II\", pp 320-323. Morgan Kaufmann, 1991. (3) Decomposing a matrix into simple transformations. Spencer Thomas. In \"Graphics Gems II\", pp 320-323. Morgan Kaufmann, 1991. (4) Recovering the data from the transformation matrix. Ronald Goldman. In \"Graphics Gems II\", pp 324-331. Morgan Kaufmann, 1991. (5) Euler angle conversion. Ken Shoemake. In \"Graphics Gems IV\", pp 222-229. Morgan Kaufmann, 1994. (6) Arcball rotation control. Ken Shoemake. In \"Graphics Gems IV\", pp 175-192. Morgan Kaufmann, 1994. (7) Representing attitude: Euler angles, unit quaternions, and rotation vectors. James Diebel. 2006. (8) A discussion of the solution for the best rotation to relate two sets of vectors. W Kabsch. Acta Cryst. 1978. A34, 827-828. (9) Closed-form solution of absolute orientation using unit quaternions. BKP Horn. J Opt Soc Am A. 1987. 4(4), 629-642. (10) Quaternions. Ken Shoemake. http://www.sfu.ca/~jwa3/cmpt461/files/quatut.pdf (11) From quaternion to matrix and back. JMP van Waveren. 2005. http://www.intel.com/cd/ids/developer/asmo-na/eng/293748.htm (12) Uniform random rotations. Ken Shoemake. In \"Graphics Gems III\", pp 124-132. Morgan Kaufmann, 1992.","title":"References"},{"location":"python_api/pcg_gazebo/#examples","text":"alpha, beta, gamma = 0.123, -1.234, 2.345 origin, xaxis, yaxis, zaxis = (0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1) I = identity_matrix() Rx = rotation_matrix(alpha, xaxis) Ry = rotation_matrix(beta, yaxis) Rz = rotation_matrix(gamma, zaxis) R = concatenate_matrices(Rx, Ry, Rz) euler = euler_from_matrix(R, 'rxyz') numpy.allclose([alpha, beta, gamma], euler) True Re = euler_matrix(alpha, beta, gamma, 'rxyz') is_same_transform(R, Re) True al, be, ga = euler_from_matrix(Re, 'rxyz') is_same_transform(Re, euler_matrix(al, be, ga, 'rxyz')) True qx = quaternion_about_axis(alpha, xaxis) qy = quaternion_about_axis(beta, yaxis) qz = quaternion_about_axis(gamma, zaxis) q = quaternion_multiply(qx, qy) q = quaternion_multiply(q, qz) Rq = quaternion_matrix(q) is_same_transform(R, Rq) True S = scale_matrix(1.23, origin) T = translation_matrix((1, 2, 3)) Z = shear_matrix(beta, xaxis, origin, zaxis) R = random_rotation_matrix(numpy.random.rand(3)) M = concatenate_matrices(T, R, Z, S) scale, shear, angles, trans, persp = decompose_matrix(M) numpy.allclose(scale, 1.23) True numpy.allclose(trans, (1, 2, 3)) True numpy.allclose(shear, (0, math.tan(beta), 0)) True is_same_transform(R, euler_matrix(axes='sxyz', *angles)) True M1 = compose_matrix(scale, shear, angles, trans, persp) is_same_transform(M, M1) True","title":"Examples"},{"location":"python_api/pcg_gazebo/#identity_matrix","text":"identity_matrix () Return 4x4 identity/unit matrix. I = identity_matrix() numpy.allclose(I, numpy.dot(I, I)) True numpy.sum(I), numpy.trace(I) (4.0, 4.0) numpy.allclose(I, numpy.identity(4, dtype=numpy.float64)) True","title":"identity_matrix"},{"location":"python_api/pcg_gazebo/#translation_matrix","text":"translation_matrix ( direction ) Return matrix to translate by direction vector. v = numpy.random.random(3) - 0.5 numpy.allclose(v, translation_matrix(v)[:3, 3]) True","title":"translation_matrix"},{"location":"python_api/pcg_gazebo/#translation_from_matrix","text":"translation_from_matrix ( matrix ) Return translation vector from translation matrix. v0 = numpy.random.random(3) - 0.5 v1 = translation_from_matrix(translation_matrix(v0)) numpy.allclose(v0, v1) True","title":"translation_from_matrix"},{"location":"python_api/pcg_gazebo/#reflection_matrix","text":"reflection_matrix ( point , normal ) Return matrix to mirror at plane defined by point and normal vector. v0 = numpy.random.random(4) - 0.5 v0[3] = 1.0 v1 = numpy.random.random(3) - 0.5 R = reflection_matrix(v0, v1) numpy.allclose(2., numpy.trace(R)) True numpy.allclose(v0, numpy.dot(R, v0)) True v2 = v0.copy() v2[:3] += v1 v3 = v0.copy() v2[:3] -= v1 numpy.allclose(v2, numpy.dot(R, v3)) True","title":"reflection_matrix"},{"location":"python_api/pcg_gazebo/#reflection_from_matrix","text":"reflection_from_matrix ( matrix ) Return mirror plane point and normal vector from reflection matrix. v0 = numpy.random.random(3) - 0.5 v1 = numpy.random.random(3) - 0.5 M0 = reflection_matrix(v0, v1) point, normal = reflection_from_matrix(M0) M1 = reflection_matrix(point, normal) is_same_transform(M0, M1) True","title":"reflection_from_matrix"},{"location":"python_api/pcg_gazebo/#rotation_matrix","text":"rotation_matrix ( angle , direction , point = None ) Return matrix to rotate about axis defined by point and direction. angle = (random.random() - 0.5) * (2*math.pi) direc = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 R0 = rotation_matrix(angle, direc, point) R1 = rotation_matrix(angle-2*math.pi, direc, point) is_same_transform(R0, R1) True R0 = rotation_matrix(angle, direc, point) R1 = rotation_matrix(-angle, -direc, point) is_same_transform(R0, R1) True I = numpy.identity(4, numpy.float64) numpy.allclose(I, rotation_matrix(math.pi*2, direc)) True numpy.allclose(2., numpy.trace(rotation_matrix(math.pi/2, ... direc, point))) True","title":"rotation_matrix"},{"location":"python_api/pcg_gazebo/#rotation_from_matrix","text":"rotation_from_matrix ( matrix ) Return rotation angle and axis from rotation matrix. angle = (random.random() - 0.5) * (2*math.pi) direc = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 R0 = rotation_matrix(angle, direc, point) angle, direc, point = rotation_from_matrix(R0) R1 = rotation_matrix(angle, direc, point) is_same_transform(R0, R1) True","title":"rotation_from_matrix"},{"location":"python_api/pcg_gazebo/#scale_matrix","text":"scale_matrix ( factor , origin = None , direction = None ) Return matrix to scale by factor around origin in direction. Use factor -1 for point symmetry. v = (numpy.random.rand(4, 5) - 0.5) * 20.0 v[3] = 1.0 S = scale_matrix(-1.234) numpy.allclose(numpy.dot(S, v)[:3], -1.234*v[:3]) True factor = random.random() * 10 - 5 origin = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 S = scale_matrix(factor, origin) S = scale_matrix(factor, origin, direct)","title":"scale_matrix"},{"location":"python_api/pcg_gazebo/#scale_from_matrix","text":"scale_from_matrix ( matrix ) Return scaling factor, origin and direction from scaling matrix. factor = random.random() * 10 - 5 origin = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 S0 = scale_matrix(factor, origin) factor, origin, direction = scale_from_matrix(S0) S1 = scale_matrix(factor, origin, direction) is_same_transform(S0, S1) True S0 = scale_matrix(factor, origin, direct) factor, origin, direction = scale_from_matrix(S0) S1 = scale_matrix(factor, origin, direction) is_same_transform(S0, S1) True","title":"scale_from_matrix"},{"location":"python_api/pcg_gazebo/#projection_matrix","text":"projection_matrix ( point , normal , direction = None , perspective = None , pseudo = False ) Return matrix to project onto plane defined by point and normal. Using either perspective point, projection direction, or none of both. If pseudo is True, perspective projections will preserve relative depth such that Perspective = dot(Orthogonal, PseudoPerspective). P = projection_matrix((0, 0, 0), (1, 0, 0)) numpy.allclose(P[1:, 1:], numpy.identity(4)[1:, 1:]) True point = numpy.random.random(3) - 0.5 normal = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 persp = numpy.random.random(3) - 0.5 P0 = projection_matrix(point, normal) P1 = projection_matrix(point, normal, direction=direct) P2 = projection_matrix(point, normal, perspective=persp) P3 = projection_matrix(point, normal, perspective=persp, pseudo=True) is_same_transform(P2, numpy.dot(P0, P3)) True P = projection_matrix((3, 0, 0), (1, 1, 0), (1, 0, 0)) v0 = (numpy.random.rand(4, 5) - 0.5) * 20.0 v0[3] = 1.0 v1 = numpy.dot(P, v0) numpy.allclose(v1[1], v0[1]) True numpy.allclose(v1[0], 3.0-v1[1]) True","title":"projection_matrix"},{"location":"python_api/pcg_gazebo/#projection_from_matrix","text":"projection_from_matrix ( matrix , pseudo = False ) Return projection plane and perspective point from projection matrix. Return values are same as arguments for projection_matrix function: point, normal, direction, perspective, and pseudo. point = numpy.random.random(3) - 0.5 normal = numpy.random.random(3) - 0.5 direct = numpy.random.random(3) - 0.5 persp = numpy.random.random(3) - 0.5 P0 = projection_matrix(point, normal) result = projection_from_matrix(P0) P1 = projection_matrix(*result) is_same_transform(P0, P1) True P0 = projection_matrix(point, normal, direct) result = projection_from_matrix(P0) P1 = projection_matrix(*result) is_same_transform(P0, P1) True P0 = projection_matrix(point, normal, perspective=persp, pseudo=False) result = projection_from_matrix(P0, pseudo=False) P1 = projection_matrix(*result) is_same_transform(P0, P1) True P0 = projection_matrix(point, normal, perspective=persp, pseudo=True) result = projection_from_matrix(P0, pseudo=True) P1 = projection_matrix(*result) is_same_transform(P0, P1) True","title":"projection_from_matrix"},{"location":"python_api/pcg_gazebo/#clip_matrix","text":"clip_matrix ( left , right , bottom , top , near , far , perspective = False ) Return matrix to obtain normalized device coordinates from frustrum. The frustrum bounds are axis-aligned along x (left, right), y (bottom, top) and z (near, far). Normalized device coordinates are in range [-1, 1] if coordinates are inside the frustrum. If perspective is True the frustrum is a truncated pyramid with the perspective point at origin and direction along z axis, otherwise an orthographic canonical view volume (a box). Homogeneous coordinates transformed by the perspective clip matrix need to be dehomogenized (devided by w coordinate). frustrum = numpy.random.rand(6) frustrum[1] += frustrum[0] frustrum[3] += frustrum[2] frustrum[5] += frustrum[4] M = clip_matrix(*frustrum, perspective=False) numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) array([-1., -1., -1., 1.]) numpy.dot(M, [frustrum[1], frustrum[3], frustrum[5], 1.0]) array([ 1., 1., 1., 1.]) M = clip_matrix(*frustrum, perspective=True) v = numpy.dot(M, [frustrum[0], frustrum[2], frustrum[4], 1.0]) v / v[3] array([-1., -1., -1., 1.]) v = numpy.dot(M, [frustrum[1], frustrum[3], frustrum[4], 1.0]) v / v[3] array([ 1., 1., -1., 1.])","title":"clip_matrix"},{"location":"python_api/pcg_gazebo/#shear_matrix","text":"shear_matrix ( angle , direction , point , normal ) Return matrix to shear by angle along direction vector on shear plane. The shear plane is defined by a point and normal vector. The direction vector must be orthogonal to the plane's normal vector. A point P is transformed by the shear matrix into P\" such that the vector P-P\" is parallel to the direction vector and its extent is given by the angle of P-P'-P\", where P' is the orthogonal projection of P onto the shear plane. angle = (random.random() - 0.5) * 4*math.pi direct = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 normal = numpy.cross(direct, numpy.random.random(3)) S = shear_matrix(angle, direct, point, normal) numpy.allclose(1.0, numpy.linalg.det(S)) True","title":"shear_matrix"},{"location":"python_api/pcg_gazebo/#shear_from_matrix","text":"shear_from_matrix ( matrix ) Return shear angle, direction and plane from shear matrix. angle = (random.random() - 0.5) * 4*math.pi direct = numpy.random.random(3) - 0.5 point = numpy.random.random(3) - 0.5 normal = numpy.cross(direct, numpy.random.random(3)) S0 = shear_matrix(angle, direct, point, normal) angle, direct, point, normal = shear_from_matrix(S0) S1 = shear_matrix(angle, direct, point, normal) is_same_transform(S0, S1) True","title":"shear_from_matrix"},{"location":"python_api/pcg_gazebo/#decompose_matrix","text":"decompose_matrix ( matrix ) Return sequence of transformations from transformation matrix. matrix : array_like Non-degenerative homogeneous transformation matrix Return tuple of: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix Raise ValueError if matrix is of wrong type or degenerative. T0 = translation_matrix((1, 2, 3)) scale, shear, angles, trans, persp = decompose_matrix(T0) T1 = translation_matrix(trans) numpy.allclose(T0, T1) True S = scale_matrix(0.123) scale, shear, angles, trans, persp = decompose_matrix(S) scale[0] 0.123 R0 = euler_matrix(1, 2, 3) scale, shear, angles, trans, persp = decompose_matrix(R0) R1 = euler_matrix(*angles) numpy.allclose(R0, R1) True","title":"decompose_matrix"},{"location":"python_api/pcg_gazebo/#compose_matrix","text":"compose_matrix ( scale = None , shear = None , angles = None , translate = None , perspective = None ) Return transformation matrix from sequence of transformations. This is the inverse of the decompose_matrix function. Sequence of transformations: scale : vector of 3 scaling factors shear : list of shear factors for x-y, x-z, y-z axes angles : list of Euler angles about static x, y, z axes translate : translation vector along x, y, z axes perspective : perspective partition of matrix scale = numpy.random.random(3) - 0.5 shear = numpy.random.random(3) - 0.5 angles = (numpy.random.random(3) - 0.5) * (2*math.pi) trans = numpy.random.random(3) - 0.5 persp = numpy.random.random(4) - 0.5 M0 = compose_matrix(scale, shear, angles, trans, persp) result = decompose_matrix(M0) M1 = compose_matrix(*result) is_same_transform(M0, M1) True","title":"compose_matrix"},{"location":"python_api/pcg_gazebo/#orthogonalization_matrix","text":"orthogonalization_matrix ( lengths , angles ) Return orthogonalization matrix for crystallographic cell coordinates. Angles are expected in degrees. The de-orthogonalization matrix is the inverse. O = orthogonalization_matrix((10., 10., 10.), (90., 90., 90.)) numpy.allclose(O[:3, :3], numpy.identity(3, float) * 10) True O = orthogonalization_matrix([9.8, 12.0, 15.5], [87.2, 80.7, 69.7]) numpy.allclose(numpy.sum(O), 43.063229) True","title":"orthogonalization_matrix"},{"location":"python_api/pcg_gazebo/#superimposition_matrix","text":"superimposition_matrix ( v0 , v1 , scaling = False , usesvd = True ) Return matrix to transform given vector set into second vector set. v0 and v1 are shape (3, *) or (4, *) arrays of at least 3 vectors. If usesvd is True, the weighted sum of squared deviations (RMSD) is minimized according to the algorithm by W. Kabsch [8]. Otherwise the quaternion based algorithm by B. Horn [9] is used (slower when using this Python implementation). The returned matrix performs rotation, translation and uniform scaling (if specified). v0 = numpy.random.rand(3, 10) M = superimposition_matrix(v0, v0) numpy.allclose(M, numpy.identity(4)) True R = random_rotation_matrix(numpy.random.random(3)) v0 = ((1,0,0), (0,1,0), (0,0,1), (1,1,1)) v1 = numpy.dot(R, v0) M = superimposition_matrix(v0, v1) numpy.allclose(v1, numpy.dot(M, v0)) True v0 = (numpy.random.rand(4, 100) - 0.5) * 20.0 v0[3] = 1.0 v1 = numpy.dot(R, v0) M = superimposition_matrix(v0, v1) numpy.allclose(v1, numpy.dot(M, v0)) True S = scale_matrix(random.random()) T = translation_matrix(numpy.random.random(3)-0.5) M = concatenate_matrices(T, R, S) v1 = numpy.dot(M, v0) v0[:3] += numpy.random.normal(0.0, 1e-9, 300).reshape(3, -1) M = superimposition_matrix(v0, v1, scaling=True) numpy.allclose(v1, numpy.dot(M, v0)) True M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) numpy.allclose(v1, numpy.dot(M, v0)) True v = numpy.empty((4, 100, 3), dtype=numpy.float64) v[:, :, 0] = v0 M = superimposition_matrix(v0, v1, scaling=True, usesvd=False) numpy.allclose(v1, numpy.dot(M, v[:, :, 0])) True","title":"superimposition_matrix"},{"location":"python_api/pcg_gazebo/#euler_matrix","text":"euler_matrix ( ai , aj , ak , axes = 'sxyz' ) Return homogeneous rotation matrix from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple R = euler_matrix(1, 2, 3, 'syxz') numpy.allclose(numpy.sum(R[0]), -1.34786452) True R = euler_matrix(1, 2, 3, (0, 1, 0, 1)) numpy.allclose(numpy.sum(R[0]), -0.383436184) True ai, aj, ak = (4.0*math.pi) * (numpy.random.random(3) - 0.5) for axes in _AXES2TUPLE.keys(): ... R = euler_matrix(ai, aj, ak, axes) for axes in _TUPLE2AXES.keys(): ... R = euler_matrix(ai, aj, ak, axes)","title":"euler_matrix"},{"location":"python_api/pcg_gazebo/#euler_from_matrix","text":"euler_from_matrix ( matrix , axes = 'sxyz' ) Return Euler angles from rotation matrix for specified axis sequence. axes : One of 24 axis sequences as string or encoded tuple Note that many Euler angle triplets can describe one matrix. R0 = euler_matrix(1, 2, 3, 'syxz') al, be, ga = euler_from_matrix(R0, 'syxz') R1 = euler_matrix(al, be, ga, 'syxz') numpy.allclose(R0, R1) True angles = (4.0*math.pi) * (numpy.random.random(3) - 0.5) for axes in _AXES2TUPLE.keys(): ... R0 = euler_matrix(axes=axes, *angles) ... R1 = euler_matrix(axes=axes, *euler_from_matrix(R0, axes)) ... if not numpy.allclose(R0, R1): print axes, \"failed\"","title":"euler_from_matrix"},{"location":"python_api/pcg_gazebo/#euler_from_quaternion","text":"euler_from_quaternion ( quaternion , axes = 'sxyz' ) Return Euler angles from quaternion for specified axis sequence. angles = euler_from_quaternion([0.06146124, 0, 0, 0.99810947]) numpy.allclose(angles, [0.123, 0, 0]) True","title":"euler_from_quaternion"},{"location":"python_api/pcg_gazebo/#quaternion_from_euler","text":"quaternion_from_euler ( ai , aj , ak , axes = 'sxyz' ) Return quaternion from Euler angles and axis sequence. ai, aj, ak : Euler's roll, pitch and yaw angles axes : One of 24 axis sequences as string or encoded tuple q = quaternion_from_euler(1, 2, 3, 'ryxz') numpy.allclose(q, [0.310622, -0.718287, 0.444435, 0.435953]) True","title":"quaternion_from_euler"},{"location":"python_api/pcg_gazebo/#quaternion_about_axis","text":"quaternion_about_axis ( angle , axis ) Return quaternion for rotation about axis. q = quaternion_about_axis(0.123, (1, 0, 0)) numpy.allclose(q, [0.06146124, 0, 0, 0.99810947]) True","title":"quaternion_about_axis"},{"location":"python_api/pcg_gazebo/#quaternion_matrix","text":"quaternion_matrix ( quaternion ) Return homogeneous rotation matrix from quaternion. R = quaternion_matrix([0.06146124, 0, 0, 0.99810947]) numpy.allclose(R, rotation_matrix(0.123, (1, 0, 0))) True","title":"quaternion_matrix"},{"location":"python_api/pcg_gazebo/#quaternion_from_matrix","text":"quaternion_from_matrix ( matrix ) Return quaternion from rotation matrix. R = rotation_matrix(0.123, (1, 2, 3)) q = quaternion_from_matrix(R) numpy.allclose(q, [0.0164262, 0.0328524, 0.0492786, 0.9981095]) True","title":"quaternion_from_matrix"},{"location":"python_api/pcg_gazebo/#quaternion_multiply","text":"quaternion_multiply ( quaternion1 , quaternion0 ) Return multiplication of two quaternions. q = quaternion_multiply([1, -2, 3, 4], [-5, 6, 7, 8]) numpy.allclose(q, [-44, -14, 48, 28]) True","title":"quaternion_multiply"},{"location":"python_api/pcg_gazebo/#quaternion_conjugate","text":"quaternion_conjugate ( quaternion ) Return conjugate of quaternion. q0 = random_quaternion() q1 = quaternion_conjugate(q0) q1[3] == q0[3] and all(q1[:3] == -q0[:3]) True","title":"quaternion_conjugate"},{"location":"python_api/pcg_gazebo/#quaternion_inverse","text":"quaternion_inverse ( quaternion ) Return inverse of quaternion. q0 = random_quaternion() q1 = quaternion_inverse(q0) numpy.allclose(quaternion_multiply(q0, q1), [0, 0, 0, 1]) True","title":"quaternion_inverse"},{"location":"python_api/pcg_gazebo/#quaternion_slerp","text":"quaternion_slerp ( quat0 , quat1 , fraction , spin = 0 , shortestpath = True ) Return spherical linear interpolation between two quaternions. q0 = random_quaternion() q1 = random_quaternion() q = quaternion_slerp(q0, q1, 0.0) numpy.allclose(q, q0) True q = quaternion_slerp(q0, q1, 1.0, 1) numpy.allclose(q, q1) True q = quaternion_slerp(q0, q1, 0.5) angle = math.acos(numpy.dot(q0, q)) numpy.allclose(2.0, math.acos(numpy.dot(q0, q1)) / angle) or numpy.allclose(2.0, math.acos(-numpy.dot(q0, q1)) / angle) True","title":"quaternion_slerp"},{"location":"python_api/pcg_gazebo/#random_quaternion","text":"random_quaternion ( rand = None ) Return uniform random unit quaternion. rand: array like or None Three independent random variables that are uniformly distributed between 0 and 1. q = random_quaternion() numpy.allclose(1.0, vector_norm(q)) True q = random_quaternion(numpy.random.random(3)) q.shape (4,)","title":"random_quaternion"},{"location":"python_api/pcg_gazebo/#random_rotation_matrix","text":"random_rotation_matrix ( rand = None ) Return uniform random rotation matrix. rnd: array like Three independent random variables that are uniformly distributed between 0 and 1 for each returned quaternion. R = random_rotation_matrix() numpy.allclose(numpy.dot(R.T, R), numpy.identity(4)) True","title":"random_rotation_matrix"},{"location":"python_api/pcg_gazebo/#arcball","text":"Arcball ( self , initial = None ) Virtual Trackball Control. ball = Arcball() ball = Arcball(initial=numpy.identity(4)) ball.place([320, 320], 320) ball.down([500, 250]) ball.drag([475, 275]) R = ball.matrix() numpy.allclose(numpy.sum(R), 3.90583455) True ball = Arcball(initial=[0, 0, 0, 1]) ball.place([320, 320], 320) ball.setaxes([1,1,0], [-1, 1, 0]) ball.setconstrain(True) ball.down([400, 200]) ball.drag([200, 400]) R = ball.matrix() numpy.allclose(numpy.sum(R), 0.2055924) True ball.next()","title":"Arcball"},{"location":"python_api/pcg_gazebo/#place","text":"Arcball . place ( self , center , radius ) Place Arcball, e.g. when window size changes. center : sequence[2] Window coordinates of trackball center. radius : float Radius of trackball in window coordinates.","title":"place"},{"location":"python_api/pcg_gazebo/#setaxes","text":"Arcball . setaxes ( self , * axes ) Set axes to constrain rotations.","title":"setaxes"},{"location":"python_api/pcg_gazebo/#setconstrain","text":"Arcball . setconstrain ( self , constrain ) Set state of constrain to axis mode.","title":"setconstrain"},{"location":"python_api/pcg_gazebo/#getconstrain","text":"Arcball . getconstrain ( self ) Return state of constrain to axis mode.","title":"getconstrain"},{"location":"python_api/pcg_gazebo/#down","text":"Arcball . down ( self , point ) Set initial cursor window coordinates and pick constrain-axis.","title":"down"},{"location":"python_api/pcg_gazebo/#drag","text":"Arcball . drag ( self , point ) Update current cursor window coordinates.","title":"drag"},{"location":"python_api/pcg_gazebo/#next","text":"Arcball . next ( self , acceleration = 0.0 ) Continue rotation in direction of last drag.","title":"next"},{"location":"python_api/pcg_gazebo/#matrix","text":"Arcball . matrix ( self ) Return homogeneous rotation matrix.","title":"matrix"},{"location":"python_api/pcg_gazebo/#arcball_map_to_sphere","text":"arcball_map_to_sphere ( point , center , radius ) Return unit sphere coordinates from window coordinates.","title":"arcball_map_to_sphere"},{"location":"python_api/pcg_gazebo/#arcball_constrain_to_axis","text":"arcball_constrain_to_axis ( point , axis ) Return sphere point perpendicular to axis.","title":"arcball_constrain_to_axis"},{"location":"python_api/pcg_gazebo/#arcball_nearest_axis","text":"arcball_nearest_axis ( point , axes ) Return axis, which arc is nearest to point.","title":"arcball_nearest_axis"},{"location":"python_api/pcg_gazebo/#vector_norm","text":"vector_norm ( data , axis = None , out = None ) Return length, i.e. eucledian norm, of ndarray along axis. v = numpy.random.random(3) n = vector_norm(v) numpy.allclose(n, numpy.linalg.norm(v)) True v = numpy.random.rand(6, 5, 3) n = vector_norm(v, axis=-1) numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=2))) True n = vector_norm(v, axis=1) numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True v = numpy.random.rand(5, 4, 3) n = numpy.empty((5, 3), dtype=numpy.float64) vector_norm(v, axis=1, out=n) numpy.allclose(n, numpy.sqrt(numpy.sum(v*v, axis=1))) True vector_norm([]) 0.0 vector_norm([1.0]) 1.0","title":"vector_norm"},{"location":"python_api/pcg_gazebo/#unit_vector","text":"unit_vector ( data , axis = None , out = None ) Return ndarray normalized by length, i.e. eucledian norm, along axis. v0 = numpy.random.random(3) v1 = unit_vector(v0) numpy.allclose(v1, v0 / numpy.linalg.norm(v0)) True v0 = numpy.random.rand(5, 4, 3) v1 = unit_vector(v0, axis=-1) v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=2)), 2) numpy.allclose(v1, v2) True v1 = unit_vector(v0, axis=1) v2 = v0 / numpy.expand_dims(numpy.sqrt(numpy.sum(v0*v0, axis=1)), 1) numpy.allclose(v1, v2) True v1 = numpy.empty((5, 4, 3), dtype=numpy.float64) unit_vector(v0, axis=1, out=v1) numpy.allclose(v1, v2) True list(unit_vector([])) [] list(unit_vector([1.0])) [1.0]","title":"unit_vector"},{"location":"python_api/pcg_gazebo/#random_vector","text":"random_vector ( size ) Return array of random doubles in the half-open interval [0.0, 1.0). v = random_vector(10000) numpy.all(v >= 0.0) and numpy.all(v < 1.0) True v0 = random_vector(10) v1 = random_vector(10) numpy.any(v0 == v1) False","title":"random_vector"},{"location":"python_api/pcg_gazebo/#inverse_matrix","text":"inverse_matrix ( matrix ) Return inverse of square transformation matrix. M0 = random_rotation_matrix() M1 = inverse_matrix(M0.T) numpy.allclose(M1, numpy.linalg.inv(M0.T)) True for size in range(1, 7): ... M0 = numpy.random.rand(size, size) ... M1 = inverse_matrix(M0) ... if not numpy.allclose(M1, numpy.linalg.inv(M0)): print size","title":"inverse_matrix"},{"location":"python_api/pcg_gazebo/#concatenate_matrices","text":"concatenate_matrices ( * matrices ) Return concatenation of series of transformation matrices. M = numpy.random.rand(16).reshape((4, 4)) - 0.5 numpy.allclose(M, concatenate_matrices(M)) True numpy.allclose(numpy.dot(M, M.T), concatenate_matrices(M, M.T)) True","title":"concatenate_matrices"},{"location":"python_api/pcg_gazebo/#is_same_transform","text":"is_same_transform ( matrix0 , matrix1 ) Return True if two matrices perform same transformation. is_same_transform(numpy.identity(4), numpy.identity(4)) True is_same_transform(numpy.identity(4), random_rotation_matrix()) False","title":"is_same_transform"},{"location":"python_api/pcg_gazebo/#pcg_gazebovisualization","text":"","title":"pcg_gazebo.visualization"},{"location":"python_api/pcg_gazebo.parsers/","text":"pcg_gazebo.parsers \u00b6 Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications parse_sdf \u00b6 parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo . parsers . types . XMLBase object. parse_urdf \u00b6 parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo . parsers . types . XMLBase object. parse_sdf_config \u00b6 parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo . parsers . types . XMLBase object. parse_xml \u00b6 parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections . OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections . OrderedDict : Dictionary where the XML tags are the keys. parse_xml_str \u00b6 parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections . OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections . OrderedDict : Dictionary where the XML tags are the keys. parse_xml_dict \u00b6 parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections . OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections . OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo . parsers . types . XMLBase object. convert_to_dict \u00b6 convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo . parsers . types . XMLBase . Input arguments xml_dict ( type: collections . OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary. convert_from_string \u00b6 convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str . sdf2urdf \u00b6 sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo . parsers . types . XMLBase ): Valid SDF element Returns pcg_gazebo . parsers . types . XMLBase as an URDF element. urdf2sdf \u00b6 urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo . parsers . types . XMLBase ): Valid URDF element Returns pcg_gazebo . parsers . types . XMLBase as a SDF element.","title":"pcg_gazebo.parsers"},{"location":"python_api/pcg_gazebo.parsers/#pcg_gazeboparsers","text":"Parsing module to generated and convert SDF, URDF and SDF Configuration formats. Sources SDF format URDF format specifications","title":"pcg_gazebo.parsers"},{"location":"python_api/pcg_gazebo.parsers/#parse_sdf","text":"parse_sdf ( input_xml ) Parse an XML file in the SDF format and generates an pcg_gazebo SDF instance. Input arguments input_xml ( type: str ): Filename of the SDF file or SDF XML formatted text. Returns pcg_gazebo . parsers . types . XMLBase object.","title":"parse_sdf"},{"location":"python_api/pcg_gazebo.parsers/#parse_urdf","text":"parse_urdf ( input_xml ) Parse an XML file in the URDF format and generates an pcg_gazebo URDF instance. Input arguments input_xml ( type: str ): Filename of the URDF file or URDF XML formatted text. Returns pcg_gazebo . parsers . types . XMLBase object.","title":"parse_urdf"},{"location":"python_api/pcg_gazebo.parsers/#parse_sdf_config","text":"parse_sdf_config ( input_xml ) Parse an XML file in the SDF Configuration format and generates an pcg_gazebo SDF Configuration instance. Input arguments input_xml ( type: str ): Filename of the SDF Configuration file or SDF Configuration XML formatted text. Returns pcg_gazebo . parsers . types . XMLBase object.","title":"parse_sdf_config"},{"location":"python_api/pcg_gazebo.parsers/#parse_xml","text":"parse_xml ( input_xml , type = 'sdf' ) Parse an XML file into an collections . OrderedDict . Input arguments input_xml ( type: str ): Filename of the XML file or XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections . OrderedDict : Dictionary where the XML tags are the keys.","title":"parse_xml"},{"location":"python_api/pcg_gazebo.parsers/#parse_xml_str","text":"parse_xml_str ( xml_str , type = 'sdf' ) Parse an XML formatted string into an collections . OrderedDict . Input arguments input_xml ( type: str ): XML formatted text. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns collections . OrderedDict : Dictionary where the XML tags are the keys.","title":"parse_xml_str"},{"location":"python_api/pcg_gazebo.parsers/#parse_xml_dict","text":"parse_xml_dict ( xml_dict , type = 'sdf' ) Converts an collections . OrderedDict created from a XML file and return an SDF, URDF or SDF Configuration pcg_gazebo element. Input arguments xml_dict ( type: collections . OrderedDict ): XML contents. type ( type: str ): Type of XML format used in the input file, options are sdf , urdf or sdf_config . Returns pcg_gazebo . parsers . types . XMLBase object.","title":"parse_xml_dict"},{"location":"python_api/pcg_gazebo.parsers/#convert_to_dict","text":"convert_to_dict ( xml_dict ) Convert the xmltodict output into a dictionary that can be parsed into a pcg_gazebo . parsers . types . XMLBase . Input arguments xml_dict ( type: collections . OrderedDict ): XML content in dictionary form. Returns dict : Formatted XML dictionary.","title":"convert_to_dict"},{"location":"python_api/pcg_gazebo.parsers/#convert_from_string","text":"convert_from_string ( str_input_xml ) Convert a string into a Python data structure type. Input arguments str_input_xml ( type: str ): Input string Returns bool , int , float , list of float or str .","title":"convert_from_string"},{"location":"python_api/pcg_gazebo.parsers/#sdf2urdf","text":"sdf2urdf ( sdf ) Recursively convert a SDF pcg_gazebo element and its child elements into an URDF pcg_gazebo element. Input arguments sdf ( type: pcg_gazebo . parsers . types . XMLBase ): Valid SDF element Returns pcg_gazebo . parsers . types . XMLBase as an URDF element.","title":"sdf2urdf"},{"location":"python_api/pcg_gazebo.parsers/#urdf2sdf","text":"urdf2sdf ( urdf ) Recursively convert an URDF pcg_gazebo element and its child elements into a SDF pcg_gazebo element. Input arguments urdf ( type: pcg_gazebo . parsers . types . XMLBase ): Valid URDF element Returns pcg_gazebo . parsers . types . XMLBase as a SDF element.","title":"urdf2sdf"},{"location":"python_api/pcg_gazebo.parsers.sdf/","text":"pcg_gazebo.parsers.sdf \u00b6 Accel \u00b6 Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1 . 4 Source < accel > (SDF 1.4) bias_mean \u00b6 Return the bias mean value SDF element, to read the value use obj . bias_mean . value bias_stddev \u00b6 Return the bias standard deviation value SDF element, to read the value use obj . bias_stddev . value mean \u00b6 Return the mean value SDF element, to read the value use obj . mean . value stddev \u00b6 Return the standard deviation value SDF element, to read the value use obj . stddev . value Accuracy \u00b6 Accuracy ( self , default = 0.001 ) Actor \u00b6 Actor ( self ) AllowAutoDisable \u00b6 AllowAutoDisable ( self , default = False ) Altimeter \u00b6 Altimeter ( self ) AlwaysOn \u00b6 AlwaysOn ( self , default = False ) Ambient \u00b6 Ambient ( self , size = 4 ) AngularVelocity \u00b6 AngularVelocity ( self ) Animation \u00b6 Animation ( self ) Attenuation \u00b6 Attenuation ( self ) AutoStart \u00b6 AutoStart ( self , default = True ) Axis \u00b6 Axis ( self ) Axis2 \u00b6 Axis2 ( self ) BiasMean \u00b6 BiasMean ( self , default = 0 ) BiasStdDev \u00b6 BiasStdDev ( self , default = 0 ) Bounce \u00b6 Bounce ( self ) Box \u00b6 Box ( self ) Bullet \u00b6 Bullet ( self , mode = 'physics' ) Camera \u00b6 Camera ( self ) CastShadows \u00b6 CastShadows ( self , default = True ) Center \u00b6 Center ( self , default = False ) CFM \u00b6 CFM ( self , default = 0 ) Child \u00b6 Child ( self , default = 'none' ) Clip \u00b6 Clip ( self ) Coefficient \u00b6 Coefficient ( self , default = 1 ) Collision \u00b6 Collision ( self ) Constant \u00b6 Constant ( self , default = 0 ) Constraints \u00b6 Constraints ( self , engine = 'ode' ) ContactMaxCorrectingVel \u00b6 ContactMaxCorrectingVel ( self , default = 100 ) ContactSurfaceLayer \u00b6 ContactSurfaceLayer ( self , default = 0.001 ) Contact \u00b6 Contact ( self , mode = 'simbody' ) Cylinder \u00b6 Cylinder ( self ) Damping \u00b6 Damping ( self , default = 0 ) DelayStart \u00b6 DelayStart ( self , default = 0 ) DepthCamera \u00b6 DepthCamera ( self ) Diffuse \u00b6 Diffuse ( self , default = [ 0 , 0 , 0 , 1 ]) Direction \u00b6 Direction ( self , default = [ 0 , 0 , - 1 ]) Dissipation \u00b6 Dissipation ( self , default = 100 ) Distortion \u00b6 Distortion ( self ) DynamicFriction \u00b6 DynamicFriction ( self , default = 0.9 ) Dynamics \u00b6 Dynamics ( self ) Effort \u00b6 Effort ( self , default =- 1 ) Emissive \u00b6 Emissive ( self , size = 4 ) Empty \u00b6 Empty ( self ) EnableWind \u00b6 EnableWind ( self , default = False ) ERP \u00b6 ERP ( self , default = 0.2 ) FallOff \u00b6 FallOff ( self , default = 0 ) Far \u00b6 Far ( self , default = 0 ) FDir1 \u00b6 FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector Filename \u00b6 Filename ( self , default = 'none' ) ForceTorque \u00b6 ForceTorque ( self ) Format \u00b6 Format ( self , default = 'R8G8B8' ) Frame \u00b6 Frame ( self , default = '' ) FrictionModel \u00b6 FrictionModel ( self ) Friction \u00b6 Friction ( self ) Configuration of the collision friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Friction2 \u00b6 Friction2 ( self , default = 1 ) Geometry \u00b6 Geometry ( self ) Granularity \u00b6 Granularity ( self , default = 1 ) Gravity \u00b6 Gravity ( self , default = True ) Height \u00b6 Height ( self , default = 1 ) HorizontalFOV \u00b6 HorizontalFOV ( self , default = 1.047 ) Horizontal \u00b6 Horizontal ( self ) Image \u00b6 Image ( self , mode = 'geometry' ) IMU \u00b6 IMU ( self ) Include \u00b6 Include ( self ) Inertia \u00b6 Inertia ( self ) Inertial \u00b6 Inertial ( self ) InitialPosition \u00b6 InitialPosition ( self , default = 0 ) InnerAngle \u00b6 InnerAngle ( self , default = 0 ) InterpolateX \u00b6 InterpolateX ( self , default = False ) Iters \u00b6 Iters ( self , default = 50 ) IXX \u00b6 IXX ( self , default = 0 ) IXY \u00b6 IXY ( self , default = 0 ) IXZ \u00b6 IXZ ( self , default = 0 ) IYY \u00b6 IYY ( self , default = 0 ) IYZ \u00b6 IYZ ( self , default = 0 ) IZZ \u00b6 IZZ ( self , default = 0 ) Joint \u00b6 Joint ( self ) K1 \u00b6 K1 ( self , default = 0 ) K2 \u00b6 K2 ( self , default = 0 ) K3 \u00b6 K3 ( self , default = 0 ) Kd \u00b6 Kd ( self , default = 1 ) Kinematic \u00b6 Kinematic ( self , default = False ) Kp \u00b6 Kp ( self , default = 1000000000000.0 ) LaserRetro \u00b6 LaserRetro ( self , default = 0 ) Length \u00b6 Length ( self ) Light \u00b6 Light ( self ) Lighting \u00b6 Lighting ( self , default = False ) Limit \u00b6 Limit ( self , mode = 'axis' ) LinearAcceleration \u00b6 LinearAcceleration ( self ) Linear \u00b6 Linear ( self , default = 0 ) Link \u00b6 Link ( self ) Localization \u00b6 Localization ( self , default = 'CUSTOM' ) Loop \u00b6 Loop ( self , default = False ) Lower \u00b6 Lower ( self , default =- 1e+16 ) Mass \u00b6 Mass ( self ) Material \u00b6 Material ( self ) MaxAngle \u00b6 MaxAngle ( self , default = 0 ) MaxContacts \u00b6 MaxContacts ( self , default = 20 ) MaxStepSize \u00b6 MaxStepSize ( self , default = 0.001 ) MaxTransientVelocity \u00b6 MaxTransientVelocity ( self , default = 0.01 ) MaxVel \u00b6 MaxVel ( self , default = 0.01 ) Max \u00b6 Max ( self , default = 0 ) Mean \u00b6 Mean ( self ) MeasureDirection \u00b6 MeasureDirection ( self , default = 'child_to_parent' ) Mesh \u00b6 Mesh ( self ) MinAngle \u00b6 MinAngle ( self , default = 0 ) MinDepth \u00b6 MinDepth ( self , default = 0 ) MinStepSize \u00b6 MinStepSize ( self , default = 0.0001 ) Min \u00b6 Min ( self , default = 0 ) Model \u00b6 Model ( self ) Mu \u00b6 Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction Mu2 \u00b6 Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction MustBeLoopJoint \u00b6 MustBeLoopJoint ( self , default = False ) Name \u00b6 Name ( self , default = 'none' ) Near \u00b6 Near ( self , default = 0 ) Noise \u00b6 Noise ( self , type = 'none' ) NormalMap \u00b6 NormalMap ( self , default = '' ) Normal \u00b6 Normal ( self ) ODE \u00b6 ODE ( self , mode ) OrientationReferenceFrame \u00b6 OrientationReferenceFrame ( self ) OuterAngle \u00b6 OuterAngle ( self , default = 0 ) Output \u00b6 Output ( self , default = 'depths' ) OverrideImpactCaptureVelocity \u00b6 OverrideImpactCaptureVelocity ( self , default = 0.001 ) OverrideStictionTransitionVelocity \u00b6 OverrideStictionTransitionVelocity ( self , default = 0.9 ) P1 \u00b6 P1 ( self , default = 0 ) P2 \u00b6 P2 ( self , default = 0 ) Parent \u00b6 Parent ( self , default = 'parent' ) PatchRadius \u00b6 PatchRadius ( self , default = 0 ) Path \u00b6 Path ( self , default = '__default__' ) Physics \u00b6 Physics ( self , mode = 'ode' ) Plane \u00b6 Plane ( self ) PlasticCoefRestitution \u00b6 PlasticCoefRestitution ( self , default = 0.5 ) PlasticImpactVelocity \u00b6 PlasticImpactVelocity ( self , default = 0.5 ) Plugin \u00b6 Plugin ( self , default = {}) Point \u00b6 Point ( self , vec_length = 2 ) Polyline \u00b6 Polyline ( self ) Pose \u00b6 Pose ( self ) Precision \u00b6 Precision ( self ) PreConIters \u00b6 PreConIters ( self , default = 0 ) ProvideFeedback \u00b6 ProvideFeedback ( self , default = False ) Quadratic \u00b6 Quadratic ( self , default = 0 ) Radius \u00b6 Radius ( self , default = 0 ) Range \u00b6 Range ( self ) Rate \u00b6 Rate ( self , type = 'none' ) Ray \u00b6 Ray ( self ) RealTimeFactor \u00b6 RealTimeFactor ( self , default = 1 ) RealTimeUpdateRate \u00b6 RealTimeUpdateRate ( self , default = 1 ) Resolution \u00b6 Resolution ( self , default = 0 ) RestitutionCoefficient \u00b6 RestitutionCoefficient ( self , default = 0 ) RollingFriction \u00b6 RollingFriction ( self , default = 1 ) Samples \u00b6 Samples ( self , default = 640 ) Save \u00b6 Save ( self ) Scale \u00b6 Scale ( self , size = 3 ) Scan \u00b6 Scan ( self ) Script \u00b6 Script ( self , mode = 'material' ) SDF \u00b6 SDF ( self , mode = 'world' ) SelfCollide \u00b6 SelfCollide ( self , default = False ) Sensor \u00b6 Sensor ( self , mode = 'altimeter' ) Shader \u00b6 Shader ( self ) Simbody \u00b6 Simbody ( self , mode = 'physics' ) Size \u00b6 Size ( self , vec_length = 3 ) Skin \u00b6 Skin ( self ) Slip \u00b6 Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip1 \u00b6 Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient Slip2 \u00b6 Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient SoftCFM \u00b6 SoftCFM ( self , default = 0 ) SoftERP \u00b6 SoftERP ( self , default = 0.2 ) Solver \u00b6 Solver ( self , engine = 'ode' ) Sor \u00b6 Sor ( self , default = 1.3 ) Specular \u00b6 Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ]) Sphere \u00b6 Sphere ( self ) SplitImpulsePenetrationThreshold \u00b6 SplitImpulsePenetrationThreshold ( self , default =- 0.01 ) SplitImpulse \u00b6 SplitImpulse ( self , default = True ) Spot \u00b6 Spot ( self ) SpringReference \u00b6 SpringReference ( self , default = 0 ) SpringStiffness \u00b6 SpringStiffness ( self , default = 0 ) StaticFriction \u00b6 StaticFriction ( self , default = 0.9 ) Static \u00b6 Static ( self , default = False ) StdDev \u00b6 StdDev ( self ) Stiffness \u00b6 Stiffness ( self , default = 100000000.0 ) SubMesh \u00b6 SubMesh ( self ) SurfaceRadius \u00b6 SurfaceRadius ( self , default = 0 ) Surface \u00b6 Surface ( self ) Threshold \u00b6 Threshold ( self , default = 0 ) Time \u00b6 Time ( self , default = 0 ) Topic \u00b6 Topic ( self , default = 'none' ) Torsional \u00b6 Torsional ( self ) Trajectory \u00b6 Trajectory ( self ) Transparency \u00b6 Transparency ( self , default = 0 ) Type \u00b6 Type ( self , default = '' ) UpdateRate \u00b6 UpdateRate ( self , default = 0 ) Upper \u00b6 Upper ( self , default = 1e+16 ) URDF \u00b6 URDF ( self , mode = 'model' ) URI \u00b6 URI ( self , default = '' ) UseDynamicMOIRescaling \u00b6 UseDynamicMOIRescaling ( self , default = False ) UseParentModelFrame \u00b6 UseParentModelFrame ( self , default = False ) UsePatchRadius \u00b6 UsePatchRadius ( self , default = True ) Velocity \u00b6 Velocity ( self , default =- 1 ) VerticalPosition \u00b6 VerticalPosition ( self ) VerticalVelocity \u00b6 VerticalVelocity ( self ) Vertical \u00b6 Vertical ( self ) ViscousFriction \u00b6 ViscousFriction ( self , default = 0 ) Visual \u00b6 Visual ( self ) Visualize \u00b6 Visualize ( self , default = False ) Waypoint \u00b6 Waypoint ( self ) Width \u00b6 Width ( self , default = 320 ) World \u00b6 World ( self ) X \u00b6 X ( self ) XYZ \u00b6 XYZ ( self , default = [ 0 , 0 , 1 ]) Y \u00b6 Y ( self ) Z \u00b6 Z ( self )","title":"pcg_gazebo.parsers.sdf"},{"location":"python_api/pcg_gazebo.parsers.sdf/#pcg_gazeboparserssdf","text":"","title":"pcg_gazebo.parsers.sdf"},{"location":"python_api/pcg_gazebo.parsers.sdf/#accel","text":"Accel ( self ) Noise parameters for linear accelerations. Child elements mean stddev bias_mean bias_stddev SDF versions 1 . 4 Source < accel > (SDF 1.4)","title":"Accel"},{"location":"python_api/pcg_gazebo.parsers.sdf/#bias_mean","text":"Return the bias mean value SDF element, to read the value use obj . bias_mean . value","title":"bias_mean"},{"location":"python_api/pcg_gazebo.parsers.sdf/#bias_stddev","text":"Return the bias standard deviation value SDF element, to read the value use obj . bias_stddev . value","title":"bias_stddev"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mean","text":"Return the mean value SDF element, to read the value use obj . mean . value","title":"mean"},{"location":"python_api/pcg_gazebo.parsers.sdf/#stddev","text":"Return the standard deviation value SDF element, to read the value use obj . stddev . value","title":"stddev"},{"location":"python_api/pcg_gazebo.parsers.sdf/#accuracy","text":"Accuracy ( self , default = 0.001 )","title":"Accuracy"},{"location":"python_api/pcg_gazebo.parsers.sdf/#actor","text":"Actor ( self )","title":"Actor"},{"location":"python_api/pcg_gazebo.parsers.sdf/#allowautodisable","text":"AllowAutoDisable ( self , default = False )","title":"AllowAutoDisable"},{"location":"python_api/pcg_gazebo.parsers.sdf/#altimeter","text":"Altimeter ( self )","title":"Altimeter"},{"location":"python_api/pcg_gazebo.parsers.sdf/#alwayson","text":"AlwaysOn ( self , default = False )","title":"AlwaysOn"},{"location":"python_api/pcg_gazebo.parsers.sdf/#ambient","text":"Ambient ( self , size = 4 )","title":"Ambient"},{"location":"python_api/pcg_gazebo.parsers.sdf/#angularvelocity","text":"AngularVelocity ( self )","title":"AngularVelocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#animation","text":"Animation ( self )","title":"Animation"},{"location":"python_api/pcg_gazebo.parsers.sdf/#attenuation","text":"Attenuation ( self )","title":"Attenuation"},{"location":"python_api/pcg_gazebo.parsers.sdf/#autostart","text":"AutoStart ( self , default = True )","title":"AutoStart"},{"location":"python_api/pcg_gazebo.parsers.sdf/#axis","text":"Axis ( self )","title":"Axis"},{"location":"python_api/pcg_gazebo.parsers.sdf/#axis2","text":"Axis2 ( self )","title":"Axis2"},{"location":"python_api/pcg_gazebo.parsers.sdf/#biasmean","text":"BiasMean ( self , default = 0 )","title":"BiasMean"},{"location":"python_api/pcg_gazebo.parsers.sdf/#biasstddev","text":"BiasStdDev ( self , default = 0 )","title":"BiasStdDev"},{"location":"python_api/pcg_gazebo.parsers.sdf/#bounce","text":"Bounce ( self )","title":"Bounce"},{"location":"python_api/pcg_gazebo.parsers.sdf/#box","text":"Box ( self )","title":"Box"},{"location":"python_api/pcg_gazebo.parsers.sdf/#bullet","text":"Bullet ( self , mode = 'physics' )","title":"Bullet"},{"location":"python_api/pcg_gazebo.parsers.sdf/#camera","text":"Camera ( self )","title":"Camera"},{"location":"python_api/pcg_gazebo.parsers.sdf/#castshadows","text":"CastShadows ( self , default = True )","title":"CastShadows"},{"location":"python_api/pcg_gazebo.parsers.sdf/#center","text":"Center ( self , default = False )","title":"Center"},{"location":"python_api/pcg_gazebo.parsers.sdf/#cfm","text":"CFM ( self , default = 0 )","title":"CFM"},{"location":"python_api/pcg_gazebo.parsers.sdf/#child","text":"Child ( self , default = 'none' )","title":"Child"},{"location":"python_api/pcg_gazebo.parsers.sdf/#clip","text":"Clip ( self )","title":"Clip"},{"location":"python_api/pcg_gazebo.parsers.sdf/#coefficient","text":"Coefficient ( self , default = 1 )","title":"Coefficient"},{"location":"python_api/pcg_gazebo.parsers.sdf/#collision","text":"Collision ( self )","title":"Collision"},{"location":"python_api/pcg_gazebo.parsers.sdf/#constant","text":"Constant ( self , default = 0 )","title":"Constant"},{"location":"python_api/pcg_gazebo.parsers.sdf/#constraints","text":"Constraints ( self , engine = 'ode' )","title":"Constraints"},{"location":"python_api/pcg_gazebo.parsers.sdf/#contactmaxcorrectingvel","text":"ContactMaxCorrectingVel ( self , default = 100 )","title":"ContactMaxCorrectingVel"},{"location":"python_api/pcg_gazebo.parsers.sdf/#contactsurfacelayer","text":"ContactSurfaceLayer ( self , default = 0.001 )","title":"ContactSurfaceLayer"},{"location":"python_api/pcg_gazebo.parsers.sdf/#contact","text":"Contact ( self , mode = 'simbody' )","title":"Contact"},{"location":"python_api/pcg_gazebo.parsers.sdf/#cylinder","text":"Cylinder ( self )","title":"Cylinder"},{"location":"python_api/pcg_gazebo.parsers.sdf/#damping","text":"Damping ( self , default = 0 )","title":"Damping"},{"location":"python_api/pcg_gazebo.parsers.sdf/#delaystart","text":"DelayStart ( self , default = 0 )","title":"DelayStart"},{"location":"python_api/pcg_gazebo.parsers.sdf/#depthcamera","text":"DepthCamera ( self )","title":"DepthCamera"},{"location":"python_api/pcg_gazebo.parsers.sdf/#diffuse","text":"Diffuse ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Diffuse"},{"location":"python_api/pcg_gazebo.parsers.sdf/#direction","text":"Direction ( self , default = [ 0 , 0 , - 1 ])","title":"Direction"},{"location":"python_api/pcg_gazebo.parsers.sdf/#dissipation","text":"Dissipation ( self , default = 100 )","title":"Dissipation"},{"location":"python_api/pcg_gazebo.parsers.sdf/#distortion","text":"Distortion ( self )","title":"Distortion"},{"location":"python_api/pcg_gazebo.parsers.sdf/#dynamicfriction","text":"DynamicFriction ( self , default = 0.9 )","title":"DynamicFriction"},{"location":"python_api/pcg_gazebo.parsers.sdf/#dynamics","text":"Dynamics ( self )","title":"Dynamics"},{"location":"python_api/pcg_gazebo.parsers.sdf/#effort","text":"Effort ( self , default =- 1 )","title":"Effort"},{"location":"python_api/pcg_gazebo.parsers.sdf/#emissive","text":"Emissive ( self , size = 4 )","title":"Emissive"},{"location":"python_api/pcg_gazebo.parsers.sdf/#empty","text":"Empty ( self )","title":"Empty"},{"location":"python_api/pcg_gazebo.parsers.sdf/#enablewind","text":"EnableWind ( self , default = False )","title":"EnableWind"},{"location":"python_api/pcg_gazebo.parsers.sdf/#erp","text":"ERP ( self , default = 0.2 )","title":"ERP"},{"location":"python_api/pcg_gazebo.parsers.sdf/#falloff","text":"FallOff ( self , default = 0 )","title":"FallOff"},{"location":"python_api/pcg_gazebo.parsers.sdf/#far","text":"Far ( self , default = 0 )","title":"Far"},{"location":"python_api/pcg_gazebo.parsers.sdf/#fdir1","text":"FDir1 ( self , default = [ 0 , 0 , 0 ]) 3-tuple specifying direction of mu1 in the collision local reference frame Args: default (list): Direction unit vector Attributes: value (list): Stored direction unit vector","title":"FDir1"},{"location":"python_api/pcg_gazebo.parsers.sdf/#filename","text":"Filename ( self , default = 'none' )","title":"Filename"},{"location":"python_api/pcg_gazebo.parsers.sdf/#forcetorque","text":"ForceTorque ( self )","title":"ForceTorque"},{"location":"python_api/pcg_gazebo.parsers.sdf/#format","text":"Format ( self , default = 'R8G8B8' )","title":"Format"},{"location":"python_api/pcg_gazebo.parsers.sdf/#frame","text":"Frame ( self , default = '' )","title":"Frame"},{"location":"python_api/pcg_gazebo.parsers.sdf/#frictionmodel","text":"FrictionModel ( self )","title":"FrictionModel"},{"location":"python_api/pcg_gazebo.parsers.sdf/#friction","text":"Friction ( self ) Configuration of the collision friction parameters. Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Friction"},{"location":"python_api/pcg_gazebo.parsers.sdf/#friction2","text":"Friction2 ( self , default = 1 )","title":"Friction2"},{"location":"python_api/pcg_gazebo.parsers.sdf/#geometry","text":"Geometry ( self )","title":"Geometry"},{"location":"python_api/pcg_gazebo.parsers.sdf/#granularity","text":"Granularity ( self , default = 1 )","title":"Granularity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#gravity","text":"Gravity ( self , default = True )","title":"Gravity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#height","text":"Height ( self , default = 1 )","title":"Height"},{"location":"python_api/pcg_gazebo.parsers.sdf/#horizontalfov","text":"HorizontalFOV ( self , default = 1.047 )","title":"HorizontalFOV"},{"location":"python_api/pcg_gazebo.parsers.sdf/#horizontal","text":"Horizontal ( self )","title":"Horizontal"},{"location":"python_api/pcg_gazebo.parsers.sdf/#image","text":"Image ( self , mode = 'geometry' )","title":"Image"},{"location":"python_api/pcg_gazebo.parsers.sdf/#imu","text":"IMU ( self )","title":"IMU"},{"location":"python_api/pcg_gazebo.parsers.sdf/#include","text":"Include ( self )","title":"Include"},{"location":"python_api/pcg_gazebo.parsers.sdf/#inertia","text":"Inertia ( self )","title":"Inertia"},{"location":"python_api/pcg_gazebo.parsers.sdf/#inertial","text":"Inertial ( self )","title":"Inertial"},{"location":"python_api/pcg_gazebo.parsers.sdf/#initialposition","text":"InitialPosition ( self , default = 0 )","title":"InitialPosition"},{"location":"python_api/pcg_gazebo.parsers.sdf/#innerangle","text":"InnerAngle ( self , default = 0 )","title":"InnerAngle"},{"location":"python_api/pcg_gazebo.parsers.sdf/#interpolatex","text":"InterpolateX ( self , default = False )","title":"InterpolateX"},{"location":"python_api/pcg_gazebo.parsers.sdf/#iters","text":"Iters ( self , default = 50 )","title":"Iters"},{"location":"python_api/pcg_gazebo.parsers.sdf/#ixx","text":"IXX ( self , default = 0 )","title":"IXX"},{"location":"python_api/pcg_gazebo.parsers.sdf/#ixy","text":"IXY ( self , default = 0 )","title":"IXY"},{"location":"python_api/pcg_gazebo.parsers.sdf/#ixz","text":"IXZ ( self , default = 0 )","title":"IXZ"},{"location":"python_api/pcg_gazebo.parsers.sdf/#iyy","text":"IYY ( self , default = 0 )","title":"IYY"},{"location":"python_api/pcg_gazebo.parsers.sdf/#iyz","text":"IYZ ( self , default = 0 )","title":"IYZ"},{"location":"python_api/pcg_gazebo.parsers.sdf/#izz","text":"IZZ ( self , default = 0 )","title":"IZZ"},{"location":"python_api/pcg_gazebo.parsers.sdf/#joint","text":"Joint ( self )","title":"Joint"},{"location":"python_api/pcg_gazebo.parsers.sdf/#k1","text":"K1 ( self , default = 0 )","title":"K1"},{"location":"python_api/pcg_gazebo.parsers.sdf/#k2","text":"K2 ( self , default = 0 )","title":"K2"},{"location":"python_api/pcg_gazebo.parsers.sdf/#k3","text":"K3 ( self , default = 0 )","title":"K3"},{"location":"python_api/pcg_gazebo.parsers.sdf/#kd","text":"Kd ( self , default = 1 )","title":"Kd"},{"location":"python_api/pcg_gazebo.parsers.sdf/#kinematic","text":"Kinematic ( self , default = False )","title":"Kinematic"},{"location":"python_api/pcg_gazebo.parsers.sdf/#kp","text":"Kp ( self , default = 1000000000000.0 )","title":"Kp"},{"location":"python_api/pcg_gazebo.parsers.sdf/#laserretro","text":"LaserRetro ( self , default = 0 )","title":"LaserRetro"},{"location":"python_api/pcg_gazebo.parsers.sdf/#length","text":"Length ( self )","title":"Length"},{"location":"python_api/pcg_gazebo.parsers.sdf/#light","text":"Light ( self )","title":"Light"},{"location":"python_api/pcg_gazebo.parsers.sdf/#lighting","text":"Lighting ( self , default = False )","title":"Lighting"},{"location":"python_api/pcg_gazebo.parsers.sdf/#limit","text":"Limit ( self , mode = 'axis' )","title":"Limit"},{"location":"python_api/pcg_gazebo.parsers.sdf/#linearacceleration","text":"LinearAcceleration ( self )","title":"LinearAcceleration"},{"location":"python_api/pcg_gazebo.parsers.sdf/#linear","text":"Linear ( self , default = 0 )","title":"Linear"},{"location":"python_api/pcg_gazebo.parsers.sdf/#link","text":"Link ( self )","title":"Link"},{"location":"python_api/pcg_gazebo.parsers.sdf/#localization","text":"Localization ( self , default = 'CUSTOM' )","title":"Localization"},{"location":"python_api/pcg_gazebo.parsers.sdf/#loop","text":"Loop ( self , default = False )","title":"Loop"},{"location":"python_api/pcg_gazebo.parsers.sdf/#lower","text":"Lower ( self , default =- 1e+16 )","title":"Lower"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mass","text":"Mass ( self )","title":"Mass"},{"location":"python_api/pcg_gazebo.parsers.sdf/#material","text":"Material ( self )","title":"Material"},{"location":"python_api/pcg_gazebo.parsers.sdf/#maxangle","text":"MaxAngle ( self , default = 0 )","title":"MaxAngle"},{"location":"python_api/pcg_gazebo.parsers.sdf/#maxcontacts","text":"MaxContacts ( self , default = 20 )","title":"MaxContacts"},{"location":"python_api/pcg_gazebo.parsers.sdf/#maxstepsize","text":"MaxStepSize ( self , default = 0.001 )","title":"MaxStepSize"},{"location":"python_api/pcg_gazebo.parsers.sdf/#maxtransientvelocity","text":"MaxTransientVelocity ( self , default = 0.01 )","title":"MaxTransientVelocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#maxvel","text":"MaxVel ( self , default = 0.01 )","title":"MaxVel"},{"location":"python_api/pcg_gazebo.parsers.sdf/#max","text":"Max ( self , default = 0 )","title":"Max"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mean_1","text":"Mean ( self )","title":"Mean"},{"location":"python_api/pcg_gazebo.parsers.sdf/#measuredirection","text":"MeasureDirection ( self , default = 'child_to_parent' )","title":"MeasureDirection"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mesh","text":"Mesh ( self )","title":"Mesh"},{"location":"python_api/pcg_gazebo.parsers.sdf/#minangle","text":"MinAngle ( self , default = 0 )","title":"MinAngle"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mindepth","text":"MinDepth ( self , default = 0 )","title":"MinDepth"},{"location":"python_api/pcg_gazebo.parsers.sdf/#minstepsize","text":"MinStepSize ( self , default = 0.0001 )","title":"MinStepSize"},{"location":"python_api/pcg_gazebo.parsers.sdf/#min","text":"Min ( self , default = 0 )","title":"Min"},{"location":"python_api/pcg_gazebo.parsers.sdf/#model","text":"Model ( self )","title":"Model"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mu","text":"Mu ( self , default = 1 ) Coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Mu"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mu2","text":"Mu2 ( self , default = 1 ) Second coefficient of friction in the range of [0, 1] Args: default (float): Coefficient of friction Attributes: value (float): Stored coefficient of friction","title":"Mu2"},{"location":"python_api/pcg_gazebo.parsers.sdf/#mustbeloopjoint","text":"MustBeLoopJoint ( self , default = False )","title":"MustBeLoopJoint"},{"location":"python_api/pcg_gazebo.parsers.sdf/#name","text":"Name ( self , default = 'none' )","title":"Name"},{"location":"python_api/pcg_gazebo.parsers.sdf/#near","text":"Near ( self , default = 0 )","title":"Near"},{"location":"python_api/pcg_gazebo.parsers.sdf/#noise","text":"Noise ( self , type = 'none' )","title":"Noise"},{"location":"python_api/pcg_gazebo.parsers.sdf/#normalmap","text":"NormalMap ( self , default = '' )","title":"NormalMap"},{"location":"python_api/pcg_gazebo.parsers.sdf/#normal","text":"Normal ( self )","title":"Normal"},{"location":"python_api/pcg_gazebo.parsers.sdf/#ode","text":"ODE ( self , mode )","title":"ODE"},{"location":"python_api/pcg_gazebo.parsers.sdf/#orientationreferenceframe","text":"OrientationReferenceFrame ( self )","title":"OrientationReferenceFrame"},{"location":"python_api/pcg_gazebo.parsers.sdf/#outerangle","text":"OuterAngle ( self , default = 0 )","title":"OuterAngle"},{"location":"python_api/pcg_gazebo.parsers.sdf/#output","text":"Output ( self , default = 'depths' )","title":"Output"},{"location":"python_api/pcg_gazebo.parsers.sdf/#overrideimpactcapturevelocity","text":"OverrideImpactCaptureVelocity ( self , default = 0.001 )","title":"OverrideImpactCaptureVelocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#overridestictiontransitionvelocity","text":"OverrideStictionTransitionVelocity ( self , default = 0.9 )","title":"OverrideStictionTransitionVelocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#p1","text":"P1 ( self , default = 0 )","title":"P1"},{"location":"python_api/pcg_gazebo.parsers.sdf/#p2","text":"P2 ( self , default = 0 )","title":"P2"},{"location":"python_api/pcg_gazebo.parsers.sdf/#parent","text":"Parent ( self , default = 'parent' )","title":"Parent"},{"location":"python_api/pcg_gazebo.parsers.sdf/#patchradius","text":"PatchRadius ( self , default = 0 )","title":"PatchRadius"},{"location":"python_api/pcg_gazebo.parsers.sdf/#path","text":"Path ( self , default = '__default__' )","title":"Path"},{"location":"python_api/pcg_gazebo.parsers.sdf/#physics","text":"Physics ( self , mode = 'ode' )","title":"Physics"},{"location":"python_api/pcg_gazebo.parsers.sdf/#plane","text":"Plane ( self )","title":"Plane"},{"location":"python_api/pcg_gazebo.parsers.sdf/#plasticcoefrestitution","text":"PlasticCoefRestitution ( self , default = 0.5 )","title":"PlasticCoefRestitution"},{"location":"python_api/pcg_gazebo.parsers.sdf/#plasticimpactvelocity","text":"PlasticImpactVelocity ( self , default = 0.5 )","title":"PlasticImpactVelocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#plugin","text":"Plugin ( self , default = {})","title":"Plugin"},{"location":"python_api/pcg_gazebo.parsers.sdf/#point","text":"Point ( self , vec_length = 2 )","title":"Point"},{"location":"python_api/pcg_gazebo.parsers.sdf/#polyline","text":"Polyline ( self )","title":"Polyline"},{"location":"python_api/pcg_gazebo.parsers.sdf/#pose","text":"Pose ( self )","title":"Pose"},{"location":"python_api/pcg_gazebo.parsers.sdf/#precision","text":"Precision ( self )","title":"Precision"},{"location":"python_api/pcg_gazebo.parsers.sdf/#preconiters","text":"PreConIters ( self , default = 0 )","title":"PreConIters"},{"location":"python_api/pcg_gazebo.parsers.sdf/#providefeedback","text":"ProvideFeedback ( self , default = False )","title":"ProvideFeedback"},{"location":"python_api/pcg_gazebo.parsers.sdf/#quadratic","text":"Quadratic ( self , default = 0 )","title":"Quadratic"},{"location":"python_api/pcg_gazebo.parsers.sdf/#radius","text":"Radius ( self , default = 0 )","title":"Radius"},{"location":"python_api/pcg_gazebo.parsers.sdf/#range","text":"Range ( self )","title":"Range"},{"location":"python_api/pcg_gazebo.parsers.sdf/#rate","text":"Rate ( self , type = 'none' )","title":"Rate"},{"location":"python_api/pcg_gazebo.parsers.sdf/#ray","text":"Ray ( self )","title":"Ray"},{"location":"python_api/pcg_gazebo.parsers.sdf/#realtimefactor","text":"RealTimeFactor ( self , default = 1 )","title":"RealTimeFactor"},{"location":"python_api/pcg_gazebo.parsers.sdf/#realtimeupdaterate","text":"RealTimeUpdateRate ( self , default = 1 )","title":"RealTimeUpdateRate"},{"location":"python_api/pcg_gazebo.parsers.sdf/#resolution","text":"Resolution ( self , default = 0 )","title":"Resolution"},{"location":"python_api/pcg_gazebo.parsers.sdf/#restitutioncoefficient","text":"RestitutionCoefficient ( self , default = 0 )","title":"RestitutionCoefficient"},{"location":"python_api/pcg_gazebo.parsers.sdf/#rollingfriction","text":"RollingFriction ( self , default = 1 )","title":"RollingFriction"},{"location":"python_api/pcg_gazebo.parsers.sdf/#samples","text":"Samples ( self , default = 640 )","title":"Samples"},{"location":"python_api/pcg_gazebo.parsers.sdf/#save","text":"Save ( self )","title":"Save"},{"location":"python_api/pcg_gazebo.parsers.sdf/#scale","text":"Scale ( self , size = 3 )","title":"Scale"},{"location":"python_api/pcg_gazebo.parsers.sdf/#scan","text":"Scan ( self )","title":"Scan"},{"location":"python_api/pcg_gazebo.parsers.sdf/#script","text":"Script ( self , mode = 'material' )","title":"Script"},{"location":"python_api/pcg_gazebo.parsers.sdf/#sdf","text":"SDF ( self , mode = 'world' )","title":"SDF"},{"location":"python_api/pcg_gazebo.parsers.sdf/#selfcollide","text":"SelfCollide ( self , default = False )","title":"SelfCollide"},{"location":"python_api/pcg_gazebo.parsers.sdf/#sensor","text":"Sensor ( self , mode = 'altimeter' )","title":"Sensor"},{"location":"python_api/pcg_gazebo.parsers.sdf/#shader","text":"Shader ( self )","title":"Shader"},{"location":"python_api/pcg_gazebo.parsers.sdf/#simbody","text":"Simbody ( self , mode = 'physics' )","title":"Simbody"},{"location":"python_api/pcg_gazebo.parsers.sdf/#size","text":"Size ( self , vec_length = 3 )","title":"Size"},{"location":"python_api/pcg_gazebo.parsers.sdf/#skin","text":"Skin ( self )","title":"Skin"},{"location":"python_api/pcg_gazebo.parsers.sdf/#slip","text":"Slip ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip"},{"location":"python_api/pcg_gazebo.parsers.sdf/#slip1","text":"Slip1 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip1"},{"location":"python_api/pcg_gazebo.parsers.sdf/#slip2","text":"Slip2 ( self , default = 0 ) Force dependent slip direction 1 in collision local frame, between the range of [0,1]. Args: default (float): Slip coefficient Attributes: value (float): Stored slip coefficient","title":"Slip2"},{"location":"python_api/pcg_gazebo.parsers.sdf/#softcfm","text":"SoftCFM ( self , default = 0 )","title":"SoftCFM"},{"location":"python_api/pcg_gazebo.parsers.sdf/#softerp","text":"SoftERP ( self , default = 0.2 )","title":"SoftERP"},{"location":"python_api/pcg_gazebo.parsers.sdf/#solver","text":"Solver ( self , engine = 'ode' )","title":"Solver"},{"location":"python_api/pcg_gazebo.parsers.sdf/#sor","text":"Sor ( self , default = 1.3 )","title":"Sor"},{"location":"python_api/pcg_gazebo.parsers.sdf/#specular","text":"Specular ( self , default = [ 0.1 , 0.1 , 0.1 , 1 ])","title":"Specular"},{"location":"python_api/pcg_gazebo.parsers.sdf/#sphere","text":"Sphere ( self )","title":"Sphere"},{"location":"python_api/pcg_gazebo.parsers.sdf/#splitimpulsepenetrationthreshold","text":"SplitImpulsePenetrationThreshold ( self , default =- 0.01 )","title":"SplitImpulsePenetrationThreshold"},{"location":"python_api/pcg_gazebo.parsers.sdf/#splitimpulse","text":"SplitImpulse ( self , default = True )","title":"SplitImpulse"},{"location":"python_api/pcg_gazebo.parsers.sdf/#spot","text":"Spot ( self )","title":"Spot"},{"location":"python_api/pcg_gazebo.parsers.sdf/#springreference","text":"SpringReference ( self , default = 0 )","title":"SpringReference"},{"location":"python_api/pcg_gazebo.parsers.sdf/#springstiffness","text":"SpringStiffness ( self , default = 0 )","title":"SpringStiffness"},{"location":"python_api/pcg_gazebo.parsers.sdf/#staticfriction","text":"StaticFriction ( self , default = 0.9 )","title":"StaticFriction"},{"location":"python_api/pcg_gazebo.parsers.sdf/#static","text":"Static ( self , default = False )","title":"Static"},{"location":"python_api/pcg_gazebo.parsers.sdf/#stddev_1","text":"StdDev ( self )","title":"StdDev"},{"location":"python_api/pcg_gazebo.parsers.sdf/#stiffness","text":"Stiffness ( self , default = 100000000.0 )","title":"Stiffness"},{"location":"python_api/pcg_gazebo.parsers.sdf/#submesh","text":"SubMesh ( self )","title":"SubMesh"},{"location":"python_api/pcg_gazebo.parsers.sdf/#surfaceradius","text":"SurfaceRadius ( self , default = 0 )","title":"SurfaceRadius"},{"location":"python_api/pcg_gazebo.parsers.sdf/#surface","text":"Surface ( self )","title":"Surface"},{"location":"python_api/pcg_gazebo.parsers.sdf/#threshold","text":"Threshold ( self , default = 0 )","title":"Threshold"},{"location":"python_api/pcg_gazebo.parsers.sdf/#time","text":"Time ( self , default = 0 )","title":"Time"},{"location":"python_api/pcg_gazebo.parsers.sdf/#topic","text":"Topic ( self , default = 'none' )","title":"Topic"},{"location":"python_api/pcg_gazebo.parsers.sdf/#torsional","text":"Torsional ( self )","title":"Torsional"},{"location":"python_api/pcg_gazebo.parsers.sdf/#trajectory","text":"Trajectory ( self )","title":"Trajectory"},{"location":"python_api/pcg_gazebo.parsers.sdf/#transparency","text":"Transparency ( self , default = 0 )","title":"Transparency"},{"location":"python_api/pcg_gazebo.parsers.sdf/#type","text":"Type ( self , default = '' )","title":"Type"},{"location":"python_api/pcg_gazebo.parsers.sdf/#updaterate","text":"UpdateRate ( self , default = 0 )","title":"UpdateRate"},{"location":"python_api/pcg_gazebo.parsers.sdf/#upper","text":"Upper ( self , default = 1e+16 )","title":"Upper"},{"location":"python_api/pcg_gazebo.parsers.sdf/#urdf","text":"URDF ( self , mode = 'model' )","title":"URDF"},{"location":"python_api/pcg_gazebo.parsers.sdf/#uri","text":"URI ( self , default = '' )","title":"URI"},{"location":"python_api/pcg_gazebo.parsers.sdf/#usedynamicmoirescaling","text":"UseDynamicMOIRescaling ( self , default = False )","title":"UseDynamicMOIRescaling"},{"location":"python_api/pcg_gazebo.parsers.sdf/#useparentmodelframe","text":"UseParentModelFrame ( self , default = False )","title":"UseParentModelFrame"},{"location":"python_api/pcg_gazebo.parsers.sdf/#usepatchradius","text":"UsePatchRadius ( self , default = True )","title":"UsePatchRadius"},{"location":"python_api/pcg_gazebo.parsers.sdf/#velocity","text":"Velocity ( self , default =- 1 )","title":"Velocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#verticalposition","text":"VerticalPosition ( self )","title":"VerticalPosition"},{"location":"python_api/pcg_gazebo.parsers.sdf/#verticalvelocity","text":"VerticalVelocity ( self )","title":"VerticalVelocity"},{"location":"python_api/pcg_gazebo.parsers.sdf/#vertical","text":"Vertical ( self )","title":"Vertical"},{"location":"python_api/pcg_gazebo.parsers.sdf/#viscousfriction","text":"ViscousFriction ( self , default = 0 )","title":"ViscousFriction"},{"location":"python_api/pcg_gazebo.parsers.sdf/#visual","text":"Visual ( self )","title":"Visual"},{"location":"python_api/pcg_gazebo.parsers.sdf/#visualize","text":"Visualize ( self , default = False )","title":"Visualize"},{"location":"python_api/pcg_gazebo.parsers.sdf/#waypoint","text":"Waypoint ( self )","title":"Waypoint"},{"location":"python_api/pcg_gazebo.parsers.sdf/#width","text":"Width ( self , default = 320 )","title":"Width"},{"location":"python_api/pcg_gazebo.parsers.sdf/#world","text":"World ( self )","title":"World"},{"location":"python_api/pcg_gazebo.parsers.sdf/#x","text":"X ( self )","title":"X"},{"location":"python_api/pcg_gazebo.parsers.sdf/#xyz","text":"XYZ ( self , default = [ 0 , 0 , 1 ])","title":"XYZ"},{"location":"python_api/pcg_gazebo.parsers.sdf/#y","text":"Y ( self )","title":"Y"},{"location":"python_api/pcg_gazebo.parsers.sdf/#z","text":"Z ( self )","title":"Z"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/","text":"pcg_gazebo.parsers.sdf_config \u00b6 Author \u00b6 Author ( self ) Description \u00b6 Description ( self , default = 'none' ) EMail \u00b6 EMail ( self , default = 'none' ) Model \u00b6 Model ( self ) Name \u00b6 Name ( self , default = 'none' ) SDF \u00b6 SDF ( self , default = 'model.sdf' ) Version \u00b6 Version ( self , default = 'none' )","title":"pcg_gazebo.parsers.sdf_config"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#pcg_gazeboparserssdf_config","text":"","title":"pcg_gazebo.parsers.sdf_config"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#author","text":"Author ( self )","title":"Author"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#description","text":"Description ( self , default = 'none' )","title":"Description"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#email","text":"EMail ( self , default = 'none' )","title":"EMail"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#model","text":"Model ( self )","title":"Model"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#name","text":"Name ( self , default = 'none' )","title":"Name"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#sdf","text":"SDF ( self , default = 'model.sdf' )","title":"SDF"},{"location":"python_api/pcg_gazebo.parsers.sdf_config/#version","text":"Version ( self , default = 'none' )","title":"Version"},{"location":"python_api/pcg_gazebo.parsers.types/","text":"pcg_gazebo.parsers.types \u00b6 XMLBase \u00b6 XMLBase ( self ) xml_element_name \u00b6 str : Name of the SDF element xml_format \u00b6 str : Name of the XML format XMLBoolean \u00b6 XMLBoolean ( self , default = False ) XMLCustom \u00b6 XMLCustom ( self , default = {}) XMLInteger \u00b6 XMLInteger ( self , default = 0 ) XMLScalar \u00b6 XMLScalar ( self , default = 0 ) XMLString \u00b6 XMLString ( self , default = '' ) XMLVector \u00b6 XMLVector ( self , size = None )","title":"pcg_gazebo.parsers.types"},{"location":"python_api/pcg_gazebo.parsers.types/#pcg_gazeboparserstypes","text":"","title":"pcg_gazebo.parsers.types"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlbase","text":"XMLBase ( self )","title":"XMLBase"},{"location":"python_api/pcg_gazebo.parsers.types/#xml_element_name","text":"str : Name of the SDF element","title":"xml_element_name"},{"location":"python_api/pcg_gazebo.parsers.types/#xml_format","text":"str : Name of the XML format","title":"xml_format"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlboolean","text":"XMLBoolean ( self , default = False )","title":"XMLBoolean"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlcustom","text":"XMLCustom ( self , default = {})","title":"XMLCustom"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlinteger","text":"XMLInteger ( self , default = 0 )","title":"XMLInteger"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlscalar","text":"XMLScalar ( self , default = 0 )","title":"XMLScalar"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlstring","text":"XMLString ( self , default = '' )","title":"XMLString"},{"location":"python_api/pcg_gazebo.parsers.types/#xmlvector","text":"XMLVector ( self , size = None )","title":"XMLVector"},{"location":"python_api/pcg_gazebo.parsers.urdf/","text":"pcg_gazebo.parsers.urdf \u00b6 Actuator \u00b6 Actuator ( self ) Axis \u00b6 Axis ( self , default = [ 1 , 0 , 0 ]) Box \u00b6 Box ( self ) Child \u00b6 Child ( self , default = 'link' ) Collision \u00b6 Collision ( self ) Color \u00b6 Color ( self , default = [ 0 , 0 , 0 , 1 ]) Cylinder \u00b6 Cylinder ( self ) Dynamics \u00b6 Dynamics ( self ) Gazebo \u00b6 Gazebo ( self , mode = 'none' , sdf_elements = {}) Geometry \u00b6 Geometry ( self ) HardwareInterface \u00b6 HardwareInterface ( self , default = 'EffortJointInterface' ) Inertia \u00b6 Inertia ( self ) Inertial \u00b6 Inertial ( self ) Joint \u00b6 Joint ( self ) Kd \u00b6 Kd ( self , default = 1 ) Kp \u00b6 Kp ( self , default = 1000000000000.0 ) Limit \u00b6 Limit ( self ) Link \u00b6 Link ( self ) Mass \u00b6 Mass ( self ) Material \u00b6 Material ( self , mode = 'color' ) MaxContacts \u00b6 MaxContacts ( self , default = 20 ) MaxVel \u00b6 MaxVel ( self , default = 0.01 ) MechanicalReduction \u00b6 MechanicalReduction ( self , default = 1 ) Mesh \u00b6 Mesh ( self ) Mimic \u00b6 Mimic ( self ) MinDepth \u00b6 MinDepth ( self , default = 0 ) Mu1 \u00b6 Mu1 ( self , default = 1 ) Mu2 \u00b6 Mu2 ( self , default = 1 ) Origin \u00b6 Origin ( self ) Parent \u00b6 Parent ( self , default = 'link' ) ProvideFeedback \u00b6 ProvideFeedback ( self , default = False ) Robot \u00b6 Robot ( self ) SafetyController \u00b6 SafetyController ( self ) SelfCollide \u00b6 SelfCollide ( self , default = False ) Sphere \u00b6 Sphere ( self ) StopCFM \u00b6 StopCFM ( self , default = 0 ) StopERP \u00b6 StopERP ( self , default = 0.2 ) Texture \u00b6 Texture ( self , default = 'filename' ) Transmission \u00b6 Transmission ( self ) Type \u00b6 Type ( self , default = 'transmission_interface/SimpleTransmission' ) Visual \u00b6 Visual ( self )","title":"pcg_gazebo.parsers.urdf"},{"location":"python_api/pcg_gazebo.parsers.urdf/#pcg_gazeboparsersurdf","text":"","title":"pcg_gazebo.parsers.urdf"},{"location":"python_api/pcg_gazebo.parsers.urdf/#actuator","text":"Actuator ( self )","title":"Actuator"},{"location":"python_api/pcg_gazebo.parsers.urdf/#axis","text":"Axis ( self , default = [ 1 , 0 , 0 ])","title":"Axis"},{"location":"python_api/pcg_gazebo.parsers.urdf/#box","text":"Box ( self )","title":"Box"},{"location":"python_api/pcg_gazebo.parsers.urdf/#child","text":"Child ( self , default = 'link' )","title":"Child"},{"location":"python_api/pcg_gazebo.parsers.urdf/#collision","text":"Collision ( self )","title":"Collision"},{"location":"python_api/pcg_gazebo.parsers.urdf/#color","text":"Color ( self , default = [ 0 , 0 , 0 , 1 ])","title":"Color"},{"location":"python_api/pcg_gazebo.parsers.urdf/#cylinder","text":"Cylinder ( self )","title":"Cylinder"},{"location":"python_api/pcg_gazebo.parsers.urdf/#dynamics","text":"Dynamics ( self )","title":"Dynamics"},{"location":"python_api/pcg_gazebo.parsers.urdf/#gazebo","text":"Gazebo ( self , mode = 'none' , sdf_elements = {})","title":"Gazebo"},{"location":"python_api/pcg_gazebo.parsers.urdf/#geometry","text":"Geometry ( self )","title":"Geometry"},{"location":"python_api/pcg_gazebo.parsers.urdf/#hardwareinterface","text":"HardwareInterface ( self , default = 'EffortJointInterface' )","title":"HardwareInterface"},{"location":"python_api/pcg_gazebo.parsers.urdf/#inertia","text":"Inertia ( self )","title":"Inertia"},{"location":"python_api/pcg_gazebo.parsers.urdf/#inertial","text":"Inertial ( self )","title":"Inertial"},{"location":"python_api/pcg_gazebo.parsers.urdf/#joint","text":"Joint ( self )","title":"Joint"},{"location":"python_api/pcg_gazebo.parsers.urdf/#kd","text":"Kd ( self , default = 1 )","title":"Kd"},{"location":"python_api/pcg_gazebo.parsers.urdf/#kp","text":"Kp ( self , default = 1000000000000.0 )","title":"Kp"},{"location":"python_api/pcg_gazebo.parsers.urdf/#limit","text":"Limit ( self )","title":"Limit"},{"location":"python_api/pcg_gazebo.parsers.urdf/#link","text":"Link ( self )","title":"Link"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mass","text":"Mass ( self )","title":"Mass"},{"location":"python_api/pcg_gazebo.parsers.urdf/#material","text":"Material ( self , mode = 'color' )","title":"Material"},{"location":"python_api/pcg_gazebo.parsers.urdf/#maxcontacts","text":"MaxContacts ( self , default = 20 )","title":"MaxContacts"},{"location":"python_api/pcg_gazebo.parsers.urdf/#maxvel","text":"MaxVel ( self , default = 0.01 )","title":"MaxVel"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mechanicalreduction","text":"MechanicalReduction ( self , default = 1 )","title":"MechanicalReduction"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mesh","text":"Mesh ( self )","title":"Mesh"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mimic","text":"Mimic ( self )","title":"Mimic"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mindepth","text":"MinDepth ( self , default = 0 )","title":"MinDepth"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mu1","text":"Mu1 ( self , default = 1 )","title":"Mu1"},{"location":"python_api/pcg_gazebo.parsers.urdf/#mu2","text":"Mu2 ( self , default = 1 )","title":"Mu2"},{"location":"python_api/pcg_gazebo.parsers.urdf/#origin","text":"Origin ( self )","title":"Origin"},{"location":"python_api/pcg_gazebo.parsers.urdf/#parent","text":"Parent ( self , default = 'link' )","title":"Parent"},{"location":"python_api/pcg_gazebo.parsers.urdf/#providefeedback","text":"ProvideFeedback ( self , default = False )","title":"ProvideFeedback"},{"location":"python_api/pcg_gazebo.parsers.urdf/#robot","text":"Robot ( self )","title":"Robot"},{"location":"python_api/pcg_gazebo.parsers.urdf/#safetycontroller","text":"SafetyController ( self )","title":"SafetyController"},{"location":"python_api/pcg_gazebo.parsers.urdf/#selfcollide","text":"SelfCollide ( self , default = False )","title":"SelfCollide"},{"location":"python_api/pcg_gazebo.parsers.urdf/#sphere","text":"Sphere ( self )","title":"Sphere"},{"location":"python_api/pcg_gazebo.parsers.urdf/#stopcfm","text":"StopCFM ( self , default = 0 )","title":"StopCFM"},{"location":"python_api/pcg_gazebo.parsers.urdf/#stoperp","text":"StopERP ( self , default = 0.2 )","title":"StopERP"},{"location":"python_api/pcg_gazebo.parsers.urdf/#texture","text":"Texture ( self , default = 'filename' )","title":"Texture"},{"location":"python_api/pcg_gazebo.parsers.urdf/#transmission","text":"Transmission ( self )","title":"Transmission"},{"location":"python_api/pcg_gazebo.parsers.urdf/#type","text":"Type ( self , default = 'transmission_interface/SimpleTransmission' )","title":"Type"},{"location":"python_api/pcg_gazebo.parsers.urdf/#visual","text":"Visual ( self )","title":"Visual"},{"location":"python_api/pcg_gazebo.simulation/","text":"pcg_gazebo.simulation \u00b6 Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo. create_object \u00b6 create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance. get_gazebo_model_folders \u00b6 get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names. load_gazebo_models \u00b6 load_gazebo_models () Search for Gazebo models in the local .gazebo / models folder and in the ROS paths. Returns dict : Information of all Gazebo models found get_gazebo_models \u00b6 get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo / models folder and in the catkin workspace as a dictionary. get_gazebo_model_names \u00b6 get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo / models folders and catkin workspace. is_gazebo_model \u00b6 is_gazebo_model ( name ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model. get_gazebo_model_path \u00b6 get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder get_gazebo_model_sdf \u00b6 get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model . sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo . parsers . types . XMLBase instance as an SDF element. Box \u00b6 Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo . simulation . Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [ 1 , 1 , 1 ] ): Vector with width, length and height of the box, collision \u00b6 pcg_gazebo . simulation . properties . Collision : Return single box-shaped collision model. size \u00b6 List of float : Size of the box as [ width , length , height ] visual \u00b6 pcg_gazebo . simulation . properties . Visual : Return single box-shaped visual model. to_sdf \u00b6 Box . to_sdf ( self , type = 'model' , name = 'box' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance. add_inertial \u00b6 Box . add_inertial ( self , mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_inertial \u00b6 Box . update_inertial ( self , mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Box . update_collision ( self ) Update collision model according to the current size . update_visual \u00b6 Box . update_visual ( self ) Update visual model according to the current size . Cylinder \u00b6 Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo . simulation . Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters. collision \u00b6 pcg_gazebo . simulation . properties . Collision : Return single cylinder-shaped collision model. length \u00b6 float : Length of the cylinder in meters radius \u00b6 float : Radius of the cylinder in meters visual \u00b6 pcg_gazebo . simulation . properties . Visual : Return single cylinder-shaped visual model. to_sdf \u00b6 Cylinder . to_sdf ( self , type = 'model' , name = 'cylinder' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance. update_inertial \u00b6 Cylinder . update_inertial ( self , mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Cylinder . update_collision ( self ) Update collision model according to the current length and radius . update_visual \u00b6 Cylinder . update_visual ( self ) Update visual model according to the current length and radius . Joint \u00b6 Joint ( self , name = 'joint' , parent = None , child = None , joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 ) Light \u00b6 Light ( self , name = 'default' , type = 'point' ) SimulationModel \u00b6 SimulationModel ( self , name = 'model' , parent = 'world' , creation_time = None , life_timeout = None , is_ground_plane = False ) Link \u00b6 Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ). collisions \u00b6 List of pcg_gazebo . simulation . properties . Collision : List of collision models creation_time \u00b6 float : Time of creation of this object, if it represents a single-link model. inertial \u00b6 pcg_gazebo . simulation . properties . Inertial : Description of the object's moments of inertia. kinematic \u00b6 bool : Flag to indicate if the model is purely kinematic life_timeout \u00b6 float : Life timeout timestamp for this object, if it represents a single-link model name \u00b6 str : Object name pose \u00b6 pcg_gazebo . simulation . properties . Pose : Pose of the object self_collide \u00b6 bool : Self-collision flag static \u00b6 bool : Flag to indicate if object is static visuals \u00b6 List of pcg_gazebo . simulation . properties . Visual : List of visual models create_link_from_mesh \u00b6 Link . create_link_from_mesh ( name = 'link' , visual_mesh_filename = None , collision_mesh_filename = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' ) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh_filename ( type: str , default: None ): Filename to the visual mesh file. collision_mesh_filename ( type: str , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict ( ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo . simulation . Link instance. enable_collision \u00b6 Link . enable_collision ( self ) Enable the inclusion of the collision models in the exported SDF description. disable_collision \u00b6 Link . disable_collision ( self ) Disable the inclusion of the collision models in the exported SDF description. enable_visual \u00b6 Link . enable_visual ( self ) Enable the inclusion of the visual models in the exported SDF description. disable_visual \u00b6 Link . disable_visual ( self ) Disable the inclusion of the collision models in the exported SDF description. get_collision_by_name \u00b6 Link . get_collision_by_name ( self , name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo . simulation . properties . Collision , or None if not collision with the given name is found. has_collision \u00b6 Link . has_collision ( self , name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise. get_visual_by_name \u00b6 Link . get_visual_by_name ( self , name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo . simulation . properties . Visual , or None if not visual with the given name is found. has_visual \u00b6 Link . has_visual ( self , name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise. add_empty_visual \u00b6 Link . add_empty_visual ( self , name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists. add_visual \u00b6 Link . add_visual ( self , visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo . simulation . properties . Visual ): Visual element Returns bool : True , if visual element could be added to object. add_empty_collision \u00b6 Link . add_empty_collision ( self , name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists. add_collision \u00b6 Link . add_collision ( self , collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo . simulation . properties . Collision ): Collision element Returns bool : True , if collision element could be added to object. to_sdf \u00b6 Link . to_sdf ( self , type = 'link' , name = 'model' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance. from_sdf \u00b6 Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo . simulation . Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo . parsers . sdf . Link ): SDF object Returns pcg_gazebo . simulation . Link : Simulation object instance export_to_gazebo_model \u00b6 Link . export_to_gazebo_model ( self , output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir / model . sdf model . config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1 . 6 ): Version of the SDF format version ( type: str , default: 0 . 1 . 0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully. add_inertial \u00b6 Link . add_inertial ( self , mass ) This function must be implemented by derived classes. update_inertial \u00b6 Link . update_inertial ( self ) This function must be implemented by derived classes. update_collision \u00b6 Link . update_collision ( self ) This function must be implemented by derived classes. update_visual \u00b6 Link . update_visual ( self ) This function must be implemented by derived classes. add_sensor \u00b6 Link . add_sensor ( self , name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo . simulation . sensors . Sensor ): Sensor description Returns bool : True , if sensor could be added to link. to_markers \u00b6 Link . to_markers ( self ) Generate visualization_msgs / Marker instances from the visual and/or collision entities. Returns visualization_msgs / MarkerArray get_footprint \u00b6 Link . get_footprint ( self , mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely . _GEOMETRIES . Polygon or shapely . _GEOMETRIES . MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely . _GEOMETRIES . Polygon or shapely . _GEOMETRIES . MultiPolygon get_meshes \u00b6 Link . get_meshes ( self , mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes. get_bounds \u00b6 Link . get_bounds ( self , mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds Plane \u00b6 Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ]) Polyline \u00b6 Polyline ( self , name = 'polyline' , height = 1 , points = []) Sphere \u00b6 Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo . simulation . Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters collision \u00b6 pcg_gazebo . simulation . properties . Collision : Return single sphere-shaped collision model. radius \u00b6 float : Radius of the sphere in meters visual \u00b6 pcg_gazebo . simulation . properties . Visual : Return single sphere-shaped visual model. to_sdf \u00b6 Sphere . to_sdf ( self , type = 'model' , name = 'sphere' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance. add_inertial \u00b6 Sphere . add_inertial ( self , mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one update_inertial \u00b6 Sphere . update_inertial ( self , mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms update_collision \u00b6 Sphere . update_collision ( self ) Update collision model according to the current radius . update_visual \u00b6 Sphere . update_visual ( self ) Update visual model according to the current radius . World \u00b6 World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [ 0 , 0 , - 9 . 8 ] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody . engine \u00b6 str : Name identififier of the physics engine gravity \u00b6 list : Acceleration of gravity vector models \u00b6 dict : Models name \u00b6 str : Name of the world physics \u00b6 pcg_gazebo . simulation . physics . Physics : Physics engine instance reset_physics \u00b6 World . reset_physics ( self , engine = 'ode' ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody . reset_models \u00b6 World . reset_models ( self ) Reset the list of models. add_include \u00b6 World . add_include ( self , include ) Add a model via include method. Input arguments include ( type: pcg_gazebo . parsers . sdf . Include ): SDF < include > element Returns bool : True , if model directed by the include element could be parsed and added to the world. add_model \u00b6 World . add_model ( self , tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo . simulaton . SimulationModel ): Model object Returns bool : True , if model could be added to the world. rm_model \u00b6 World . rm_model ( self , tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world. model_exists \u00b6 World . model_exists ( self , tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise. add_plugin \u00b6 World . add_plugin ( self , tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo . parsers . sdf . Plugin or pcg_gazebo . simulation . properties . Plugin ): Plugin description. rm_plugin \u00b6 World . rm_plugin ( self , tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world. plugin_exists \u00b6 World . plugin_exists ( self , tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise. add_light \u00b6 World . add_light ( self , tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo . parsers . sdf . Light or pcg_gazebo . simulation . properties . Light ): Light description rm_light \u00b6 World . rm_light ( self , tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world. light_exists \u00b6 World . light_exists ( self , tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise. to_sdf \u00b6 World . to_sdf ( self , type = 'world' , with_default_ground_plane = True , with_default_sun = True ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo . parsers . sdf . SDF with a world element in it or pcg_gazebo . parsers . sdf . World . from_sdf \u00b6 World . from_sdf ( sdf ) Parse an pcg_gazebo . parsers . sdf . World into a c. Input arguments sdf ( type: pcg_gazebo . parsers . sdf . World ): SDF world element Returns pcg_gazebo . parsers . sdf . World instance. create_scene \u00b6 World . create_scene ( self , mesh_type = 'collision' , add_pseudo_color = True ) Return a trimesh . Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color. plot_footprints \u00b6 World . plot_footprints ( self , fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib . pyplot . Figure or bokeh . plotting . Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib . pyplot . Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0 . 5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib . pyplot . Figure or bokeh . plotting . Figure .","title":"pcg_gazebo.simulation"},{"location":"python_api/pcg_gazebo.simulation/#pcg_gazebosimulation","text":"Simulation interface module, with abstraction classes for all relevant entities that form a simulation in Gazebo.","title":"pcg_gazebo.simulation"},{"location":"python_api/pcg_gazebo.simulation/#create_object","text":"create_object ( tag , ** kwargs ) Factory method for Link subclasses. Input arguments tag ( type: str ): Name identifier of the object class kwargs ( type: dict ): Input arguments for the object class Returns Link : Subclass instance.","title":"create_object"},{"location":"python_api/pcg_gazebo.simulation/#get_gazebo_model_folders","text":"get_gazebo_model_folders ( dir_path ) Return the paths to all Gazebo model folders under the directory dir_path . Input arguments dir_path ( type: str ): Path to the search directory. Returns dict : Gazebo model paths ordered according to the Gazebo model names.","title":"get_gazebo_model_folders"},{"location":"python_api/pcg_gazebo.simulation/#load_gazebo_models","text":"load_gazebo_models () Search for Gazebo models in the local .gazebo / models folder and in the ROS paths. Returns dict : Information of all Gazebo models found","title":"load_gazebo_models"},{"location":"python_api/pcg_gazebo.simulation/#get_gazebo_models","text":"get_gazebo_models () Return the information of all Gazebo models found in the local .gazebo / models folder and in the catkin workspace as a dictionary.","title":"get_gazebo_models"},{"location":"python_api/pcg_gazebo.simulation/#get_gazebo_model_names","text":"get_gazebo_model_names () Return the names of all Gazebo models that can be found is the local .gazebo / models folders and catkin workspace.","title":"get_gazebo_model_names"},{"location":"python_api/pcg_gazebo.simulation/#is_gazebo_model","text":"is_gazebo_model ( name ) Test if a model with the identifier name is a Gazebo model that is found in the resources path. Input arguments name ( type: str ): Name identifier of the model Returns True if name refers to a Gazebo model.","title":"is_gazebo_model"},{"location":"python_api/pcg_gazebo.simulation/#get_gazebo_model_path","text":"get_gazebo_model_path ( model_name ) Return the path of the Gazebo model. Input arguments model_name ( type: str ): Name of the Gazebo model Returns str : Path of the Gazebo model folder","title":"get_gazebo_model_path"},{"location":"python_api/pcg_gazebo.simulation/#get_gazebo_model_sdf","text":"get_gazebo_model_sdf ( model_name , sdf_file = 'model.sdf' ) Parse the Gazebo model's SDF file into a pcg_gazebo SDF instance. Input arguments model_name ( type: str ): Name of the Gazebo model. sdf_file ( type: str , default: model . sdf ): Name of the SDF file to be parsed. Returns pcg_gazebo . parsers . types . XMLBase instance as an SDF element.","title":"get_gazebo_model_sdf"},{"location":"python_api/pcg_gazebo.simulation/#box","text":"Box ( self , name = 'box' , size = [ 1 , 1 , 1 ]) Class derived from pcg_gazebo . simulation . Link to describe a box-shaped link or single-link model. Input arguments name ( type: str , default: box ): Name of the object size ( type: list , default: [ 1 , 1 , 1 ] ): Vector with width, length and height of the box,","title":"Box"},{"location":"python_api/pcg_gazebo.simulation/#collision","text":"pcg_gazebo . simulation . properties . Collision : Return single box-shaped collision model.","title":"collision"},{"location":"python_api/pcg_gazebo.simulation/#size","text":"List of float : Size of the box as [ width , length , height ]","title":"size"},{"location":"python_api/pcg_gazebo.simulation/#visual","text":"pcg_gazebo . simulation . properties . Visual : Return single box-shaped visual model.","title":"visual"},{"location":"python_api/pcg_gazebo.simulation/#to_sdf","text":"Box . to_sdf ( self , type = 'model' , name = 'box' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input box : SDF box element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance.","title":"to_sdf"},{"location":"python_api/pcg_gazebo.simulation/#add_inertial","text":"Box . add_inertial ( self , mass ) Initialize mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms","title":"add_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_inertial","text":"Box . update_inertial ( self , mass = None ) Update mass and moments of inertia for box model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_collision","text":"Box . update_collision ( self ) Update collision model according to the current size .","title":"update_collision"},{"location":"python_api/pcg_gazebo.simulation/#update_visual","text":"Box . update_visual ( self ) Update visual model according to the current size .","title":"update_visual"},{"location":"python_api/pcg_gazebo.simulation/#cylinder","text":"Cylinder ( self , name = 'cylinder' , length = 1 , radius = 1 ) Class derived from pcg_gazebo . simulation . Link to describe a cylinder-shaped link or single-link model. Input arguments name ( type: str , default: cylinder ): Name of the object. length ( type: float , default: 1 ): Length of the cylinder in meters. radius ( type: float , default: 1 ): Radius of the cylinder in meters.","title":"Cylinder"},{"location":"python_api/pcg_gazebo.simulation/#collision_1","text":"pcg_gazebo . simulation . properties . Collision : Return single cylinder-shaped collision model.","title":"collision"},{"location":"python_api/pcg_gazebo.simulation/#length","text":"float : Length of the cylinder in meters","title":"length"},{"location":"python_api/pcg_gazebo.simulation/#radius","text":"float : Radius of the cylinder in meters","title":"radius"},{"location":"python_api/pcg_gazebo.simulation/#visual_1","text":"pcg_gazebo . simulation . properties . Visual : Return single cylinder-shaped visual model.","title":"visual"},{"location":"python_api/pcg_gazebo.simulation/#to_sdf_1","text":"Cylinder . to_sdf ( self , type = 'model' , name = 'cylinder' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input cylinder : SDF cylinder element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance.","title":"to_sdf"},{"location":"python_api/pcg_gazebo.simulation/#update_inertial_1","text":"Cylinder . update_inertial ( self , mass = None ) Initialize mass and moments of inertia for cylinder model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_collision_1","text":"Cylinder . update_collision ( self ) Update collision model according to the current length and radius .","title":"update_collision"},{"location":"python_api/pcg_gazebo.simulation/#update_visual_1","text":"Cylinder . update_visual ( self ) Update visual model according to the current length and radius .","title":"update_visual"},{"location":"python_api/pcg_gazebo.simulation/#joint","text":"Joint ( self , name = 'joint' , parent = None , child = None , joint_type = 'fixed' , axis_xyz = [ 0 , 0 , 1 ], damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 , lower =- 1e+16 , upper = 1e+16 , velocity =- 1 , effort =- 1 )","title":"Joint"},{"location":"python_api/pcg_gazebo.simulation/#light","text":"Light ( self , name = 'default' , type = 'point' )","title":"Light"},{"location":"python_api/pcg_gazebo.simulation/#simulationmodel","text":"SimulationModel ( self , name = 'model' , parent = 'world' , creation_time = None , life_timeout = None , is_ground_plane = False )","title":"SimulationModel"},{"location":"python_api/pcg_gazebo.simulation/#link","text":"Link ( self , name = 'object' , creation_time = None , life_timeout = None , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], inertial = None , static = False , self_collide = False , kinematic = False , visuals = None , collisions = None ) Representation of a simulated link or a single-link model . Input arguments name ( type: str , value: object ): Name of the object. creation_time ( type: float , default: None ): Timestamp of the creation of the object in Gazebo. life_timeout ( type: float , default: None ): Timeout in which to remove the object from the simulation ( not implemented ).","title":"Link"},{"location":"python_api/pcg_gazebo.simulation/#collisions","text":"List of pcg_gazebo . simulation . properties . Collision : List of collision models","title":"collisions"},{"location":"python_api/pcg_gazebo.simulation/#creation_time","text":"float : Time of creation of this object, if it represents a single-link model.","title":"creation_time"},{"location":"python_api/pcg_gazebo.simulation/#inertial","text":"pcg_gazebo . simulation . properties . Inertial : Description of the object's moments of inertia.","title":"inertial"},{"location":"python_api/pcg_gazebo.simulation/#kinematic","text":"bool : Flag to indicate if the model is purely kinematic","title":"kinematic"},{"location":"python_api/pcg_gazebo.simulation/#life_timeout","text":"float : Life timeout timestamp for this object, if it represents a single-link model","title":"life_timeout"},{"location":"python_api/pcg_gazebo.simulation/#name","text":"str : Object name","title":"name"},{"location":"python_api/pcg_gazebo.simulation/#pose","text":"pcg_gazebo . simulation . properties . Pose : Pose of the object","title":"pose"},{"location":"python_api/pcg_gazebo.simulation/#self_collide","text":"bool : Self-collision flag","title":"self_collide"},{"location":"python_api/pcg_gazebo.simulation/#static","text":"bool : Flag to indicate if object is static","title":"static"},{"location":"python_api/pcg_gazebo.simulation/#visuals","text":"List of pcg_gazebo . simulation . properties . Visual : List of visual models","title":"visuals"},{"location":"python_api/pcg_gazebo.simulation/#create_link_from_mesh","text":"Link . create_link_from_mesh ( name = 'link' , visual_mesh_filename = None , collision_mesh_filename = None , use_approximated_collision = False , approximated_collision_model = 'box' , visual_mesh_scale = [ 1 , 1 , 1 ], collision_mesh_scale = [ 1 , 1 , 1 ], pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], color = None , mass = 0 , inertia = None , use_approximated_inertia = True , approximated_inertia_model = 'box' ) Factory method to build a link or single-link model from a mesh. This method allows not only assigning a mesh as a visual and collision geometry, but also using geometrical approximations of the input mesh to create, for example, a collision mesh, or computing the moments of inertia. Input arguments name ( type: str , default: link ): Name of the link. visual_mesh_filename ( type: str , default: None ): Filename to the visual mesh file. collision_mesh_filename ( type: str , default: None ): Filename to the collision mesh file. If the input is None and use_approximated_collision is False , the visual mesh will be also set as collision mesh. use_approximated_collision ( type: bool , default: False ): If True , the collision geometry will be approximated from the visual mesh geometry into a model given by the approximated_collision_model input. approximated_collision_model ( type: str , default: box ): Name of the geometry to which the visual geometry will be approximated to generated the collision mesh, options are box , cylinder or sphere . visual_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling factors for the visual mesh in X, Y and Z directions. collision_mesh_scale ( type: list , default: [ 1 , 1 , 1 ] ): Scaling factors for the collision mesh in X, Y and Z directions. pose ( type: list , default: [ 0 , 0 , 0 , 0 , 0 , 0 ] ): Link's pose with respect to the model frame. color ( type: list or str , default: None ): Color set to the visual mesh. If None is provided, no color is set and the mesh will inherit the material of the mesh file. If the input is random , a random RGB color is generated. This input can also be set as xkcd for a random xkcd color name, or a string with the name of a specific xkcd color (e.g., teal ). Otherwise, the input can be an RGB vector as a list . mass ( type: float , default: 0 ): Mass of the link in kilograms. If the mass is not greater than zero, the link will be set as static. inertia ( type: dict , default: None ): Moments of inertia of the link. This input can be either a dictionary defined as dict ( ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) or None . If None is provided, use_approximated_inertia is True and mass is greater than zero, the moments of inertia will be computed from an approximated visual mesh geometry given by the input approximated_inertia_model . use_approximated_inertia ( type: bool , default: True ): If True and mass is greater tha zero, the moments of inertia of the link will be computed from a approximated visual mesh model described by approximated_inertia_model . approximated_inertia_model ( type: str , default: box ): Type of geometry approximation to be applied to the visual geometry. The dimensions of the geometry will then be used to compute the moments of inertia. Options are box , cylinder or sphere . Returns pcg_gazebo . simulation . Link instance.","title":"create_link_from_mesh"},{"location":"python_api/pcg_gazebo.simulation/#enable_collision","text":"Link . enable_collision ( self ) Enable the inclusion of the collision models in the exported SDF description.","title":"enable_collision"},{"location":"python_api/pcg_gazebo.simulation/#disable_collision","text":"Link . disable_collision ( self ) Disable the inclusion of the collision models in the exported SDF description.","title":"disable_collision"},{"location":"python_api/pcg_gazebo.simulation/#enable_visual","text":"Link . enable_visual ( self ) Enable the inclusion of the visual models in the exported SDF description.","title":"enable_visual"},{"location":"python_api/pcg_gazebo.simulation/#disable_visual","text":"Link . disable_visual ( self ) Disable the inclusion of the collision models in the exported SDF description.","title":"disable_visual"},{"location":"python_api/pcg_gazebo.simulation/#get_collision_by_name","text":"Link . get_collision_by_name ( self , name ) Return the collision model associated with the input name identifier. Input arguments name ( type: str ): Name of the collision model. Returns pcg_gazebo . simulation . properties . Collision , or None if not collision with the given name is found.","title":"get_collision_by_name"},{"location":"python_api/pcg_gazebo.simulation/#has_collision","text":"Link . has_collision ( self , name ) Test if a collision with the input name exists. Input arguments name ( type: str ): Name of the collision model Returns bool : True , if a collision model exists, `False, otherwise.","title":"has_collision"},{"location":"python_api/pcg_gazebo.simulation/#get_visual_by_name","text":"Link . get_visual_by_name ( self , name ) Return the visual model associated with the input name identifier. Input arguments name ( type: str ): Name of the visual model. Returns pcg_gazebo . simulation . properties . Visual , or None if not visual with the given name is found.","title":"get_visual_by_name"},{"location":"python_api/pcg_gazebo.simulation/#has_visual","text":"Link . has_visual ( self , name ) Test if a visual with the input name exists. Input arguments name ( type: str ): Name of the visual model Returns bool : True , if a visual model exists, `False, otherwise.","title":"has_visual"},{"location":"python_api/pcg_gazebo.simulation/#add_empty_visual","text":"Link . add_empty_visual ( self , name = 'visual' ) Create an empty visual model and add it to the object. Input arguments name ( type: str , default: visual ): Name of the visual model. Returns bool : True if visual model could be created and added to the object. False if another visual with the same name already exists.","title":"add_empty_visual"},{"location":"python_api/pcg_gazebo.simulation/#add_visual","text":"Link . add_visual ( self , visual ) Add visual model to the object. If a visual element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments visual ( type: pcg_gazebo . simulation . properties . Visual ): Visual element Returns bool : True , if visual element could be added to object.","title":"add_visual"},{"location":"python_api/pcg_gazebo.simulation/#add_empty_collision","text":"Link . add_empty_collision ( self , name = 'collision' ) Create an empty collision model and add it to the object. Input arguments name ( type: str , default: collision ): Name of the collision model. Returns bool : True if collision model could be created and added to the object. False if another collision with the same name already exists.","title":"add_empty_collision"},{"location":"python_api/pcg_gazebo.simulation/#add_collision","text":"Link . add_collision ( self , collision ) Add collision model to the object. If a collision element with the same name already exists, a suffix will be added to the name in the format _i , i being an integer. Input arguments collision ( type: pcg_gazebo . simulation . properties . Collision ): Collision element Returns bool : True , if collision element could be added to object.","title":"add_collision"},{"location":"python_api/pcg_gazebo.simulation/#to_sdf_2","text":"Link . to_sdf ( self , type = 'link' , name = 'model' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance.","title":"to_sdf"},{"location":"python_api/pcg_gazebo.simulation/#from_sdf","text":"Link . from_sdf ( sdf ) Factory method to generate a pcg_gazebo . simulation . Link instance from an SDF instance. Only links can be parsed. Input arguments sdf ( type: pcg_gazebo . parsers . sdf . Link ): SDF object Returns pcg_gazebo . simulation . Link : Simulation object instance","title":"from_sdf"},{"location":"python_api/pcg_gazebo.simulation/#export_to_gazebo_model","text":"Link . export_to_gazebo_model ( self , output_dir , name = 'model' , sdf_version = '1.6' , version = '0.1.0' , author_names = None , author_emails = None , description = '' , generate_sdf_with_version = False ) Export the object as a Gazebo model, in the format model_dir / model . sdf model . config Input arguments output_dir ( type: str ): Name of the directory where the model directory will be stored. name ( type: str , default: model ): Name of the model sdf_version ( type: str , default: 1 . 6 ): Version of the SDF format version ( type: str , default: 0 . 1 . 0 ): Gazebo model version author_names ( type: list , default: None ): List of authors author_emails ( type: list , default: None ): List of e-mails description ( type: str ): Model description generate_sdf_with_version ( type: bool , default: False ): Parameter description Returns bool : True , if Gazebo model files were exported successfully.","title":"export_to_gazebo_model"},{"location":"python_api/pcg_gazebo.simulation/#add_inertial_1","text":"Link . add_inertial ( self , mass ) This function must be implemented by derived classes.","title":"add_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_inertial_2","text":"Link . update_inertial ( self ) This function must be implemented by derived classes.","title":"update_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_collision_2","text":"Link . update_collision ( self ) This function must be implemented by derived classes.","title":"update_collision"},{"location":"python_api/pcg_gazebo.simulation/#update_visual_2","text":"Link . update_visual ( self ) This function must be implemented by derived classes.","title":"update_visual"},{"location":"python_api/pcg_gazebo.simulation/#add_sensor","text":"Link . add_sensor ( self , name , sensor ) Add sensor associated to the link. Input arguments name ( type: str ): Name of the sensor sensor ( type: pcg_gazebo . simulation . sensors . Sensor ): Sensor description Returns bool : True , if sensor could be added to link.","title":"add_sensor"},{"location":"python_api/pcg_gazebo.simulation/#to_markers","text":"Link . to_markers ( self ) Generate visualization_msgs / Marker instances from the visual and/or collision entities. Returns visualization_msgs / MarkerArray","title":"to_markers"},{"location":"python_api/pcg_gazebo.simulation/#get_footprint","text":"Link . get_footprint ( self , mesh_type = 'collision' , pose_offset = None , use_bounding_box = False , z_limits = None ) Returns the shapely . _GEOMETRIES . Polygon or shapely . _GEOMETRIES . MultiPolygon that represent the projection of the visual or collision meshes on the XY plane. Input arguments mesh_type ( type: str , default: collision ): Origin of the meshes, options are visual or collision . pose_offset ( type: data_type , default: None ): Pose offset to be applied to all meshes before the footprint is computed use_bounding_box ( type: bool , default: False ): Use the mesh's bounding box for the footprint calculation z_limits ( type: list , default: None ): Minimum and maximum limits in the Z direction were the meshes will be sectioned. Returns shapely . _GEOMETRIES . Polygon or shapely . _GEOMETRIES . MultiPolygon","title":"get_footprint"},{"location":"python_api/pcg_gazebo.simulation/#get_meshes","text":"Link . get_meshes ( self , mesh_type = 'collision' , pose_offset = None ) Return all the meshes associated with this link. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be returned, options are visual or collision . pose_offset ( type: list , default: None ): Pose offset to be applied to all meshes. Returns List of trimesh meshes.","title":"get_meshes"},{"location":"python_api/pcg_gazebo.simulation/#get_bounds","text":"Link . get_bounds ( self , mesh_type = 'collision' ) Return the bounds of the link with respect to its meshes. Input arguments mesh_type ( type: str , default: collision ): Type of mesh, options are visual or collision . Returns dict : Meshes' bounds","title":"get_bounds"},{"location":"python_api/pcg_gazebo.simulation/#plane","text":"Plane ( self , name = 'plane' , normal = [ 0 , 0 , 1 ], size = [ 1 , 1 ])","title":"Plane"},{"location":"python_api/pcg_gazebo.simulation/#polyline","text":"Polyline ( self , name = 'polyline' , height = 1 , points = [])","title":"Polyline"},{"location":"python_api/pcg_gazebo.simulation/#sphere","text":"Sphere ( self , name = 'sphere' , radius = 1 ) Class derived from pcg_gazebo . simulation . Link to describe a sphere-shaped link or single-link model. Input arguments name ( type: str , default: sphere ): Name of the object radius ( type: float , default: 1 ): Radius of the sphere in meters","title":"Sphere"},{"location":"python_api/pcg_gazebo.simulation/#collision_2","text":"pcg_gazebo . simulation . properties . Collision : Return single sphere-shaped collision model.","title":"collision"},{"location":"python_api/pcg_gazebo.simulation/#radius_1","text":"float : Radius of the sphere in meters","title":"radius"},{"location":"python_api/pcg_gazebo.simulation/#visual_2","text":"pcg_gazebo . simulation . properties . Visual : Return single sphere-shaped visual model.","title":"visual"},{"location":"python_api/pcg_gazebo.simulation/#to_sdf_3","text":"Sphere . to_sdf ( self , type = 'model' , name = 'sphere' , sdf_version = '1.6' ) Convert object to an SDF element. The object can be converted to different SDF elements according to the type input sphere : SDF sphere element geometry : SDF geometry element with nested element collision : SDF collision element visual : SDF visual element link : SDF link element with collision and visual properties model : single-link SDF model element sdf : SDF file format with a nested model element. Input arguments type ( type: str ): Type of output SDF element, options are collision , visual , link , model , sdf . name ( type: str , default: model ): Name of the output object sdf_version ( type: str , default: 1 . 6 ): Version of the output SDF element Returns pcg_gazebo . parsers . types . XMLBase : SDF element instance.","title":"to_sdf"},{"location":"python_api/pcg_gazebo.simulation/#add_inertial_2","text":"Sphere . add_inertial ( self , mass , hollow = False ) Initialize mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms hollow ( type: bool , default: False ): Compute moments of inertia for a hollow sphere, instead of a solid one","title":"add_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_inertial_3","text":"Sphere . update_inertial ( self , mass = None ) Update mass and moments of inertia for sphere model. Input arguments mass ( type: float ): Mass in kilograms","title":"update_inertial"},{"location":"python_api/pcg_gazebo.simulation/#update_collision_3","text":"Sphere . update_collision ( self ) Update collision model according to the current radius .","title":"update_collision"},{"location":"python_api/pcg_gazebo.simulation/#update_visual_3","text":"Sphere . update_visual ( self ) Update visual model according to the current radius .","title":"update_visual"},{"location":"python_api/pcg_gazebo.simulation/#world","text":"World ( self , name = 'default' , gravity = [ 0 , 0 , - 9.8 ], engine = 'ode' ) Abstraction of Gazebo's world description. This class contains the settings configuring the world's physics engine models lights plugins gravity and can be later exported into a .world file that Gazebo can parse and execute. Input arguments name ( type: str , value: default ): Name of the world. gravity ( type: list , default: [ 0 , 0 , - 9 . 8 ] ): Acceleration of gravity vector. engine ( type: str , default: ode ): Name of the default physics engine, options are ode , bullet or simbody .","title":"World"},{"location":"python_api/pcg_gazebo.simulation/#engine","text":"str : Name identififier of the physics engine","title":"engine"},{"location":"python_api/pcg_gazebo.simulation/#gravity","text":"list : Acceleration of gravity vector","title":"gravity"},{"location":"python_api/pcg_gazebo.simulation/#models","text":"dict : Models","title":"models"},{"location":"python_api/pcg_gazebo.simulation/#name_1","text":"str : Name of the world","title":"name"},{"location":"python_api/pcg_gazebo.simulation/#physics","text":"pcg_gazebo . simulation . physics . Physics : Physics engine instance","title":"physics"},{"location":"python_api/pcg_gazebo.simulation/#reset_physics","text":"World . reset_physics ( self , engine = 'ode' ) Reset the physics engine to its default configuration. Input arguments engine ( type: str , default: ode ): Name identifier of the physics engine, options are ode , bullet or simbody .","title":"reset_physics"},{"location":"python_api/pcg_gazebo.simulation/#reset_models","text":"World . reset_models ( self ) Reset the list of models.","title":"reset_models"},{"location":"python_api/pcg_gazebo.simulation/#add_include","text":"World . add_include ( self , include ) Add a model via include method. Input arguments include ( type: pcg_gazebo . parsers . sdf . Include ): SDF < include > element Returns bool : True , if model directed by the include element could be parsed and added to the world.","title":"add_include"},{"location":"python_api/pcg_gazebo.simulation/#add_model","text":"World . add_model ( self , tag , model ) Add a model to the world. Input arguments tag ( type: str ): Model's local name in the world. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. model ( type: pcg_gazebo . simulaton . SimulationModel ): Model object Returns bool : True , if model could be added to the world.","title":"add_model"},{"location":"python_api/pcg_gazebo.simulation/#rm_model","text":"World . rm_model ( self , tag ) Remove model from world. Input arguments tag ( type: str ): Local name identifier of the model to be removed. Returns bool : True , if model could be removed, False if no model with name tag could be found in the world.","title":"rm_model"},{"location":"python_api/pcg_gazebo.simulation/#model_exists","text":"World . model_exists ( self , tag ) Test if a model with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the model. Returns bool : True , if model exists, False , otherwise.","title":"model_exists"},{"location":"python_api/pcg_gazebo.simulation/#add_plugin","text":"World . add_plugin ( self , tag , plugin ) Add plugin description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. plugin ( type: pcg_gazebo . parsers . sdf . Plugin or pcg_gazebo . simulation . properties . Plugin ): Plugin description.","title":"add_plugin"},{"location":"python_api/pcg_gazebo.simulation/#rm_plugin","text":"World . rm_plugin ( self , tag ) Remove plugin from world. Input arguments tag ( type: str ): Local name identifier of the plugin to be removed. Returns bool : True , if plugin could be removed, False if no plugin with name tag could be found in the world.","title":"rm_plugin"},{"location":"python_api/pcg_gazebo.simulation/#plugin_exists","text":"World . plugin_exists ( self , tag ) Test if a plugin with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the plugin. Returns bool : True , if plugin exists, False , otherwise.","title":"plugin_exists"},{"location":"python_api/pcg_gazebo.simulation/#add_light","text":"World . add_light ( self , tag , light ) Add light description to the world. Input arguments tag ( type: str ): Name identifier for the plugin. If a model with the same name already exists, the model will be created with a counter suffix in the format _i , i being an integer. light ( type: pcg_gazebo . parsers . sdf . Light or pcg_gazebo . simulation . properties . Light ): Light description","title":"add_light"},{"location":"python_api/pcg_gazebo.simulation/#rm_light","text":"World . rm_light ( self , tag ) Remove light from world. Input arguments tag ( type: str ): Local name identifier of the light to be removed. Returns bool : True , if light could be removed, False if no light with name tag could be found in the world.","title":"rm_light"},{"location":"python_api/pcg_gazebo.simulation/#light_exists","text":"World . light_exists ( self , tag ) Test if a light with name tag exists in the world description. Input arguments tag ( type: str ): Local name identifier of the light. Returns bool : True , if light exists, False , otherwise.","title":"light_exists"},{"location":"python_api/pcg_gazebo.simulation/#to_sdf_4","text":"World . to_sdf ( self , type = 'world' , with_default_ground_plane = True , with_default_sun = True ) Convert the world description into as pcg_gazebo SDF element. Input arguments type ( type: str , default: world ): Type of output SDF element to be generated, options are world or sdf . It is important to note that to export the world description into a file, it is necessary to have the sdf format. with_default_ground_plane ( type: bool , default: True ): Add Gazebo's default ground plane model to the world. with_default_sun ( type: bool , default: True ): Add Gazebo's default sun model to the world. Returns pcg_gazebo . parsers . sdf . SDF with a world element in it or pcg_gazebo . parsers . sdf . World .","title":"to_sdf"},{"location":"python_api/pcg_gazebo.simulation/#from_sdf_1","text":"World . from_sdf ( sdf ) Parse an pcg_gazebo . parsers . sdf . World into a c. Input arguments sdf ( type: pcg_gazebo . parsers . sdf . World ): SDF world element Returns pcg_gazebo . parsers . sdf . World instance.","title":"from_sdf"},{"location":"python_api/pcg_gazebo.simulation/#create_scene","text":"World . create_scene ( self , mesh_type = 'collision' , add_pseudo_color = True ) Return a trimesh . Scene with all the world's models. Input arguments mesh_type ( type: str , default: collision ): Type of mesh to be included in the scene, options are collision or visual . add_pseudo_color ( type: bool , default: True ): If True , set each mesh with a pseudo-color.","title":"create_scene"},{"location":"python_api/pcg_gazebo.simulation/#plot_footprints","text":"World . plot_footprints ( self , fig = None , ax = None , fig_width = 20 , fig_height = 20 , mesh_type = 'collision' , z_limits = None , colormap = 'magma' , grid = True , ignore_ground_plane = True , line_width = 1 , line_style = 'solid' , alpha = 0.5 , engine = 'matplotlib' , dpi = 200 ) Plot the mesh footprint projections on the XY plane. Input arguments fig ( type: matplotlib . pyplot . Figure or bokeh . plotting . Figure , default: None ): Figure object. If None is provided, the figure will be created. ax ( type: matplotlib . pyplot . Axes , default: None ): Axes object to add the plot. If None is provided, the axes object will be created. fig_width ( type: float or int , default: 20 ): Width of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . fig_height ( type: float or int , default: 20 ): Height of the figure in inches, if engine is matplotlib , or pixels, if engine is bokeh . mesh_type ( type: str , default: collision ): Type of mesh to consider for the footprint computation, options are collision and visual . z_limits ( type: list , default: None ): List of minimum and maximum Z-levels to consider when sectioning the meshes. colormap ( type: str , default: magma ): Name of the colormap to be used. Check this link for matplotlib colormaps and this link for bokeh colormaps. grid ( type: bool , default: True ): If True , add grid to the plot. ignore_ground_plane ( type: bool , default: True ): Ignore the models flagged as ground plane from the plot. line_width ( type: float , default: 1 ): Width of the line of each footprint polygon patch. line_style ( type: str , default: solid ): Style of the line of each footprint polygon patch. Check this link to see all the line style options. alpha ( type: float , default: 0 . 5 ): Alpha channel value for the footprint objects. engine ( type: str , default: matplotlib ): Engine to use for the generation of the figure, options are bokeh and matplotlib . dpi ( type: int , default: 200 ): Image's DPI Returns matplotlib . pyplot . Figure or bokeh . plotting . Figure .","title":"plot_footprints"},{"location":"python_api/pcg_gazebo.simulation.physics/","text":"pcg_gazebo.simulation.physics \u00b6 Physics \u00b6 Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False ) Bullet \u00b6 Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = True , split_impulse_penetration_threshold =- 0.01 ) ODE \u00b6 ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_scaling = False , friction_model = 'pyramid_model' , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , contact_max_correcting_vel = 100 ) Simbody \u00b6 Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 0.5 , static_friction = 0.9 , dynamic_friction = 0.9 , viscous_friction = 0.9 , override_impact_capture_velocity = 0.001 , override_stiction_transition_velocity = 0.001 )","title":"pcg_gazebo.simulation.physics"},{"location":"python_api/pcg_gazebo.simulation.physics/#pcg_gazebosimulationphysics","text":"","title":"pcg_gazebo.simulation.physics"},{"location":"python_api/pcg_gazebo.simulation.physics/#physics","text":"Physics ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , engine = 'ode' , name = 'default_physics' , default = False )","title":"Physics"},{"location":"python_api/pcg_gazebo.simulation.physics/#bullet","text":"Bullet ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , split_impulse = True , split_impulse_penetration_threshold =- 0.01 )","title":"Bullet"},{"location":"python_api/pcg_gazebo.simulation.physics/#ode","text":"ODE ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , iters = 50 , sor = 1.3 , type = 'quick' , precon_iters = 0 , use_dynamic_moi_scaling = False , friction_model = 'pyramid_model' , cfm = 0 , erp = 0.2 , contact_surface_layer = 0.001 , contact_max_correcting_vel = 100 )","title":"ODE"},{"location":"python_api/pcg_gazebo.simulation.physics/#simbody","text":"Simbody ( self , max_step_size = 0.001 , real_time_factor = 1 , real_time_update_rate = 1000 , max_contacts = 20 , min_step_size = 0.0001 , accuracy = 0.001 , max_transient_velocity = 0.01 , stiffness = 100000000.0 , dissipation = 100 , plastic_coef_restitution = 0.5 , plastic_impact_velocity = 0.5 , static_friction = 0.9 , dynamic_friction = 0.9 , viscous_friction = 0.9 , override_impact_capture_velocity = 0.001 , override_stiction_transition_velocity = 0.001 )","title":"Simbody"},{"location":"python_api/pcg_gazebo.simulation.properties/","text":"pcg_gazebo.simulation.properties \u00b6 Axis \u00b6 Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit = 0 , effort_limit = 0 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 ) BoundingBox \u00b6 BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ]) Collision \u00b6 Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = 1.0 , mu2 = 1.0 , slip1 = 0 , slip2 = 0 , rolling_friction = 1 , fdir1 = [ 0 , 0 , 0 ], max_contacts = 10 , soft_cfm = 0 , soft_erp = 0.2 , kp = 1000000000000.0 , kd = 1 , max_vel = 0.01 , min_depth = 0 , split_impulse = 1 , split_impulse_penetration_threshold =- 0.01 , enable_friction = False , enable_bounce = False , enable_contact = False ) Footprint \u00b6 Footprint ( self ) Geometry \u00b6 Geometry ( self , geo_type = None , ** kwargs ) Inertial \u00b6 Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 ) Material \u00b6 Material ( self ) Mesh \u00b6 Mesh ( self , filename = None , load_mesh = False ) Noise \u00b6 Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' ) Plugin \u00b6 Plugin ( self , name = None , filename = None ) Pose \u00b6 Pose ( self , pos = [ 0 , 0 , 0 ], rpy = None , quat = None ) Visual \u00b6 Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"pcg_gazebo.simulation.properties"},{"location":"python_api/pcg_gazebo.simulation.properties/#pcg_gazebosimulationproperties","text":"","title":"pcg_gazebo.simulation.properties"},{"location":"python_api/pcg_gazebo.simulation.properties/#axis","text":"Axis ( self , xyz = [ 0 , 0 , 1 ], lower_limit =- 1e+16 , upper_limit = 1e+16 , velocity_limit = 0 , effort_limit = 0 , damping = 0 , friction = 0 , spring_reference = 0 , spring_stiffness = 0 )","title":"Axis"},{"location":"python_api/pcg_gazebo.simulation.properties/#boundingbox","text":"BoundingBox ( self , min_corner = [ 0 , 0 , 0 ], max_corner = [ 0 , 0 , 0 ])","title":"BoundingBox"},{"location":"python_api/pcg_gazebo.simulation.properties/#collision","text":"Collision ( self , name = 'collision' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], geometry_type = None , geometry_args = None , mu = 1.0 , mu2 = 1.0 , slip1 = 0 , slip2 = 0 , rolling_friction = 1 , fdir1 = [ 0 , 0 , 0 ], max_contacts = 10 , soft_cfm = 0 , soft_erp = 0.2 , kp = 1000000000000.0 , kd = 1 , max_vel = 0.01 , min_depth = 0 , split_impulse = 1 , split_impulse_penetration_threshold =- 0.01 , enable_friction = False , enable_bounce = False , enable_contact = False )","title":"Collision"},{"location":"python_api/pcg_gazebo.simulation.properties/#footprint","text":"Footprint ( self )","title":"Footprint"},{"location":"python_api/pcg_gazebo.simulation.properties/#geometry","text":"Geometry ( self , geo_type = None , ** kwargs )","title":"Geometry"},{"location":"python_api/pcg_gazebo.simulation.properties/#inertial","text":"Inertial ( self , mass = 0 , ixx = 0 , iyy = 0 , izz = 0 , ixy = 0 , ixz = 0 , iyz = 0 )","title":"Inertial"},{"location":"python_api/pcg_gazebo.simulation.properties/#material","text":"Material ( self )","title":"Material"},{"location":"python_api/pcg_gazebo.simulation.properties/#mesh","text":"Mesh ( self , filename = None , load_mesh = False )","title":"Mesh"},{"location":"python_api/pcg_gazebo.simulation.properties/#noise","text":"Noise ( self , mean = 0 , stddev = 0 , bias_mean = 0 , bias_stddev = 0 , precision = 0 , type = 'none' )","title":"Noise"},{"location":"python_api/pcg_gazebo.simulation.properties/#plugin","text":"Plugin ( self , name = None , filename = None )","title":"Plugin"},{"location":"python_api/pcg_gazebo.simulation.properties/#pose","text":"Pose ( self , pos = [ 0 , 0 , 0 ], rpy = None , quat = None )","title":"Pose"},{"location":"python_api/pcg_gazebo.simulation.properties/#visual","text":"Visual ( self , name = 'visual' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], cast_shadows = True , transparency = 0 , geometry_type = None , geometry_args = None )","title":"Visual"},{"location":"python_api/pcg_gazebo.simulation.sensors/","text":"pcg_gazebo.simulation.sensors \u00b6 Sensor \u00b6 Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Camera \u00b6 Camera ( self , name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ]) Contact \u00b6 Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' ) IMU \u00b6 IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ]) Ray \u00b6 Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 )","title":"pcg_gazebo.simulation.sensors"},{"location":"python_api/pcg_gazebo.simulation.sensors/#pcg_gazebosimulationsensors","text":"","title":"pcg_gazebo.simulation.sensors"},{"location":"python_api/pcg_gazebo.simulation.sensors/#sensor","text":"Sensor ( self , name = 'sensor' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"Sensor"},{"location":"python_api/pcg_gazebo.simulation.sensors/#camera","text":"Camera ( self , name = 'camera' , always_on = True , update_rate = 50 , visualize = True , topic = 'camera' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], noise_type = 'gaussian' , noise_mean = 0 , noise_stddev = 0 , horizontal_fov = 1.047 , image_width = 320 , image_height = 240 , image_format = 'R8G8B8' , clip_near = 0.1 , clip_far = 100 , distortion_k1 = 0 , distortion_k2 = 0 , distortion_k3 = 0 , distortion_p1 = 0 , distortion_p2 = 0 , distortion_center = [ 0.5 , 0.5 ])","title":"Camera"},{"location":"python_api/pcg_gazebo.simulation.sensors/#contact","text":"Contact ( self , name = 'contact' , always_on = True , update_rate = 50 , visualize = True , topic = 'contact' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], collision_element_name = '' )","title":"Contact"},{"location":"python_api/pcg_gazebo.simulation.sensors/#imu","text":"IMU ( self , name = 'imu' , always_on = True , update_rate = 50 , visualize = False , topic = 'topic' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ])","title":"IMU"},{"location":"python_api/pcg_gazebo.simulation.sensors/#ray","text":"Ray ( self , name = 'ray' , always_on = True , update_rate = 50 , visualize = True , topic = 'scan' , pose = [ 0 , 0 , 0 , 0 , 0 , 0 ], horizontal_samples = 640 , horizontal_resolution = 1 , horizontal_min_angle = 0 , horizontal_max_angle = 0 , vertical_samples = 1 , vertical_resolution = 1 , vertical_min_angle = 0 , vertical_max_angle = 0 , range_min = 0 , range_max = 0 , range_resolution = 0 , noise_mean = 0 , noise_stddev = 0 )","title":"Ray"},{"location":"tutorials/parsers/sdf/","text":"The creation of the necessary SDF files to build a simulation requires the creation and editing for files in the SDF format , a specific format created to describe models and worlds in Gazebo. In order to allow the edition and creation of scenarios programatically, the SDF parser is the module that allows quick creation of all the necessary simulation entities with default parameters already provided. This modules can generate or parse SDF format files and allow the use of Python scripting for editing. This module was created according to the SDF format specification","title":"Introduction"},{"location":"tutorials/parsers/sdf/collisions/","text":"Collision \u00b6 The collision properties of a link. Note that this can be different from the visual properties of a link, for example, simpler collision models are often used to reduce computation time. This is a child element of < link > and a link can have multiple collisions. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The collision element is created with an empty geometry by default collision = create_sdf_element ( 'collision' ) print ( collision ) <collision name=\"collision\"> <geometry> <empty></empty> </geometry> </collision> # To see the optional elements, use the method reset() collision . reset ( with_optional_elements = True ) print ( collision ) <collision name=\"collision\"> <max_contacts>10</max_contacts> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <empty></empty> </geometry> <laser_retro>0</laser_retro> </collision> # Setting the parameters of a collision element # Maximum number of contacts allowed between two entities, this value # will override the max_contacts element defined in physics collision . max_contacts = 30 # Pose of the collision geometry with respect to a speficied frame collision . pose = [ 0 , 0 , 1 , 0 , 0 , 0 ] collision . pose . frame = 'base_link' print ( collision ) <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <empty></empty> </geometry> <laser_retro>0</laser_retro> </collision> # Setting different geometries to the collision element collision . geometry . box = create_sdf_element ( 'box' ) print ( collision ) collision . geometry . sphere = create_sdf_element ( 'sphere' ) print ( collision ) collision . geometry . cylinder = create_sdf_element ( 'cylinder' ) print ( collision ) collision . geometry . plane = create_sdf_element ( 'plane' ) print ( collision ) collision . geometry . mesh = create_sdf_element ( 'mesh' ) collision . geometry . mesh . reset ( with_optional_elements = True ) print ( collision ) collision . geometry . image = create_sdf_element ( 'image' ) print ( collision ) collision . geometry . polyline = create_sdf_element ( 'polyline' ) print ( collision ) <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <box> <size>0 0 0</size> </box> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <sphere> <radius>0</radius> </sphere> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <plane> <normal>0 0 1</normal> <size>0 0</size> </plane> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <mesh> <uri></uri> <scale>1 1 1</scale> <submesh> <name>none</name> <center>0</center> </submesh> </mesh> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <image> <threshold>0</threshold> <uri></uri> <scale>1</scale> <granularity>1</granularity> <height>1</height> </image> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <polyline> <height>1</height> </polyline> </geometry> <laser_retro>0</laser_retro> </collision> # Optional elements can also be created dynamically collision = create_sdf_element ( 'collision' ) print ( collision ) <collision name=\"collision\"> <geometry> <empty></empty> </geometry> </collision> collision . max_contacts = 40 print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <geometry> <empty></empty> </geometry> </collision> collision . pose = [ 0 , 0.2 , 0 , 0 , 0 , 0 ] collision . pose . frame = 'new_frame' print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <empty></empty> </geometry> </collision> # The geometry entity can be set with a dictionary with all the child parameters collision . geometry . box = dict ( size = [ 2 , 3 , 4 ]) print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> </collision> # The pose, as other variables, can be set using a dictionary # For SDF elements with no child elements, only values, the dictionary must always have a key 'value' # d = {value=[0, 0, 0, 0, 0, 0]} # If the element contains attributes, as the attribute 'frame' in the element 'pose', there should be a key # 'attributes' with a dictionary containing all the attributes # d = {value=[0, 0, 0, 0, 0, 0], attributes=dict(frame='new_frame')} collision . pose = { 'value' : [ 0 , 0.2 , 0 , 0 , 0 , 0 ], 'attributes' : { 'frame' : 'new_frame' }} print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> </collision>","title":"Collisions"},{"location":"tutorials/parsers/sdf/collisions/#collision","text":"The collision properties of a link. Note that this can be different from the visual properties of a link, for example, simpler collision models are often used to reduce computation time. This is a child element of < link > and a link can have multiple collisions. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The collision element is created with an empty geometry by default collision = create_sdf_element ( 'collision' ) print ( collision ) <collision name=\"collision\"> <geometry> <empty></empty> </geometry> </collision> # To see the optional elements, use the method reset() collision . reset ( with_optional_elements = True ) print ( collision ) <collision name=\"collision\"> <max_contacts>10</max_contacts> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <empty></empty> </geometry> <laser_retro>0</laser_retro> </collision> # Setting the parameters of a collision element # Maximum number of contacts allowed between two entities, this value # will override the max_contacts element defined in physics collision . max_contacts = 30 # Pose of the collision geometry with respect to a speficied frame collision . pose = [ 0 , 0 , 1 , 0 , 0 , 0 ] collision . pose . frame = 'base_link' print ( collision ) <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <empty></empty> </geometry> <laser_retro>0</laser_retro> </collision> # Setting different geometries to the collision element collision . geometry . box = create_sdf_element ( 'box' ) print ( collision ) collision . geometry . sphere = create_sdf_element ( 'sphere' ) print ( collision ) collision . geometry . cylinder = create_sdf_element ( 'cylinder' ) print ( collision ) collision . geometry . plane = create_sdf_element ( 'plane' ) print ( collision ) collision . geometry . mesh = create_sdf_element ( 'mesh' ) collision . geometry . mesh . reset ( with_optional_elements = True ) print ( collision ) collision . geometry . image = create_sdf_element ( 'image' ) print ( collision ) collision . geometry . polyline = create_sdf_element ( 'polyline' ) print ( collision ) <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <box> <size>0 0 0</size> </box> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <sphere> <radius>0</radius> </sphere> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <plane> <normal>0 0 1</normal> <size>0 0</size> </plane> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <mesh> <uri></uri> <scale>1 1 1</scale> <submesh> <name>none</name> <center>0</center> </submesh> </mesh> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <image> <threshold>0</threshold> <uri></uri> <scale>1</scale> <granularity>1</granularity> <height>1</height> </image> </geometry> <laser_retro>0</laser_retro> </collision> <collision name=\"collision\"> <max_contacts>30</max_contacts> <pose frame=\"base_link\">0 0 1 0 0 0</pose> <surface> <bounce> <threshold>100000</threshold> <restitution_coefficient>0</restitution_coefficient> </bounce> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <friction> <torsional> <ode> <slip>0</slip> </ode> <surface_radius>0</surface_radius> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> <patch_radius>0</patch_radius> </torsional> <ode> <fdir1>0 0 0</fdir1> <mu>1</mu> <slip1>0</slip1> <slip2>0</slip2> <mu2>1</mu2> </ode> <bullet> <fdir1>0 0 0</fdir1> <rolling_friction>1</rolling_friction> <friction>1</friction> <friction2>1</friction2> </bullet> </friction> </surface> <contact> <ode> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <kd>1</kd> <min_depth>0</min_depth> <soft_cfm>0</soft_cfm> <max_vel>0.01</max_vel> </ode> <bullet> <kp>1000000000000.0</kp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <kd>1</kd> <split_impulse>1</split_impulse> <soft_cfm>0</soft_cfm> <soft_erp>0.2</soft_erp> </bullet> </contact> <geometry> <polyline> <height>1</height> </polyline> </geometry> <laser_retro>0</laser_retro> </collision> # Optional elements can also be created dynamically collision = create_sdf_element ( 'collision' ) print ( collision ) <collision name=\"collision\"> <geometry> <empty></empty> </geometry> </collision> collision . max_contacts = 40 print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <geometry> <empty></empty> </geometry> </collision> collision . pose = [ 0 , 0.2 , 0 , 0 , 0 , 0 ] collision . pose . frame = 'new_frame' print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <empty></empty> </geometry> </collision> # The geometry entity can be set with a dictionary with all the child parameters collision . geometry . box = dict ( size = [ 2 , 3 , 4 ]) print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> </collision> # The pose, as other variables, can be set using a dictionary # For SDF elements with no child elements, only values, the dictionary must always have a key 'value' # d = {value=[0, 0, 0, 0, 0, 0]} # If the element contains attributes, as the attribute 'frame' in the element 'pose', there should be a key # 'attributes' with a dictionary containing all the attributes # d = {value=[0, 0, 0, 0, 0, 0], attributes=dict(frame='new_frame')} collision . pose = { 'value' : [ 0 , 0.2 , 0 , 0 , 0 , 0 ], 'attributes' : { 'frame' : 'new_frame' }} print ( collision ) <collision name=\"collision\"> <max_contacts>40</max_contacts> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> </collision>","title":"Collision"},{"location":"tutorials/parsers/sdf/convert_from_sdf_file/","text":"Converting from SDF file \u00b6 import os from pcg_gazebo.parsers import parse_xml def download_sdf ( url , model_name ): output_sdf = '/tmp/{}.sdf' . format ( model_name ) os . system ( 'wget {} -O {}' . format ( url , output_sdf )) with open ( output_sdf , 'r' ) as f : for line in f : print ( line . replace ( ' \\n ' , '' )) return output_sdf Bookshelf \u00b6 url = 'https://bitbucket.org/osrf/gazebo_models/raw/9533d55593096e7ebdfb539e99d2bf9cb1bff347/bookshelf/model.sdf' obj = parse_xml ( download_sdf ( url , 'bookshelf' ), type = 'sdf' ) <?xml version=\"1.0\" ?> <sdf version=\"1.5\"> <model name=\"bookshelf\"> <static>true</static> <link name=\"link\"> <inertial> <mass>1.0</mass> </inertial> <collision name=\"back\"> <pose>0 0.005 0.6 0 0 0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> </collision> <visual name=\"visual1\"> <pose>0 0.005 0.6 0 0 0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"left_side\"> <pose>0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <visual name=\"visual2\"> <pose>0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"right_side\"> <pose>-0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <visual name=\"visual3\"> <pose>-0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"bottom\"> <pose>0 -0.195 0.03 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> </collision> <visual name=\"visual4\"> <pose>0 -0.195 0.03 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"top\"> <pose>0 -0.195 1.19 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <visual name=\"visual5\"> <pose>0 -0.195 1.19 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"low_shelf\"> <pose>0 -0.195 0.43 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <visual name=\"visual6\"> <pose>0 -0.195 0.43 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"high_shelf\"> <pose>0 -0.195 0.8 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <visual name=\"visual7\"> <pose>0 -0.195 0.8 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> </link> </model> </sdf> print ( obj ) <sdf version=\"1.5\"> <model name=\"bookshelf\"> <link name=\"link\"> <inertial> <mass>1.0</mass> <inertia> <ixz>0</ixz> <iyz>0</iyz> <iyy>0</iyy> <izz>0</izz> <ixx>0</ixx> <ixy>0</ixy> </inertia> <pose frame=\"\">0 0 0 0 0 0</pose> </inertial> <visual name=\"visual1\"> <pose frame=\"\">0.0 0.005 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual2\"> <pose frame=\"\">0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual3\"> <pose frame=\"\">-0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual4\"> <pose frame=\"\">0.0 -0.195 0.03 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual5\"> <pose frame=\"\">0.0 -0.195 1.19 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual6\"> <pose frame=\"\">0.0 -0.195 0.43 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual7\"> <pose frame=\"\">0.0 -0.195 0.8 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <collision name=\"back\"> <pose frame=\"\">0.0 0.005 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> </collision> <collision name=\"left_side\"> <pose frame=\"\">0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <collision name=\"right_side\"> <pose frame=\"\">-0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <collision name=\"bottom\"> <pose frame=\"\">0.0 -0.195 0.03 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> </collision> <collision name=\"top\"> <pose frame=\"\">0.0 -0.195 1.19 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <collision name=\"low_shelf\"> <pose frame=\"\">0.0 -0.195 0.43 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <collision name=\"high_shelf\"> <pose frame=\"\">0.0 -0.195 0.8 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> </link> <static>1</static> </model> </sdf> Beer can \u00b6 url = 'https://bitbucket.org/osrf/gazebo_models/raw/9533d55593096e7ebdfb539e99d2bf9cb1bff347/beer/model.sdf' obj = parse_xml ( download_sdf ( url , 'beer' ), type = 'sdf' ) <?xml version=\"1.0\" ?> <sdf version=\"1.5\"> <model name=\"beer\"> <link name=\"link\"> <pose>0 0 0.115 0 0 0</pose> <inertial> <mass>0.390</mass> <inertia> <ixx>0.00058</ixx> <ixy>0</ixy> <ixz>0</ixz> <iyy>0.00058</iyy> <iyz>0</iyz> <izz>0.00019</izz> </inertia> </inertial> <collision name=\"collision\"> <geometry> <cylinder> <radius>0.055000</radius> <length>0.230000</length> </cylinder> </geometry> </collision> <visual name=\"visual\"> <geometry> <cylinder> <radius>0.055000</radius> <length>0.230000</length> </cylinder> </geometry> <material> <script> <uri>model://beer/materials/scripts</uri> <uri>model://beer/materials/textures</uri> <name>Beer/Diffuse</name> </script> </material> </visual> </link> </model> </sdf> print ( obj ) <sdf version=\"1.5\"> <model name=\"beer\"> <link name=\"link\"> <pose frame=\"\">0.0 0.0 0.115 0.0 0.0 0.0</pose> <inertial> <mass>0.39</mass> <inertia> <ixz>0.0</ixz> <iyz>0.0</iyz> <iyy>0.00058</iyy> <izz>0.00019</izz> <ixx>0.00058</ixx> <ixy>0.0</ixy> </inertia> <pose frame=\"\">0 0 0 0 0 0</pose> </inertial> <visual name=\"visual\"> <geometry> <cylinder> <length>0.23</length> <radius>0.055</radius> </cylinder> </geometry> <material> <script> <name>Beer/Diffuse</name> <uri>model://beer/materials/scripts</uri> <uri>model://beer/materials/textures</uri> </script> </material> </visual> <collision name=\"collision\"> <geometry> <cylinder> <length>0.23</length> <radius>0.055</radius> </cylinder> </geometry> </collision> </link> </model> </sdf>","title":"Convert from SDF file"},{"location":"tutorials/parsers/sdf/convert_from_sdf_file/#converting-from-sdf-file","text":"import os from pcg_gazebo.parsers import parse_xml def download_sdf ( url , model_name ): output_sdf = '/tmp/{}.sdf' . format ( model_name ) os . system ( 'wget {} -O {}' . format ( url , output_sdf )) with open ( output_sdf , 'r' ) as f : for line in f : print ( line . replace ( ' \\n ' , '' )) return output_sdf","title":"Converting from SDF file"},{"location":"tutorials/parsers/sdf/convert_from_sdf_file/#bookshelf","text":"url = 'https://bitbucket.org/osrf/gazebo_models/raw/9533d55593096e7ebdfb539e99d2bf9cb1bff347/bookshelf/model.sdf' obj = parse_xml ( download_sdf ( url , 'bookshelf' ), type = 'sdf' ) <?xml version=\"1.0\" ?> <sdf version=\"1.5\"> <model name=\"bookshelf\"> <static>true</static> <link name=\"link\"> <inertial> <mass>1.0</mass> </inertial> <collision name=\"back\"> <pose>0 0.005 0.6 0 0 0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> </collision> <visual name=\"visual1\"> <pose>0 0.005 0.6 0 0 0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"left_side\"> <pose>0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <visual name=\"visual2\"> <pose>0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"right_side\"> <pose>-0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <visual name=\"visual3\"> <pose>-0.45 -0.195 0.6 0 0 0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"bottom\"> <pose>0 -0.195 0.03 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> </collision> <visual name=\"visual4\"> <pose>0 -0.195 0.03 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"top\"> <pose>0 -0.195 1.19 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <visual name=\"visual5\"> <pose>0 -0.195 1.19 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"low_shelf\"> <pose>0 -0.195 0.43 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <visual name=\"visual6\"> <pose>0 -0.195 0.43 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> <collision name=\"high_shelf\"> <pose>0 -0.195 0.8 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <visual name=\"visual7\"> <pose>0 -0.195 0.8 0 0 0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> </material> </visual> </link> </model> </sdf> print ( obj ) <sdf version=\"1.5\"> <model name=\"bookshelf\"> <link name=\"link\"> <inertial> <mass>1.0</mass> <inertia> <ixz>0</ixz> <iyz>0</iyz> <iyy>0</iyy> <izz>0</izz> <ixx>0</ixx> <ixy>0</ixy> </inertia> <pose frame=\"\">0 0 0 0 0 0</pose> </inertial> <visual name=\"visual1\"> <pose frame=\"\">0.0 0.005 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual2\"> <pose frame=\"\">0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual3\"> <pose frame=\"\">-0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual4\"> <pose frame=\"\">0.0 -0.195 0.03 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual5\"> <pose frame=\"\">0.0 -0.195 1.19 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual6\"> <pose frame=\"\">0.0 -0.195 0.43 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <visual name=\"visual7\"> <pose frame=\"\">0.0 -0.195 0.8 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> <material> <script> <name>Gazebo/Wood</name> <uri>file://media/materials/scripts/gazebo.material</uri> </script> </material> </visual> <collision name=\"back\"> <pose frame=\"\">0.0 0.005 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.9 0.01 1.2</size> </box> </geometry> </collision> <collision name=\"left_side\"> <pose frame=\"\">0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <collision name=\"right_side\"> <pose frame=\"\">-0.45 -0.195 0.6 0.0 0.0 0.0</pose> <geometry> <box> <size>0.02 0.4 1.2</size> </box> </geometry> </collision> <collision name=\"bottom\"> <pose frame=\"\">0.0 -0.195 0.03 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.06</size> </box> </geometry> </collision> <collision name=\"top\"> <pose frame=\"\">0.0 -0.195 1.19 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <collision name=\"low_shelf\"> <pose frame=\"\">0.0 -0.195 0.43 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> <collision name=\"high_shelf\"> <pose frame=\"\">0.0 -0.195 0.8 0.0 0.0 0.0</pose> <geometry> <box> <size>0.88 0.4 0.02</size> </box> </geometry> </collision> </link> <static>1</static> </model> </sdf>","title":"Bookshelf"},{"location":"tutorials/parsers/sdf/convert_from_sdf_file/#beer-can","text":"url = 'https://bitbucket.org/osrf/gazebo_models/raw/9533d55593096e7ebdfb539e99d2bf9cb1bff347/beer/model.sdf' obj = parse_xml ( download_sdf ( url , 'beer' ), type = 'sdf' ) <?xml version=\"1.0\" ?> <sdf version=\"1.5\"> <model name=\"beer\"> <link name=\"link\"> <pose>0 0 0.115 0 0 0</pose> <inertial> <mass>0.390</mass> <inertia> <ixx>0.00058</ixx> <ixy>0</ixy> <ixz>0</ixz> <iyy>0.00058</iyy> <iyz>0</iyz> <izz>0.00019</izz> </inertia> </inertial> <collision name=\"collision\"> <geometry> <cylinder> <radius>0.055000</radius> <length>0.230000</length> </cylinder> </geometry> </collision> <visual name=\"visual\"> <geometry> <cylinder> <radius>0.055000</radius> <length>0.230000</length> </cylinder> </geometry> <material> <script> <uri>model://beer/materials/scripts</uri> <uri>model://beer/materials/textures</uri> <name>Beer/Diffuse</name> </script> </material> </visual> </link> </model> </sdf> print ( obj ) <sdf version=\"1.5\"> <model name=\"beer\"> <link name=\"link\"> <pose frame=\"\">0.0 0.0 0.115 0.0 0.0 0.0</pose> <inertial> <mass>0.39</mass> <inertia> <ixz>0.0</ixz> <iyz>0.0</iyz> <iyy>0.00058</iyy> <izz>0.00019</izz> <ixx>0.00058</ixx> <ixy>0.0</ixy> </inertia> <pose frame=\"\">0 0 0 0 0 0</pose> </inertial> <visual name=\"visual\"> <geometry> <cylinder> <length>0.23</length> <radius>0.055</radius> </cylinder> </geometry> <material> <script> <name>Beer/Diffuse</name> <uri>model://beer/materials/scripts</uri> <uri>model://beer/materials/textures</uri> </script> </material> </visual> <collision name=\"collision\"> <geometry> <cylinder> <length>0.23</length> <radius>0.055</radius> </cylinder> </geometry> </collision> </link> </model> </sdf>","title":"Beer can"},{"location":"tutorials/parsers/sdf/geometries/","text":"Geometries \u00b6 Geometry entities are child elements of < visual > or < collision > elements. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element Basic entities \u00b6 Demonstration of the basic SDF elements that can be generated with and without the optional parameters. Geometries \u00b6 Box \u00b6 # Default box box = create_sdf_element ( 'box' ) print ( 'Default box' ) print ( box ) print ( 'Default box - as dict' ) print ( box . to_dict ()) print ( 'Default box - as SDF' ) print ( box . to_xml_as_str ()) # Changing the size box . size = [ 2 , 3 , 4 ] print ( 'Custom box' ) print ( box ) # Exporting # box.export_xml('/tmp/box.sdf') Default box <box> <size>0 0 0</size> </box> Default box - as dict {'box': {'size': {'value': [0, 0, 0]}}} Default box - as SDF <box><size>0 0 0</size></box> Custom box <box> <size>2 3 4</size> </box> Cylinder \u00b6 # Default cylinder cylinder = create_sdf_element ( 'cylinder' ) print ( 'Default cylinder' ) print ( cylinder ) print ( 'Default cylinder - as dict' ) print ( cylinder . to_dict ()) print ( 'Default cylinder - as SDF' ) print ( cylinder . to_xml_as_str ()) # Changing the parameters cylinder . radius = 2 cylinder . length = 3 print ( 'Custom cylinder' ) print ( cylinder ) # Exporting # cylinder.export_xml('/tmp/cylinder.sdf') Default cylinder <cylinder> <length>0</length> <radius>0</radius> </cylinder> Default cylinder - as dict {'cylinder': {'length': {'value': 0}, 'radius': {'value': 0}}} Default cylinder - as SDF <cylinder><length>0</length><radius>0</radius></cylinder> Custom cylinder <cylinder> <length>3.0</length> <radius>2.0</radius> </cylinder> Sphere \u00b6 # Default sphere sphere = create_sdf_element ( 'sphere' ) print ( 'Default sphere' ) print ( sphere ) print ( 'Default sphere - as dict' ) print ( sphere . to_dict ()) print ( 'Default sphere - as SDF' ) print ( sphere . to_xml_as_str ()) # Changing the parameters sphere . radius = 2 print ( 'Custom sphere' ) print ( sphere ) # Exporting # sphere.export_xml('/tmp/sphere.sdf') Default sphere <sphere> <radius>0</radius> </sphere> Default sphere - as dict {'sphere': {'radius': {'value': 0}}} Default sphere - as SDF <sphere><radius>0</radius></sphere> Custom sphere <sphere> <radius>2.0</radius> </sphere> Plane \u00b6 # Default plane plane = create_sdf_element ( 'plane' ) print ( 'Default plane' ) print ( plane ) print ( 'Default plane - as dict' ) print ( plane . to_dict ()) print ( 'Default plane - as SDF' ) print ( plane . to_xml_as_str ()) # Changing the parameters # Length of each side of the plane plane . size = [ 10 , 10 ] # Normal direction of the plane plane . normal = [ 1 , 0 , 0 ] print ( 'Custom plane' ) print ( plane ) # Exporting # plane.export_xml('/tmp/plane.sdf') Default plane <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> Default plane - as dict {'plane': {'size': {'value': [0, 0]}, 'normal': {'value': [0, 0, 1]}}} Default plane - as SDF <plane><size>0 0</size><normal>0 0 1</normal></plane> Custom plane <plane> <size>10 10</size> <normal>1 0 0</normal> </plane> Image \u00b6 A grayscale image can be used to extrude a set of boxes # Default image image = create_sdf_element ( 'image' ) print ( 'Default image' ) print ( image ) print ( 'Default image - as dict' ) print ( image . to_dict ()) print ( 'Default image - as SDF' ) print ( image . to_xml_as_str ()) # Height of the extruded boxes image . height = 10 # The amount of error in the model image . granularity = 1 # Grayscale threshold image . threshold = 100 # Scaling factor applied to the image image . scale = [ 2 ] # URI of the grayscale image image . uri = 'filename' print ( 'Custom image' ) print ( image ) # Exporting # image.export_xml('/tmp/image.sdf') Default image <image> <granularity>1</granularity> <height>1</height> <scale>1</scale> <uri></uri> <threshold>0</threshold> </image> Default image - as dict {'image': {'granularity': {'value': 1}, 'height': {'value': 1}, 'scale': {'value': [1]}, 'uri': {'value': ''}, 'threshold': {'value': 0}}} Default image - as SDF <image><granularity>1</granularity><height>1</height><scale>1</scale><uri></uri><threshold>0</threshold></image> Custom image <image> <granularity>1</granularity> <height>10.0</height> <scale>2</scale> <uri>filename</uri> <threshold>100.0</threshold> </image> Mesh \u00b6 mesh = create_sdf_element ( 'mesh' ) print ( 'Default mesh - with default parameters' ) print ( mesh ) print ( 'Default mesh - as dict' ) print ( mesh . to_dict ()) print ( 'Default mesh - as SDF' ) print ( mesh . to_xml_as_str ()) Default mesh - with default parameters <mesh> <scale>1 1 1</scale> <uri></uri> </mesh> Default mesh - as dict {'mesh': {'scale': {'value': [1, 1, 1]}, 'uri': {'value': ''}}} Default mesh - as SDF <mesh><scale>1 1 1</scale><uri></uri></mesh> print ( 'Mesh with optional parameters' ) mesh . reset ( with_optional_elements = True ) print ( mesh ) # Name of the submesh under the parent mesh mesh . submesh . name = 'submesh.stl' # Set to true to center the vertices of the submesh at (0, 0, 0) mesh . submesh . center = True # Scaling factor of the mesh mesh . scale = [ 2 , 1 , 1 ] # URI of the mesh mesh . uri = 'file://mesh.stl' print ( 'Custom mesh' ) print ( mesh ) Mesh with optional parameters <mesh> <scale>1 1 1</scale> <uri></uri> <submesh> <center>0</center> <name>none</name> </submesh> </mesh> Custom mesh <mesh> <scale>2 1 1</scale> <uri>file://mesh.stl</uri> <submesh> <center>1</center> <name>submesh.stl</name> </submesh> </mesh> Polyline \u00b6 polyline = create_sdf_element ( 'polyline' ) print ( 'Default polyline - with default parameters' ) print ( polyline ) print ( 'Default polyline - as dict' ) print ( polyline . to_dict ()) print ( 'Default polyline - as SDF' ) print ( polyline . to_xml_as_str ()) Default polyline - with default parameters <polyline> <height>1</height> </polyline> Default polyline - as dict {'polyline': {'height': {'value': 1}}} Default polyline - as SDF <polyline><height>1</height></polyline> print ( 'Polyline with optional parameters' ) polyline . reset ( with_optional_elements = True ) print ( polyline ) # Set new height polyline . height = 2.3 # Customize point polyline . points [ 0 ] . value = [ 2.3 , 4.5 ] # Add new point polyline . add_point () # Set the coordinates of new point polyline . points [ 1 ] . value = [ 3.7 , 10.1 ] print ( 'Custom polyline' ) print ( polyline ) Polyline with optional parameters <polyline> <point>0 0</point> <height>1</height> </polyline> Custom polyline <polyline> <point>2.3 4.5</point> <point>3.7 10.1</point> <height>2.3</height> </polyline> Creating a geometry entity \u00b6 # Initially, the geometry is created with a <empty/> element geometry = create_sdf_element ( 'geometry' ) print ( geometry ) <geometry> <empty></empty> </geometry> # Creating a geometry for each of the basic forms # The geometry entity has a separate mode for each possible geometry forms, since it cannot hold # multiple geometries # When a new geometry is set, the former one is deleted print ( 'All the geometry entity modes:' ) print ( geometry . get_modes ()) geometry . box = box print ( geometry ) geometry . cylinder = cylinder print ( geometry ) geometry . sphere = sphere print ( geometry ) geometry . plane = plane print ( geometry ) geometry . image = image print ( geometry ) geometry . mesh = mesh print ( geometry ) geometry . polyline = polyline print ( geometry ) All the geometry entity modes: ['empty', 'box', 'image', 'cylinder', 'sphere', 'plane', 'mesh', 'polyline'] <geometry> <box> <size>2 3 4</size> </box> </geometry> <geometry> <cylinder> <length>3.0</length> <radius>2.0</radius> </cylinder> </geometry> <geometry> <sphere> <radius>2.0</radius> </sphere> </geometry> <geometry> <plane> <size>10 10</size> <normal>1 0 0</normal> </plane> </geometry> <geometry> <image> <granularity>1</granularity> <height>10.0</height> <scale>2</scale> <uri>filename</uri> <threshold>100.0</threshold> </image> </geometry> <geometry> <mesh> <scale>2 1 1</scale> <uri>file://mesh.stl</uri> <submesh> <center>1</center> <name>submesh.stl</name> </submesh> </mesh> </geometry> <geometry> <polyline> <height>2.3</height> <point>2.3 4.5</point> <point>3.7 10.1</point> </polyline> </geometry>","title":"Geometries"},{"location":"tutorials/parsers/sdf/geometries/#geometries","text":"Geometry entities are child elements of < visual > or < collision > elements. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element","title":"Geometries"},{"location":"tutorials/parsers/sdf/geometries/#basic-entities","text":"Demonstration of the basic SDF elements that can be generated with and without the optional parameters.","title":"Basic entities"},{"location":"tutorials/parsers/sdf/geometries/#geometries_1","text":"","title":"Geometries"},{"location":"tutorials/parsers/sdf/geometries/#box","text":"# Default box box = create_sdf_element ( 'box' ) print ( 'Default box' ) print ( box ) print ( 'Default box - as dict' ) print ( box . to_dict ()) print ( 'Default box - as SDF' ) print ( box . to_xml_as_str ()) # Changing the size box . size = [ 2 , 3 , 4 ] print ( 'Custom box' ) print ( box ) # Exporting # box.export_xml('/tmp/box.sdf') Default box <box> <size>0 0 0</size> </box> Default box - as dict {'box': {'size': {'value': [0, 0, 0]}}} Default box - as SDF <box><size>0 0 0</size></box> Custom box <box> <size>2 3 4</size> </box>","title":"Box"},{"location":"tutorials/parsers/sdf/geometries/#cylinder","text":"# Default cylinder cylinder = create_sdf_element ( 'cylinder' ) print ( 'Default cylinder' ) print ( cylinder ) print ( 'Default cylinder - as dict' ) print ( cylinder . to_dict ()) print ( 'Default cylinder - as SDF' ) print ( cylinder . to_xml_as_str ()) # Changing the parameters cylinder . radius = 2 cylinder . length = 3 print ( 'Custom cylinder' ) print ( cylinder ) # Exporting # cylinder.export_xml('/tmp/cylinder.sdf') Default cylinder <cylinder> <length>0</length> <radius>0</radius> </cylinder> Default cylinder - as dict {'cylinder': {'length': {'value': 0}, 'radius': {'value': 0}}} Default cylinder - as SDF <cylinder><length>0</length><radius>0</radius></cylinder> Custom cylinder <cylinder> <length>3.0</length> <radius>2.0</radius> </cylinder>","title":"Cylinder"},{"location":"tutorials/parsers/sdf/geometries/#sphere","text":"# Default sphere sphere = create_sdf_element ( 'sphere' ) print ( 'Default sphere' ) print ( sphere ) print ( 'Default sphere - as dict' ) print ( sphere . to_dict ()) print ( 'Default sphere - as SDF' ) print ( sphere . to_xml_as_str ()) # Changing the parameters sphere . radius = 2 print ( 'Custom sphere' ) print ( sphere ) # Exporting # sphere.export_xml('/tmp/sphere.sdf') Default sphere <sphere> <radius>0</radius> </sphere> Default sphere - as dict {'sphere': {'radius': {'value': 0}}} Default sphere - as SDF <sphere><radius>0</radius></sphere> Custom sphere <sphere> <radius>2.0</radius> </sphere>","title":"Sphere"},{"location":"tutorials/parsers/sdf/geometries/#plane","text":"# Default plane plane = create_sdf_element ( 'plane' ) print ( 'Default plane' ) print ( plane ) print ( 'Default plane - as dict' ) print ( plane . to_dict ()) print ( 'Default plane - as SDF' ) print ( plane . to_xml_as_str ()) # Changing the parameters # Length of each side of the plane plane . size = [ 10 , 10 ] # Normal direction of the plane plane . normal = [ 1 , 0 , 0 ] print ( 'Custom plane' ) print ( plane ) # Exporting # plane.export_xml('/tmp/plane.sdf') Default plane <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> Default plane - as dict {'plane': {'size': {'value': [0, 0]}, 'normal': {'value': [0, 0, 1]}}} Default plane - as SDF <plane><size>0 0</size><normal>0 0 1</normal></plane> Custom plane <plane> <size>10 10</size> <normal>1 0 0</normal> </plane>","title":"Plane"},{"location":"tutorials/parsers/sdf/geometries/#image","text":"A grayscale image can be used to extrude a set of boxes # Default image image = create_sdf_element ( 'image' ) print ( 'Default image' ) print ( image ) print ( 'Default image - as dict' ) print ( image . to_dict ()) print ( 'Default image - as SDF' ) print ( image . to_xml_as_str ()) # Height of the extruded boxes image . height = 10 # The amount of error in the model image . granularity = 1 # Grayscale threshold image . threshold = 100 # Scaling factor applied to the image image . scale = [ 2 ] # URI of the grayscale image image . uri = 'filename' print ( 'Custom image' ) print ( image ) # Exporting # image.export_xml('/tmp/image.sdf') Default image <image> <granularity>1</granularity> <height>1</height> <scale>1</scale> <uri></uri> <threshold>0</threshold> </image> Default image - as dict {'image': {'granularity': {'value': 1}, 'height': {'value': 1}, 'scale': {'value': [1]}, 'uri': {'value': ''}, 'threshold': {'value': 0}}} Default image - as SDF <image><granularity>1</granularity><height>1</height><scale>1</scale><uri></uri><threshold>0</threshold></image> Custom image <image> <granularity>1</granularity> <height>10.0</height> <scale>2</scale> <uri>filename</uri> <threshold>100.0</threshold> </image>","title":"Image"},{"location":"tutorials/parsers/sdf/geometries/#mesh","text":"mesh = create_sdf_element ( 'mesh' ) print ( 'Default mesh - with default parameters' ) print ( mesh ) print ( 'Default mesh - as dict' ) print ( mesh . to_dict ()) print ( 'Default mesh - as SDF' ) print ( mesh . to_xml_as_str ()) Default mesh - with default parameters <mesh> <scale>1 1 1</scale> <uri></uri> </mesh> Default mesh - as dict {'mesh': {'scale': {'value': [1, 1, 1]}, 'uri': {'value': ''}}} Default mesh - as SDF <mesh><scale>1 1 1</scale><uri></uri></mesh> print ( 'Mesh with optional parameters' ) mesh . reset ( with_optional_elements = True ) print ( mesh ) # Name of the submesh under the parent mesh mesh . submesh . name = 'submesh.stl' # Set to true to center the vertices of the submesh at (0, 0, 0) mesh . submesh . center = True # Scaling factor of the mesh mesh . scale = [ 2 , 1 , 1 ] # URI of the mesh mesh . uri = 'file://mesh.stl' print ( 'Custom mesh' ) print ( mesh ) Mesh with optional parameters <mesh> <scale>1 1 1</scale> <uri></uri> <submesh> <center>0</center> <name>none</name> </submesh> </mesh> Custom mesh <mesh> <scale>2 1 1</scale> <uri>file://mesh.stl</uri> <submesh> <center>1</center> <name>submesh.stl</name> </submesh> </mesh>","title":"Mesh"},{"location":"tutorials/parsers/sdf/geometries/#polyline","text":"polyline = create_sdf_element ( 'polyline' ) print ( 'Default polyline - with default parameters' ) print ( polyline ) print ( 'Default polyline - as dict' ) print ( polyline . to_dict ()) print ( 'Default polyline - as SDF' ) print ( polyline . to_xml_as_str ()) Default polyline - with default parameters <polyline> <height>1</height> </polyline> Default polyline - as dict {'polyline': {'height': {'value': 1}}} Default polyline - as SDF <polyline><height>1</height></polyline> print ( 'Polyline with optional parameters' ) polyline . reset ( with_optional_elements = True ) print ( polyline ) # Set new height polyline . height = 2.3 # Customize point polyline . points [ 0 ] . value = [ 2.3 , 4.5 ] # Add new point polyline . add_point () # Set the coordinates of new point polyline . points [ 1 ] . value = [ 3.7 , 10.1 ] print ( 'Custom polyline' ) print ( polyline ) Polyline with optional parameters <polyline> <point>0 0</point> <height>1</height> </polyline> Custom polyline <polyline> <point>2.3 4.5</point> <point>3.7 10.1</point> <height>2.3</height> </polyline>","title":"Polyline"},{"location":"tutorials/parsers/sdf/geometries/#creating-a-geometry-entity","text":"# Initially, the geometry is created with a <empty/> element geometry = create_sdf_element ( 'geometry' ) print ( geometry ) <geometry> <empty></empty> </geometry> # Creating a geometry for each of the basic forms # The geometry entity has a separate mode for each possible geometry forms, since it cannot hold # multiple geometries # When a new geometry is set, the former one is deleted print ( 'All the geometry entity modes:' ) print ( geometry . get_modes ()) geometry . box = box print ( geometry ) geometry . cylinder = cylinder print ( geometry ) geometry . sphere = sphere print ( geometry ) geometry . plane = plane print ( geometry ) geometry . image = image print ( geometry ) geometry . mesh = mesh print ( geometry ) geometry . polyline = polyline print ( geometry ) All the geometry entity modes: ['empty', 'box', 'image', 'cylinder', 'sphere', 'plane', 'mesh', 'polyline'] <geometry> <box> <size>2 3 4</size> </box> </geometry> <geometry> <cylinder> <length>3.0</length> <radius>2.0</radius> </cylinder> </geometry> <geometry> <sphere> <radius>2.0</radius> </sphere> </geometry> <geometry> <plane> <size>10 10</size> <normal>1 0 0</normal> </plane> </geometry> <geometry> <image> <granularity>1</granularity> <height>10.0</height> <scale>2</scale> <uri>filename</uri> <threshold>100.0</threshold> </image> </geometry> <geometry> <mesh> <scale>2 1 1</scale> <uri>file://mesh.stl</uri> <submesh> <center>1</center> <name>submesh.stl</name> </submesh> </mesh> </geometry> <geometry> <polyline> <height>2.3</height> <point>2.3 4.5</point> <point>3.7 10.1</point> </polyline> </geometry>","title":"Creating a geometry entity"},{"location":"tutorials/parsers/sdf/links_joints_sensors/","text":"Links, joints and sensors \u00b6 Links \u00b6 A physical link in the simulation contains inertia, collision and visual properties. A link must be a child of a model and a model can have multiple links. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The link is empty by default link = create_sdf_element ( 'link' ) print ( link ) <link name=\"link\"/> # Let's create the elements dynamically at first link = create_sdf_element ( 'link' ) # The link's name must be unique in a model link . name = 'base_link' print ( link ) <link name=\"base_link\"/> # Mass of the link in kg link . mass = 30 # The center of mass are the cartesian coordinates in link.inertial.pose link . center_of_mass = [ 0 , 10 , 0 ] # The moments of inertia describe the elements of the 3x3 rotational inertial matrix link . inertia . ixx = 0.5 link . inertia . iyy = 0.5 link . inertia . izz = 0.5 print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> </link> # If gravity is set as true, the link will be affected by gravity link . gravity = True print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <gravity>1</gravity> </link> # If kinematic is set to true, the link is kinematic only link . kinematic = False print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <gravity>1</gravity> </link> # The pose of the link with respect to a frame link . pose = [ 0 , 0 , 1 , 0 , 0 , 0 ] print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> </link> # As mentioned in previous notebooks, a link can have multiple visual and collision elements # To create an empty collision geometry, use the function add_collision as follows link . add_collision ( name = 'collision_1' ) print ( link . collisions [ 0 ]) <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> # Set the geometry of the collision link . collisions [ 0 ] . box = create_sdf_element ( 'box' ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> </link> # You can also add a collision geometry by creating a collision entity and # adding it to the link as follows collision = create_sdf_element ( 'collision' ) collision . reset ( with_optional_elements = True ) collision . geometry . cylinder = create_sdf_element ( 'cylinder' ) link . add_collision ( 'collision_2' , collision ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can't add collision or visual elements with duplicated names # You can also add a collision geometry by creating a collision entity and # adding it to the link as follows collision = create_sdf_element ( 'collision' ) collision . reset ( with_optional_elements = True ) collision . geometry . box = create_sdf_element ( 'box' ) link . add_collision ( 'collision_2' , collision ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> link . add_collision ( 'collision_3' , collision ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can retrieve the collision geometry by its name # If the name given is not found, the function will return None print ( link . get_collision_by_name ( 'collision_1' )) print ( link . get_collision_by_name ( 'collision_10' )) # Or iterate in the collisions list for elem in link . collisions : print ( elem ) <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> None <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> # The same is true for visual elements, create an empty visual element by using add_visual link . add_visual ( 'visual_1' ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <visual name=\"visual_1\"> <geometry> <empty></empty> </geometry> </visual> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # Set the geometry of the visual element link . visuals [ 0 ] . geometry . plane = create_sdf_element ( 'plane' ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can also add a collision geometry by creating a collision entity and # adding it to the link as follows visual = create_sdf_element ( 'visual' ) visual . reset ( with_optional_elements = True ) visual . geometry . cylinder = create_sdf_element ( 'cylinder' ) link . add_visual ( 'visual_2' , visual ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> <visual name=\"visual_2\"> <pose frame=\"\">0 0 0 0 0 0</pose> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <cast_shadows>1</cast_shadows> <transparency>0</transparency> <material> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <specular>0.1 0.1 0.1 1</specular> <ambient>0 0 0 1</ambient> <emissive>0 0 0 1</emissive> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <diffuse>0 0 0 1</diffuse> </material> </visual> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can retrieve the visual geometry by its name # If the name given is not found, the function will return None print ( link . get_visual_by_name ( 'visual_1' )) print ( link . get_visual_by_name ( 'visual_10' )) # Or iterate in the visuals list for elem in link . visuals : print ( elem ) <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> None <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> <visual name=\"visual_2\"> <pose frame=\"\">0 0 0 0 0 0</pose> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <cast_shadows>1</cast_shadows> <transparency>0</transparency> <material> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <specular>0.1 0.1 0.1 1</specular> <ambient>0 0 0 1</ambient> <emissive>0 0 0 1</emissive> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <diffuse>0 0 0 1</diffuse> </material> </visual> Joints \u00b6 # The joint is empty by default joint = create_sdf_element ( 'joint' ) print ( joint ) <joint name=\"joint\" type=\"revolute\"> <parent>parent</parent> <child>none</child> </joint> Sensors \u00b6 sensor = create_sdf_element ( 'sensor' ) print ( sensor ) <sensor name=\"default\" type=\"altimeter\"/> print ( sensor . get_modes ()) ['none', 'altimeter', 'camera', 'contact', 'depth', 'gps', 'gpu_ray', 'imu', 'logical_camera', 'magnetometer', 'multicamera', 'ray', 'rfid', 'rfidtag', 'sonar', 'wireless_receiver', 'wireless_transmitter', 'force_torque'] sensor . reset ( mode = 'altimeter' , with_optional_elements = True ) print ( sensor ) <sensor name=\"default\" type=\"default\"> <topic>none</topic> <update_rate>0</update_rate> <always_on>0</always_on> <altimeter> <vertical_position> <noise type=\"none\"> <precision>0</precision> <stddev>0</stddev> <bias_stddev>0</bias_stddev> <bias_mean>0</bias_mean> <mean>0</mean> </noise> </vertical_position> <vertical_velocity> <noise type=\"none\"> <precision>0</precision> <stddev>0</stddev> <bias_stddev>0</bias_stddev> <bias_mean>0</bias_mean> <mean>0</mean> </noise> </vertical_velocity> </altimeter> <pose frame=\"\">0 0 0 0 0 0</pose> <visualize>0</visualize> <plugin filename=\"\" name=\"\"/> </sensor> sensor . reset ( mode = 'camera' , with_optional_elements = True ) print ( sensor ) <sensor name=\"default\" type=\"default\"> <topic>none</topic> <update_rate>0</update_rate> <always_on>0</always_on> <pose frame=\"\">0 0 0 0 0 0</pose> <visualize>0</visualize> <plugin filename=\"\" name=\"\"/> <camera name=\"default\"> <clip> <near>100</near> <far>0.1</far> </clip> <distortion> <k3>0</k3> <k2>0</k2> <k1>0</k1> <center>0.5 0.5</center> <p2>0</p2> <p1>0</p1> </distortion> <noise type=\"none\"> <precision>0</precision> <stddev>0</stddev> <bias_stddev>0</bias_stddev> <bias_mean>0</bias_mean> <mean>0</mean> </noise> <horizontal_fov>1.047</horizontal_fov> <image> <width>320</width> <format>R8G8B8</format> <height>1</height> </image> <depth_camera> <output>depths</output> </depth_camera> <save enabled=\"False\"> <path>__default__</path> </save> </camera> </sensor> sensor . reset ( mode = 'force_torque' , with_optional_elements = True ) print ( sensor ) <sensor name=\"default\" type=\"default\"> <topic>none</topic> <update_rate>0</update_rate> <always_on>0</always_on> <pose frame=\"\">0 0 0 0 0 0</pose> <visualize>0</visualize> <plugin filename=\"\" name=\"\"/> <force_torque> <frame>child</frame> <measure_direction>child_to_parent</measure_direction> </force_torque> </sensor>","title":"Links, joints and sensors"},{"location":"tutorials/parsers/sdf/links_joints_sensors/#links-joints-and-sensors","text":"","title":"Links, joints and sensors"},{"location":"tutorials/parsers/sdf/links_joints_sensors/#links","text":"A physical link in the simulation contains inertia, collision and visual properties. A link must be a child of a model and a model can have multiple links. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The link is empty by default link = create_sdf_element ( 'link' ) print ( link ) <link name=\"link\"/> # Let's create the elements dynamically at first link = create_sdf_element ( 'link' ) # The link's name must be unique in a model link . name = 'base_link' print ( link ) <link name=\"base_link\"/> # Mass of the link in kg link . mass = 30 # The center of mass are the cartesian coordinates in link.inertial.pose link . center_of_mass = [ 0 , 10 , 0 ] # The moments of inertia describe the elements of the 3x3 rotational inertial matrix link . inertia . ixx = 0.5 link . inertia . iyy = 0.5 link . inertia . izz = 0.5 print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> </link> # If gravity is set as true, the link will be affected by gravity link . gravity = True print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <gravity>1</gravity> </link> # If kinematic is set to true, the link is kinematic only link . kinematic = False print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <gravity>1</gravity> </link> # The pose of the link with respect to a frame link . pose = [ 0 , 0 , 1 , 0 , 0 , 0 ] print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> </link> # As mentioned in previous notebooks, a link can have multiple visual and collision elements # To create an empty collision geometry, use the function add_collision as follows link . add_collision ( name = 'collision_1' ) print ( link . collisions [ 0 ]) <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> # Set the geometry of the collision link . collisions [ 0 ] . box = create_sdf_element ( 'box' ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> </link> # You can also add a collision geometry by creating a collision entity and # adding it to the link as follows collision = create_sdf_element ( 'collision' ) collision . reset ( with_optional_elements = True ) collision . geometry . cylinder = create_sdf_element ( 'cylinder' ) link . add_collision ( 'collision_2' , collision ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can't add collision or visual elements with duplicated names # You can also add a collision geometry by creating a collision entity and # adding it to the link as follows collision = create_sdf_element ( 'collision' ) collision . reset ( with_optional_elements = True ) collision . geometry . box = create_sdf_element ( 'box' ) link . add_collision ( 'collision_2' , collision ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> link . add_collision ( 'collision_3' , collision ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can retrieve the collision geometry by its name # If the name given is not found, the function will return None print ( link . get_collision_by_name ( 'collision_1' )) print ( link . get_collision_by_name ( 'collision_10' )) # Or iterate in the collisions list for elem in link . collisions : print ( elem ) <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> None <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> # The same is true for visual elements, create an empty visual element by using add_visual link . add_visual ( 'visual_1' ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <visual name=\"visual_1\"> <geometry> <empty></empty> </geometry> </visual> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # Set the geometry of the visual element link . visuals [ 0 ] . geometry . plane = create_sdf_element ( 'plane' ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can also add a collision geometry by creating a collision entity and # adding it to the link as follows visual = create_sdf_element ( 'visual' ) visual . reset ( with_optional_elements = True ) visual . geometry . cylinder = create_sdf_element ( 'cylinder' ) link . add_visual ( 'visual_2' , visual ) print ( link ) <link name=\"base_link\"> <inertial> <pose frame=\"\">0.0 10.0 0.0 0 0 0</pose> <mass>30.0</mass> <inertia> <ixx>0.5</ixx> <iyy>0.5</iyy> <ixz>0</ixz> <iyz>0</iyz> <izz>0.5</izz> <ixy>0</ixy> </inertia> </inertial> <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> <visual name=\"visual_2\"> <pose frame=\"\">0 0 0 0 0 0</pose> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <cast_shadows>1</cast_shadows> <transparency>0</transparency> <material> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <specular>0.1 0.1 0.1 1</specular> <ambient>0 0 0 1</ambient> <emissive>0 0 0 1</emissive> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <diffuse>0 0 0 1</diffuse> </material> </visual> <kinematic>0</kinematic> <pose frame=\"\">0 0 1 0 0 0</pose> <gravity>1</gravity> <collision name=\"collision_1\"> <geometry> <empty></empty> </geometry> </collision> <collision name=\"collision_2\"> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_2_0\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> <collision name=\"collision_3\"> <geometry> <box> <size>0 0 0</size> </box> </geometry> <max_contacts>10</max_contacts> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <laser_retro>0</laser_retro> <pose frame=\"\">0 0 0 0 0 0</pose> <surface> <bounce> <restitution_coefficient>0</restitution_coefficient> <threshold>100000</threshold> </bounce> <contact> <bullet> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <soft_erp>0.2</soft_erp> <split_impulse>1</split_impulse> <kd>1</kd> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> </bullet> <ode> <soft_cfm>0</soft_cfm> <kp>1000000000000.0</kp> <min_depth>0</min_depth> <max_vel>0.01</max_vel> <kd>1</kd> <soft_erp>0.2</soft_erp> </ode> </contact> <friction> <torsional> <patch_radius>0</patch_radius> <surface_radius>0</surface_radius> <ode> <slip>0</slip> </ode> <coefficient>1</coefficient> <use_patch_radius>1</use_patch_radius> </torsional> <bullet> <fdir1>0 0 0</fdir1> <friction>1</friction> <rolling_friction>1</rolling_friction> <friction2>1</friction2> </bullet> <ode> <mu2>1</mu2> <mu>1</mu> <fdir1>0 0 0</fdir1> <slip1>0</slip1> <slip2>0</slip2> </ode> </friction> </surface> </collision> </link> # You can retrieve the visual geometry by its name # If the name given is not found, the function will return None print ( link . get_visual_by_name ( 'visual_1' )) print ( link . get_visual_by_name ( 'visual_10' )) # Or iterate in the visuals list for elem in link . visuals : print ( elem ) <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> None <visual name=\"visual_1\"> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> </visual> <visual name=\"visual_2\"> <pose frame=\"\">0 0 0 0 0 0</pose> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <cast_shadows>1</cast_shadows> <transparency>0</transparency> <material> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <specular>0.1 0.1 0.1 1</specular> <ambient>0 0 0 1</ambient> <emissive>0 0 0 1</emissive> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <diffuse>0 0 0 1</diffuse> </material> </visual>","title":"Links"},{"location":"tutorials/parsers/sdf/links_joints_sensors/#joints","text":"# The joint is empty by default joint = create_sdf_element ( 'joint' ) print ( joint ) <joint name=\"joint\" type=\"revolute\"> <parent>parent</parent> <child>none</child> </joint>","title":"Joints"},{"location":"tutorials/parsers/sdf/links_joints_sensors/#sensors","text":"sensor = create_sdf_element ( 'sensor' ) print ( sensor ) <sensor name=\"default\" type=\"altimeter\"/> print ( sensor . get_modes ()) ['none', 'altimeter', 'camera', 'contact', 'depth', 'gps', 'gpu_ray', 'imu', 'logical_camera', 'magnetometer', 'multicamera', 'ray', 'rfid', 'rfidtag', 'sonar', 'wireless_receiver', 'wireless_transmitter', 'force_torque'] sensor . reset ( mode = 'altimeter' , with_optional_elements = True ) print ( sensor ) <sensor name=\"default\" type=\"default\"> <topic>none</topic> <update_rate>0</update_rate> <always_on>0</always_on> <altimeter> <vertical_position> <noise type=\"none\"> <precision>0</precision> <stddev>0</stddev> <bias_stddev>0</bias_stddev> <bias_mean>0</bias_mean> <mean>0</mean> </noise> </vertical_position> <vertical_velocity> <noise type=\"none\"> <precision>0</precision> <stddev>0</stddev> <bias_stddev>0</bias_stddev> <bias_mean>0</bias_mean> <mean>0</mean> </noise> </vertical_velocity> </altimeter> <pose frame=\"\">0 0 0 0 0 0</pose> <visualize>0</visualize> <plugin filename=\"\" name=\"\"/> </sensor> sensor . reset ( mode = 'camera' , with_optional_elements = True ) print ( sensor ) <sensor name=\"default\" type=\"default\"> <topic>none</topic> <update_rate>0</update_rate> <always_on>0</always_on> <pose frame=\"\">0 0 0 0 0 0</pose> <visualize>0</visualize> <plugin filename=\"\" name=\"\"/> <camera name=\"default\"> <clip> <near>100</near> <far>0.1</far> </clip> <distortion> <k3>0</k3> <k2>0</k2> <k1>0</k1> <center>0.5 0.5</center> <p2>0</p2> <p1>0</p1> </distortion> <noise type=\"none\"> <precision>0</precision> <stddev>0</stddev> <bias_stddev>0</bias_stddev> <bias_mean>0</bias_mean> <mean>0</mean> </noise> <horizontal_fov>1.047</horizontal_fov> <image> <width>320</width> <format>R8G8B8</format> <height>1</height> </image> <depth_camera> <output>depths</output> </depth_camera> <save enabled=\"False\"> <path>__default__</path> </save> </camera> </sensor> sensor . reset ( mode = 'force_torque' , with_optional_elements = True ) print ( sensor ) <sensor name=\"default\" type=\"default\"> <topic>none</topic> <update_rate>0</update_rate> <always_on>0</always_on> <pose frame=\"\">0 0 0 0 0 0</pose> <visualize>0</visualize> <plugin filename=\"\" name=\"\"/> <force_torque> <frame>child</frame> <measure_direction>child_to_parent</measure_direction> </force_torque> </sensor>","title":"Sensors"},{"location":"tutorials/parsers/sdf/materials/","text":"Materials \u00b6 Child element of a < visual > element. A visual may contain only one material. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # Material elements are initially empty since all its child elements are optional material = create_sdf_element ( 'material' ) print ( material ) <material/> # To create all optional elements with its default elements, use reset() material . reset ( with_optional_elements = True ) print ( material ) <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <ambient>0 0 0 1</ambient> </material> Creating a custom material \u00b6 # Setting the script # URI of the material script file # Gazebo's default material file can be found at # https://bitbucket.org/osrf/gazebo/src/bd1cdea8fa3d71d6afcdaa83c9b01891d5f72e71/media/materials/scripts/gazebo.material?at=default&fileviewer=file-view-default material . script . uri = 'file://media/materials/scripts/gazebo.material' # Name of the script within the script file material . script . name = 'Gazebo/Wood' # Setting the shader # The shader type can be one of the list below: # ['vertex', 'pixel', 'normal_map_objectspace', 'normal_map_tangentspace'] material . shader . type = 'vertex' material . shader . normal_map = 'file://normal_map' # If lighting is false, dynamic lighting will be disabled material . lighting = False # The colors must be a set of four numbers in the range of [0, 1] material . ambient = [ 0.2 , 0.2 , 0.2 , 1 ] material . diffuse = [ 0.2 , 0.4 , 0.2 , 1 ] material . specular = [ 0.2 , 0.2 , 0.6 , 1 ] material . emissive = [ 0.5 , 0.5 , 0.5 , 1 ] print ( material ) <material> <specular>0.2 0.2 0.6 1</specular> <diffuse>0.2 0.4 0.2 1</diffuse> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> <shader type=\"vertex\"> <normal_map>file://normal_map</normal_map> </shader> <emissive>0.5 0.5 0.5 1</emissive> <ambient>0.2 0.2 0.2 1</ambient> </material>","title":"Materials"},{"location":"tutorials/parsers/sdf/materials/#materials","text":"Child element of a < visual > element. A visual may contain only one material. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # Material elements are initially empty since all its child elements are optional material = create_sdf_element ( 'material' ) print ( material ) <material/> # To create all optional elements with its default elements, use reset() material . reset ( with_optional_elements = True ) print ( material ) <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <ambient>0 0 0 1</ambient> </material>","title":"Materials"},{"location":"tutorials/parsers/sdf/materials/#creating-a-custom-material","text":"# Setting the script # URI of the material script file # Gazebo's default material file can be found at # https://bitbucket.org/osrf/gazebo/src/bd1cdea8fa3d71d6afcdaa83c9b01891d5f72e71/media/materials/scripts/gazebo.material?at=default&fileviewer=file-view-default material . script . uri = 'file://media/materials/scripts/gazebo.material' # Name of the script within the script file material . script . name = 'Gazebo/Wood' # Setting the shader # The shader type can be one of the list below: # ['vertex', 'pixel', 'normal_map_objectspace', 'normal_map_tangentspace'] material . shader . type = 'vertex' material . shader . normal_map = 'file://normal_map' # If lighting is false, dynamic lighting will be disabled material . lighting = False # The colors must be a set of four numbers in the range of [0, 1] material . ambient = [ 0.2 , 0.2 , 0.2 , 1 ] material . diffuse = [ 0.2 , 0.4 , 0.2 , 1 ] material . specular = [ 0.2 , 0.2 , 0.6 , 1 ] material . emissive = [ 0.5 , 0.5 , 0.5 , 1 ] print ( material ) <material> <specular>0.2 0.2 0.6 1</specular> <diffuse>0.2 0.4 0.2 1</diffuse> <lighting>0</lighting> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>Gazebo/Wood</name> </script> <shader type=\"vertex\"> <normal_map>file://normal_map</normal_map> </shader> <emissive>0.5 0.5 0.5 1</emissive> <ambient>0.2 0.2 0.2 1</ambient> </material>","title":"Creating a custom material"},{"location":"tutorials/parsers/sdf/models/","text":"Models \u00b6 A model element defines a complete robot or any other kind of physical object. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The model is empty by default model = create_sdf_element ( 'model' ) print ( model ) <model name=\"model\"/> # Let's create the elements dynamically at first model = create_sdf_element ( 'model' ) # The model's name must be unique in a model model . name = 'my_robot' print ( model ) <model name=\"my_robot\"/> # If static is set to true, the model is immovable model . static = True print ( model ) <model name=\"my_robot\"> <static>1</static> </model> # With the allow_auto_disable flag on, the physics engine can skip # updating the model when the model is at rest # This is only used for models with no joints model . allow_auto_disable = True print ( model ) <model name=\"my_robot\"> <static>1</static> <allow_auto_disable>1</allow_auto_disable> </model> # If self_collide is set to true, the model will collide with # others expect with those connected by a joint model . self_collide = True print ( model ) <model name=\"my_robot\"> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> </model> # Pose of model with respect to the world frame model . pose = [ 0 , 1 , 1 , 0 , 0 , 0 ] print ( model ) <model name=\"my_robot\"> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> <pose frame=\"\">0 1 1 0 0 0</pose> </model> # An empty link can be added by using the add_link() method as follows model . add_link ( name = 'link_1' ) print ( model . links [ 0 ]) <link name=\"link_1\"/> # The link can be edited as well model . links [ 0 ] . gravity = True print ( model ) <model name=\"my_robot\"> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> <pose frame=\"\">0 1 1 0 0 0</pose> <link name=\"link_1\"> <gravity>1</gravity> </link> </model> # Another link with the same name cannot be added model . add_link ( 'link_1' ) Link element with name link_1 already exists # A model from another file can be included using the add_include() # method model . add_include ( 'include_1' ) model . includes [ 0 ] . uri = 'file://some_file' model . includes [ 0 ] . name = 'some_model' print ( model ) <model name=\"my_robot\"> <link name=\"link_1\"> <gravity>1</gravity> </link> <pose frame=\"\">0 1 1 0 0 0</pose> <include> <name>some_model</name> <uri>file://some_file</uri> </include> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> </model> # An empty link can be added by using the add_link() method as follows model . add_joint ( name = 'joint_1' ) print ( model . joints [ 0 ]) <joint name=\"joint_1\" type=\"revolute\"> <child>none</child> <parent>parent</parent> </joint>","title":"Models"},{"location":"tutorials/parsers/sdf/models/#models","text":"A model element defines a complete robot or any other kind of physical object. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The model is empty by default model = create_sdf_element ( 'model' ) print ( model ) <model name=\"model\"/> # Let's create the elements dynamically at first model = create_sdf_element ( 'model' ) # The model's name must be unique in a model model . name = 'my_robot' print ( model ) <model name=\"my_robot\"/> # If static is set to true, the model is immovable model . static = True print ( model ) <model name=\"my_robot\"> <static>1</static> </model> # With the allow_auto_disable flag on, the physics engine can skip # updating the model when the model is at rest # This is only used for models with no joints model . allow_auto_disable = True print ( model ) <model name=\"my_robot\"> <static>1</static> <allow_auto_disable>1</allow_auto_disable> </model> # If self_collide is set to true, the model will collide with # others expect with those connected by a joint model . self_collide = True print ( model ) <model name=\"my_robot\"> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> </model> # Pose of model with respect to the world frame model . pose = [ 0 , 1 , 1 , 0 , 0 , 0 ] print ( model ) <model name=\"my_robot\"> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> <pose frame=\"\">0 1 1 0 0 0</pose> </model> # An empty link can be added by using the add_link() method as follows model . add_link ( name = 'link_1' ) print ( model . links [ 0 ]) <link name=\"link_1\"/> # The link can be edited as well model . links [ 0 ] . gravity = True print ( model ) <model name=\"my_robot\"> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> <pose frame=\"\">0 1 1 0 0 0</pose> <link name=\"link_1\"> <gravity>1</gravity> </link> </model> # Another link with the same name cannot be added model . add_link ( 'link_1' ) Link element with name link_1 already exists # A model from another file can be included using the add_include() # method model . add_include ( 'include_1' ) model . includes [ 0 ] . uri = 'file://some_file' model . includes [ 0 ] . name = 'some_model' print ( model ) <model name=\"my_robot\"> <link name=\"link_1\"> <gravity>1</gravity> </link> <pose frame=\"\">0 1 1 0 0 0</pose> <include> <name>some_model</name> <uri>file://some_file</uri> </include> <static>1</static> <self_collide>1</self_collide> <allow_auto_disable>1</allow_auto_disable> </model> # An empty link can be added by using the add_link() method as follows model . add_joint ( name = 'joint_1' ) print ( model . joints [ 0 ]) <joint name=\"joint_1\" type=\"revolute\"> <child>none</child> <parent>parent</parent> </joint>","title":"Models"},{"location":"tutorials/parsers/sdf/physics_engines/","text":"Physics engines \u00b6 The description of the physics engine's parameters is one of the most import parts in the world description in Gazebo. A < world > can only have one physics element. It can use the following engines: ODE ( ode ) Bullet ( bullet ) Simbody ( simbody ) DART ( dart ) and a specific SDF block is available to describe each engine. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # Create first the global physics block physics = create_sdf_element ( 'physics' ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <real_time_update_rate>1000</real_time_update_rate> </physics> # The physics engine's configuration modes are named after the # engine being used, the default being `ode` physics . reset ( mode = 'ode' , with_optional_elements = True ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <real_time_update_rate>1000</real_time_update_rate> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <ode> <solver> <use_dynamic_moi_scaling>0</use_dynamic_moi_scaling> <sor>1.3</sor> <friction_model>pyramid_model</friction_model> <type>quick</type> <iters>50</iters> <min_step_size>0.0001</min_step_size> <precon_iters>0</precon_iters> </solver> <constraints> <cfm>0</cfm> <contact_max_correcting_vel>100</contact_max_correcting_vel> <contact_surface_layer>0.001</contact_surface_layer> <erp>0.2</erp> </constraints> </ode> </physics> physics . reset ( mode = 'bullet' , with_optional_elements = True ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"bullet\"> <max_contacts>20</max_contacts> <bullet> <solver> <type>quick</type> <iters>50</iters> <sor>1.3</sor> <min_step_size>0.0001</min_step_size> </solver> <constraints> <split_impulse>1</split_impulse> <cfm>0</cfm> <erp>0.2</erp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <contact_surface_layer>0.001</contact_surface_layer> </constraints> </bullet> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <real_time_update_rate>1000</real_time_update_rate> </physics> physics . reset ( mode = 'simbody' , with_optional_elements = True ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"simbody\"> <simbody> <accuracy>0.001</accuracy> <contact> <plastic_impact_velocity>0.5</plastic_impact_velocity> <viscous_friction>0</viscous_friction> <dissipation>100</dissipation> <stiffness>100000000.0</stiffness> <plastic_coef_restitution>0.5</plastic_coef_restitution> <static_friction>0.9</static_friction> <override_stiction_transition_velocity>0.001</override_stiction_transition_velocity> <override_impact_capture_velocity>0.001</override_impact_capture_velocity> <dynamic_friction>0.9</dynamic_friction> </contact> <max_transient_velocity>0.01</max_transient_velocity> <min_step_size>0.0001</min_step_size> </simbody> <max_contacts>20</max_contacts> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <real_time_update_rate>1000</real_time_update_rate> </physics>","title":"Physics engines"},{"location":"tutorials/parsers/sdf/physics_engines/#physics-engines","text":"The description of the physics engine's parameters is one of the most import parts in the world description in Gazebo. A < world > can only have one physics element. It can use the following engines: ODE ( ode ) Bullet ( bullet ) Simbody ( simbody ) DART ( dart ) and a specific SDF block is available to describe each engine. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # Create first the global physics block physics = create_sdf_element ( 'physics' ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <real_time_update_rate>1000</real_time_update_rate> </physics> # The physics engine's configuration modes are named after the # engine being used, the default being `ode` physics . reset ( mode = 'ode' , with_optional_elements = True ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <real_time_update_rate>1000</real_time_update_rate> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <ode> <solver> <use_dynamic_moi_scaling>0</use_dynamic_moi_scaling> <sor>1.3</sor> <friction_model>pyramid_model</friction_model> <type>quick</type> <iters>50</iters> <min_step_size>0.0001</min_step_size> <precon_iters>0</precon_iters> </solver> <constraints> <cfm>0</cfm> <contact_max_correcting_vel>100</contact_max_correcting_vel> <contact_surface_layer>0.001</contact_surface_layer> <erp>0.2</erp> </constraints> </ode> </physics> physics . reset ( mode = 'bullet' , with_optional_elements = True ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"bullet\"> <max_contacts>20</max_contacts> <bullet> <solver> <type>quick</type> <iters>50</iters> <sor>1.3</sor> <min_step_size>0.0001</min_step_size> </solver> <constraints> <split_impulse>1</split_impulse> <cfm>0</cfm> <erp>0.2</erp> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <contact_surface_layer>0.001</contact_surface_layer> </constraints> </bullet> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <real_time_update_rate>1000</real_time_update_rate> </physics> physics . reset ( mode = 'simbody' , with_optional_elements = True ) print ( physics ) <physics default=\"1\" name=\"default_physics\" type=\"simbody\"> <simbody> <accuracy>0.001</accuracy> <contact> <plastic_impact_velocity>0.5</plastic_impact_velocity> <viscous_friction>0</viscous_friction> <dissipation>100</dissipation> <stiffness>100000000.0</stiffness> <plastic_coef_restitution>0.5</plastic_coef_restitution> <static_friction>0.9</static_friction> <override_stiction_transition_velocity>0.001</override_stiction_transition_velocity> <override_impact_capture_velocity>0.001</override_impact_capture_velocity> <dynamic_friction>0.9</dynamic_friction> </contact> <max_transient_velocity>0.01</max_transient_velocity> <min_step_size>0.0001</min_step_size> </simbody> <max_contacts>20</max_contacts> <real_time_factor>1</real_time_factor> <max_step_size>0.001</max_step_size> <real_time_update_rate>1000</real_time_update_rate> </physics>","title":"Physics engines"},{"location":"tutorials/parsers/sdf/plugins/","text":"Plugins \u00b6 # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element plugin_args = dict ( robotNamespace = 'robot' , topic = '/topic' , args = dict ( param1 = 1 , param2 = True , param3 = dict ( param31 = 'option' , param32 = 3.434534 ), param4 = [ 3.1 , 4.5 , 8.5 ] ) ) plugin = create_sdf_element ( 'plugin' , plugin_args ) plugin . name = 'some_plugin' plugin . filename = 'libplugin.so' print ( plugin ) <plugin filename=\"libplugin.so\" name=\"some_plugin\"/> plugin = create_sdf_element ( 'plugin' , plugin_args ) plugin . value = plugin_args plugin . name = 'another_plugin' plugin . filename = 'libanother_plugin.so' print ( plugin ) <plugin filename=\"libanother_plugin.so\" name=\"another_plugin\"> <args> <param3> <param31>option</param31> <param32>3.434534</param32> </param3> <param1>1</param1> <param2>1</param2> <param4>3.1 4.5 8.5</param4> </args> <topic>/topic</topic> <robotNamespace>robot</robotNamespace> </plugin> Some plugin default constructors \u00b6 from pcg_gazebo.parsers.sdf import Plugin gazebo_ros_control \u00b6 print ( Plugin . gazebo_ros_control ( name = 'gazebo_ros_control' , robot_namespace = '/my_robot' , control_period = 10 , robot_param = '/robot_description' , robot_sim_type = None )) <plugin filename=\"libgazebo_ros_control.so\" name=\"gazebo_ros_control\"> <controlPeriod>10</controlPeriod> <robotNamespace>/my_robot</robotNamespace> <robotParam>/robot_description</robotParam> </plugin> gazebo_ros_bumper \u00b6 print ( Plugin . gazebo_ros_bumper ( name = 'gazebo_ros_bumper' , robot_namespace = '/my_robot' , bumper_topic_name = 'bumper_states' , frame_name = 'world' )) <plugin filename=\"libgazebo_ros_bumper.so\" name=\"gazebo_ros_bumper\"> <robotNamespace>/my_robot</robotNamespace> <frameName>world</frameName> <bumperTopicName>bumper_states</bumperTopicName> </plugin> gazebo_ros_ft_sensor \u00b6 print ( Plugin . gazebo_ros_ft_sensor ( name = 'gazebo_ros_ft_sensor' , robot_namespace = 'my_robot' , joint_name = 'some_joint' , topic_name = 'force_torque_sensor_output' , gaussian_noise = 0.05 , update_rate = 0 )) <plugin filename=\"libgazebo_ros_ft_sensor.so\" name=\"gazebo_ros_ft_sensor\"> <jointName>some_joint</jointName> <updateRate>0</updateRate> <robotNamespace>my_robot</robotNamespace> <topicName>force_torque_sensor_output</topicName> <gaussianNoise>0.05</gaussianNoise> </plugin>","title":"Plugins"},{"location":"tutorials/parsers/sdf/plugins/#plugins","text":"# Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element plugin_args = dict ( robotNamespace = 'robot' , topic = '/topic' , args = dict ( param1 = 1 , param2 = True , param3 = dict ( param31 = 'option' , param32 = 3.434534 ), param4 = [ 3.1 , 4.5 , 8.5 ] ) ) plugin = create_sdf_element ( 'plugin' , plugin_args ) plugin . name = 'some_plugin' plugin . filename = 'libplugin.so' print ( plugin ) <plugin filename=\"libplugin.so\" name=\"some_plugin\"/> plugin = create_sdf_element ( 'plugin' , plugin_args ) plugin . value = plugin_args plugin . name = 'another_plugin' plugin . filename = 'libanother_plugin.so' print ( plugin ) <plugin filename=\"libanother_plugin.so\" name=\"another_plugin\"> <args> <param3> <param31>option</param31> <param32>3.434534</param32> </param3> <param1>1</param1> <param2>1</param2> <param4>3.1 4.5 8.5</param4> </args> <topic>/topic</topic> <robotNamespace>robot</robotNamespace> </plugin>","title":"Plugins"},{"location":"tutorials/parsers/sdf/plugins/#some-plugin-default-constructors","text":"from pcg_gazebo.parsers.sdf import Plugin","title":"Some plugin default constructors"},{"location":"tutorials/parsers/sdf/plugins/#gazebo_ros_control","text":"print ( Plugin . gazebo_ros_control ( name = 'gazebo_ros_control' , robot_namespace = '/my_robot' , control_period = 10 , robot_param = '/robot_description' , robot_sim_type = None )) <plugin filename=\"libgazebo_ros_control.so\" name=\"gazebo_ros_control\"> <controlPeriod>10</controlPeriod> <robotNamespace>/my_robot</robotNamespace> <robotParam>/robot_description</robotParam> </plugin>","title":"gazebo_ros_control"},{"location":"tutorials/parsers/sdf/plugins/#gazebo_ros_bumper","text":"print ( Plugin . gazebo_ros_bumper ( name = 'gazebo_ros_bumper' , robot_namespace = '/my_robot' , bumper_topic_name = 'bumper_states' , frame_name = 'world' )) <plugin filename=\"libgazebo_ros_bumper.so\" name=\"gazebo_ros_bumper\"> <robotNamespace>/my_robot</robotNamespace> <frameName>world</frameName> <bumperTopicName>bumper_states</bumperTopicName> </plugin>","title":"gazebo_ros_bumper"},{"location":"tutorials/parsers/sdf/plugins/#gazebo_ros_ft_sensor","text":"print ( Plugin . gazebo_ros_ft_sensor ( name = 'gazebo_ros_ft_sensor' , robot_namespace = 'my_robot' , joint_name = 'some_joint' , topic_name = 'force_torque_sensor_output' , gaussian_noise = 0.05 , update_rate = 0 )) <plugin filename=\"libgazebo_ros_ft_sensor.so\" name=\"gazebo_ros_ft_sensor\"> <jointName>some_joint</jointName> <updateRate>0</updateRate> <robotNamespace>my_robot</robotNamespace> <topicName>force_torque_sensor_output</topicName> <gaussianNoise>0.05</gaussianNoise> </plugin>","title":"gazebo_ros_ft_sensor"},{"location":"tutorials/parsers/sdf/visuals/","text":"Visuals \u00b6 The < visual > element specifies the shape of the geometry for rendering. It is a child element from < link > and a link can have multiple visual elements. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The visual element is created with an empty geometry by default visual = create_sdf_element ( 'visual' ) print ( visual ) <visual name=\"visual\"> <geometry> <empty></empty> </geometry> </visual> # To see the optional elements, use the method reset() visual . reset ( with_optional_elements = True ) print ( visual ) <visual name=\"visual\"> <pose frame=\"\">0 0 0 0 0 0</pose> <geometry> <empty></empty> </geometry> <transparency>0</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> # Setting the parameters for the visual element # Each visual in a link should have an unique name visual . name = 'custom_visual' # If cast_shadows is true, the geometry will cast shadows visual . cast_shadows = True # The transparency is a double in the range of [0, 1], 0 being opaque and 1 fully transparent visual . transparency = 0.2 # Pose of the visual geometry with respect to a frame visual . pose = [ 0 , 0.2 , 0 , 0 , 0 , 0 ] visual . pose . frame = 'base_link' print ( visual ) <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <empty></empty> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> # Setting different geometries to the visual element visual . geometry . box = create_sdf_element ( 'box' ) print ( visual ) visual . geometry . sphere = create_sdf_element ( 'sphere' ) print ( visual ) visual . geometry . cylinder = create_sdf_element ( 'cylinder' ) print ( visual ) visual . geometry . plane = create_sdf_element ( 'plane' ) print ( visual ) visual . geometry . mesh = create_sdf_element ( 'mesh' ) visual . geometry . mesh . reset ( with_optional_elements = True ) print ( visual ) visual . geometry . image = create_sdf_element ( 'image' ) print ( visual ) visual . geometry . polyline = create_sdf_element ( 'polyline' ) print ( visual ) <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>0 0 0</size> </box> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <sphere> <radius>0</radius> </sphere> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <mesh> <uri></uri> <submesh> <name>none</name> <center>0</center> </submesh> <scale>1 1 1</scale> </mesh> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <image> <uri></uri> <height>1</height> <granularity>1</granularity> <threshold>0</threshold> <scale>1</scale> </image> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <polyline> <height>1</height> </polyline> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> # Optional elements can also be created dynamically visual = create_sdf_element ( 'visual' ) print ( visual ) <visual name=\"visual\"> <geometry> <empty></empty> </geometry> </visual> visual . cast_shadows = True print ( visual ) <visual name=\"visual\"> <geometry> <empty></empty> </geometry> <cast_shadows>1</cast_shadows> </visual> visual . pose = [ 0 , 0.2 , 0 , 0 , 0 , 0 ] print ( visual ) <visual name=\"visual\"> <pose frame=\"\">0 0.2 0 0 0 0</pose> <geometry> <empty></empty> </geometry> <cast_shadows>1</cast_shadows> </visual> # The geometry entity can be set with a dictionary with all the child parameters visual . geometry . box = dict ( size = [ 2 , 3 , 4 ]) print ( visual ) <visual name=\"visual\"> <pose frame=\"\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> <cast_shadows>1</cast_shadows> </visual> # The pose, as other variables, can be set using a dictionary # For SDF elements with no child elements, only values, the dictionary must always have a key 'value' # d = {value=[0, 0, 0, 0, 0, 0]} # If the element contains attributes, as the attribute 'frame' in the element 'pose', there should be a key # 'attributes' with a dictionary containing all the attributes # d = {value=[0, 0, 0, 0, 0, 0], attributes=dict(frame='new_frame')} visual . pose = { 'value' : [ 0 , 0.2 , 0 , 0 , 0 , 0 ], 'attributes' : { 'frame' : 'new_frame' }} print ( visual ) <visual name=\"visual\"> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> <cast_shadows>1</cast_shadows> </visual>","title":"Visuals"},{"location":"tutorials/parsers/sdf/visuals/#visuals","text":"The < visual > element specifies the shape of the geometry for rendering. It is a child element from < link > and a link can have multiple visual elements. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The visual element is created with an empty geometry by default visual = create_sdf_element ( 'visual' ) print ( visual ) <visual name=\"visual\"> <geometry> <empty></empty> </geometry> </visual> # To see the optional elements, use the method reset() visual . reset ( with_optional_elements = True ) print ( visual ) <visual name=\"visual\"> <pose frame=\"\">0 0 0 0 0 0</pose> <geometry> <empty></empty> </geometry> <transparency>0</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> # Setting the parameters for the visual element # Each visual in a link should have an unique name visual . name = 'custom_visual' # If cast_shadows is true, the geometry will cast shadows visual . cast_shadows = True # The transparency is a double in the range of [0, 1], 0 being opaque and 1 fully transparent visual . transparency = 0.2 # Pose of the visual geometry with respect to a frame visual . pose = [ 0 , 0.2 , 0 , 0 , 0 , 0 ] visual . pose . frame = 'base_link' print ( visual ) <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <empty></empty> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> # Setting different geometries to the visual element visual . geometry . box = create_sdf_element ( 'box' ) print ( visual ) visual . geometry . sphere = create_sdf_element ( 'sphere' ) print ( visual ) visual . geometry . cylinder = create_sdf_element ( 'cylinder' ) print ( visual ) visual . geometry . plane = create_sdf_element ( 'plane' ) print ( visual ) visual . geometry . mesh = create_sdf_element ( 'mesh' ) visual . geometry . mesh . reset ( with_optional_elements = True ) print ( visual ) visual . geometry . image = create_sdf_element ( 'image' ) print ( visual ) visual . geometry . polyline = create_sdf_element ( 'polyline' ) print ( visual ) <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>0 0 0</size> </box> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <sphere> <radius>0</radius> </sphere> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <cylinder> <radius>0</radius> <length>0</length> </cylinder> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <plane> <size>0 0</size> <normal>0 0 1</normal> </plane> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <mesh> <uri></uri> <submesh> <name>none</name> <center>0</center> </submesh> <scale>1 1 1</scale> </mesh> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <image> <uri></uri> <height>1</height> <granularity>1</granularity> <threshold>0</threshold> <scale>1</scale> </image> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> <visual name=\"custom_visual\"> <pose frame=\"base_link\">0 0.2 0 0 0 0</pose> <geometry> <polyline> <height>1</height> </polyline> </geometry> <transparency>0.2</transparency> <cast_shadows>1</cast_shadows> <material> <specular>0.1 0.1 0.1 1</specular> <diffuse>0 0 0 1</diffuse> <shader type=\"pixel\"> <normal_map>default</normal_map> </shader> <emissive>0 0 0 1</emissive> <script> <uri>file://media/materials/scripts/gazebo.material</uri> <name>default</name> </script> <lighting>0</lighting> <ambient>0 0 0 1</ambient> </material> </visual> # Optional elements can also be created dynamically visual = create_sdf_element ( 'visual' ) print ( visual ) <visual name=\"visual\"> <geometry> <empty></empty> </geometry> </visual> visual . cast_shadows = True print ( visual ) <visual name=\"visual\"> <geometry> <empty></empty> </geometry> <cast_shadows>1</cast_shadows> </visual> visual . pose = [ 0 , 0.2 , 0 , 0 , 0 , 0 ] print ( visual ) <visual name=\"visual\"> <pose frame=\"\">0 0.2 0 0 0 0</pose> <geometry> <empty></empty> </geometry> <cast_shadows>1</cast_shadows> </visual> # The geometry entity can be set with a dictionary with all the child parameters visual . geometry . box = dict ( size = [ 2 , 3 , 4 ]) print ( visual ) <visual name=\"visual\"> <pose frame=\"\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> <cast_shadows>1</cast_shadows> </visual> # The pose, as other variables, can be set using a dictionary # For SDF elements with no child elements, only values, the dictionary must always have a key 'value' # d = {value=[0, 0, 0, 0, 0, 0]} # If the element contains attributes, as the attribute 'frame' in the element 'pose', there should be a key # 'attributes' with a dictionary containing all the attributes # d = {value=[0, 0, 0, 0, 0, 0], attributes=dict(frame='new_frame')} visual . pose = { 'value' : [ 0 , 0.2 , 0 , 0 , 0 , 0 ], 'attributes' : { 'frame' : 'new_frame' }} print ( visual ) <visual name=\"visual\"> <pose frame=\"new_frame\">0 0.2 0 0 0 0</pose> <geometry> <box> <size>2 3 4</size> </box> </geometry> <cast_shadows>1</cast_shadows> </visual>","title":"Visuals"},{"location":"tutorials/parsers/sdf/world/","text":"World \u00b6 The world element encapsulates an entire world description including: models, scene, physics, joints, and plugins. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The default world contains only the definition of the acceleration of gravity # and the default configuration of the physics engine using `ode` world = create_sdf_element ( 'world' ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> </world> # The physics engine can be edited using its object setter world . physics . reset ( mode = 'ode' , with_optional_elements = True ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <ode> <constraints> <cfm>0</cfm> <erp>0.2</erp> <contact_surface_layer>0.001</contact_surface_layer> <contact_max_correcting_vel>100</contact_max_correcting_vel> </constraints> <solver> <type>quick</type> <sor>1.3</sor> <use_dynamic_moi_scaling>0</use_dynamic_moi_scaling> <friction_model>pyramid_model</friction_model> <min_step_size>0.0001</min_step_size> <precon_iters>0</precon_iters> <iters>50</iters> </solver> </ode> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> </world> world . physics . reset ( mode = 'bullet' , with_optional_elements = True ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"bullet\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <bullet> <constraints> <cfm>0</cfm> <split_impulse>1</split_impulse> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <contact_surface_layer>0.001</contact_surface_layer> <erp>0.2</erp> </constraints> <solver> <type>quick</type> <sor>1.3</sor> <iters>50</iters> <min_step_size>0.0001</min_step_size> </solver> </bullet> <real_time_update_rate>1000</real_time_update_rate> <real_time_factor>1</real_time_factor> </physics> <gravity>0 0 -9.8</gravity> </world> world . physics . reset ( mode = 'simbody' , with_optional_elements = True ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"simbody\"> <max_contacts>20</max_contacts> <simbody> <accuracy>0.001</accuracy> <min_step_size>0.0001</min_step_size> <contact> <plastic_impact_velocity>0.5</plastic_impact_velocity> <plastic_coef_restitution>0.5</plastic_coef_restitution> <stiffness>100000000.0</stiffness> <dissipation>100</dissipation> <override_stiction_transition_velocity>0.001</override_stiction_transition_velocity> <viscous_friction>0</viscous_friction> <dynamic_friction>0.9</dynamic_friction> <static_friction>0.9</static_friction> <override_impact_capture_velocity>0.001</override_impact_capture_velocity> </contact> <max_transient_velocity>0.01</max_transient_velocity> </simbody> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> </world> # A world can contain multiple models, add an empty model by using the add_model method world . reset () world . add_model ( 'model_1' ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> <model name=\"model_1\"/> </world> # You can add a model to the world as well model = create_sdf_element ( 'model' ) world . add_model ( 'model_2' , model ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> <model name=\"model_1\"/> <model name=\"model_2\"/> </world> # You must have unique names for the models in a world world . add_model ( 'model_1' ) Model element with name model_1 already exists","title":"World"},{"location":"tutorials/parsers/sdf/world/#world","text":"The world element encapsulates an entire world description including: models, scene, physics, joints, and plugins. # Import the element creator from pcg_gazebo.parsers.sdf import create_sdf_element # The default world contains only the definition of the acceleration of gravity # and the default configuration of the physics engine using `ode` world = create_sdf_element ( 'world' ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> </world> # The physics engine can be edited using its object setter world . physics . reset ( mode = 'ode' , with_optional_elements = True ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <ode> <constraints> <cfm>0</cfm> <erp>0.2</erp> <contact_surface_layer>0.001</contact_surface_layer> <contact_max_correcting_vel>100</contact_max_correcting_vel> </constraints> <solver> <type>quick</type> <sor>1.3</sor> <use_dynamic_moi_scaling>0</use_dynamic_moi_scaling> <friction_model>pyramid_model</friction_model> <min_step_size>0.0001</min_step_size> <precon_iters>0</precon_iters> <iters>50</iters> </solver> </ode> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> </world> world . physics . reset ( mode = 'bullet' , with_optional_elements = True ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"bullet\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <bullet> <constraints> <cfm>0</cfm> <split_impulse>1</split_impulse> <split_impulse_penetration_threshold>-0.01</split_impulse_penetration_threshold> <contact_surface_layer>0.001</contact_surface_layer> <erp>0.2</erp> </constraints> <solver> <type>quick</type> <sor>1.3</sor> <iters>50</iters> <min_step_size>0.0001</min_step_size> </solver> </bullet> <real_time_update_rate>1000</real_time_update_rate> <real_time_factor>1</real_time_factor> </physics> <gravity>0 0 -9.8</gravity> </world> world . physics . reset ( mode = 'simbody' , with_optional_elements = True ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"simbody\"> <max_contacts>20</max_contacts> <simbody> <accuracy>0.001</accuracy> <min_step_size>0.0001</min_step_size> <contact> <plastic_impact_velocity>0.5</plastic_impact_velocity> <plastic_coef_restitution>0.5</plastic_coef_restitution> <stiffness>100000000.0</stiffness> <dissipation>100</dissipation> <override_stiction_transition_velocity>0.001</override_stiction_transition_velocity> <viscous_friction>0</viscous_friction> <dynamic_friction>0.9</dynamic_friction> <static_friction>0.9</static_friction> <override_impact_capture_velocity>0.001</override_impact_capture_velocity> </contact> <max_transient_velocity>0.01</max_transient_velocity> </simbody> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> </world> # A world can contain multiple models, add an empty model by using the add_model method world . reset () world . add_model ( 'model_1' ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> <model name=\"model_1\"/> </world> # You can add a model to the world as well model = create_sdf_element ( 'model' ) world . add_model ( 'model_2' , model ) print ( world ) <world name=\"default\"> <physics default=\"1\" name=\"default_physics\" type=\"ode\"> <max_contacts>20</max_contacts> <max_step_size>0.001</max_step_size> <real_time_factor>1</real_time_factor> <real_time_update_rate>1000</real_time_update_rate> </physics> <gravity>0 0 -9.8</gravity> <model name=\"model_1\"/> <model name=\"model_2\"/> </world> # You must have unique names for the models in a world world . add_model ( 'model_1' ) Model element with name model_1 already exists","title":"World"},{"location":"tutorials/parsers/urdf/","text":"ROS applications make use of the URDF format for the robot description. This package includes a parsers also for URDF to make it possible to improve the cross-conversion to and from SDF regarding various simulation-specific tags that will mostly be parsed only for the ODE physics engine at the moment.","title":"Introduction"},{"location":"tutorials/parsers/urdf/collision/","text":"Collision \u00b6 The collision properties of a link. Note that this can be different from the visual properties of a link, for example, simpler collision models are often used to reduce computation time. This is a child element of < link > and a link can have multiple collisions. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element # The collision element is created with an empty geometry by default collision = create_urdf_element ( 'collision' ) print ( collision ) # Setting the parameters for the visual element collision . origin . xyz = [ 1 , 0 , 1 ] collision . origin . rpy = [ 0.2 , 0 , 0.6 ] print ( collision ) # Setting different geometries to the visual element collision . geometry . box = create_urdf_element ( 'box' ) print ( collision ) collision . geometry . sphere = create_urdf_element ( 'sphere' ) print ( collision ) collision . geometry . cylinder = create_urdf_element ( 'cylinder' ) print ( collision ) collision . geometry . mesh = create_urdf_element ( 'mesh' ) print ( collision )","title":"Collisions"},{"location":"tutorials/parsers/urdf/collision/#collision","text":"The collision properties of a link. Note that this can be different from the visual properties of a link, for example, simpler collision models are often used to reduce computation time. This is a child element of < link > and a link can have multiple collisions. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element # The collision element is created with an empty geometry by default collision = create_urdf_element ( 'collision' ) print ( collision ) # Setting the parameters for the visual element collision . origin . xyz = [ 1 , 0 , 1 ] collision . origin . rpy = [ 0.2 , 0 , 0.6 ] print ( collision ) # Setting different geometries to the visual element collision . geometry . box = create_urdf_element ( 'box' ) print ( collision ) collision . geometry . sphere = create_urdf_element ( 'sphere' ) print ( collision ) collision . geometry . cylinder = create_urdf_element ( 'cylinder' ) print ( collision ) collision . geometry . mesh = create_urdf_element ( 'mesh' ) print ( collision )","title":"Collision"},{"location":"tutorials/parsers/urdf/geometries/","text":"Geometries \u00b6 Geometry entities are child elements of < visual > or < collision > elements. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element Basic entities \u00b6 Demonstration of the basic URDF elements that can be generated with and without the optional parameters. Geometries \u00b6 Box \u00b6 # Default box box = create_urdf_element ( 'box' ) print ( 'Default box' ) print ( box ) print ( 'Default box - as dict' ) print ( box . to_dict ()) print ( 'Default box - as URDF' ) print ( box . to_xml_as_str ()) # Changing the size box . size = [ 2 , 3 , 4 ] print ( 'Custom box' ) print ( box ) # Exporting # box.export_xml('/tmp/box.urdf') Cylinder \u00b6 # Default cylinder cylinder = create_urdf_element ( 'cylinder' ) print ( 'Default cylinder' ) print ( cylinder ) print ( 'Default cylinder - as dict' ) print ( cylinder . to_dict ()) print ( 'Default cylinder - as URDF' ) print ( cylinder . to_xml_as_str ()) # Changing the parameters cylinder . radius = 2 cylinder . length = 3 print ( 'Custom cylinder' ) print ( cylinder ) # Exporting # cylinder.export_xml('/tmp/cylinder.urdf') Sphere \u00b6 # Default sphere sphere = create_urdf_element ( 'sphere' ) print ( 'Default sphere' ) print ( sphere ) print ( 'Default sphere - as dict' ) print ( sphere . to_dict ()) print ( 'Default sphere - as URDF' ) print ( sphere . to_xml_as_str ()) # Changing the parameters sphere . radius = 2 print ( 'Custom sphere' ) print ( sphere ) # Exporting # sphere.export_xml('/tmp/sphere.urdf') Mesh \u00b6 mesh = create_urdf_element ( 'mesh' ) print ( 'Default mesh - with default parameters' ) print ( mesh ) print ( 'Default mesh - as dict' ) print ( mesh . to_dict ()) print ( 'Default mesh - as URDF' ) print ( mesh . to_xml_as_str ()) # Changing the parameters mesh . filename = 'package://mesh.dae' print ( 'Custom mesh' ) print ( mesh ) # Exporting # mesh.export_xml('/tmp/mesh.urdf') Creating a geometry entity \u00b6 # Initially, the geometry is created with a <box/> element geometry = create_urdf_element ( 'geometry' ) print ( geometry ) # Creating a geometry for each of the basic forms # The geometry entity has a separate mode for each possible geometry forms, since it cannot hold # multiple geometries # When a new geometry is set, the former one is deleted print ( 'All the geometry entity modes:' ) print ( geometry . get_modes ()) geometry . box = box print ( geometry ) geometry . cylinder = cylinder print ( geometry ) geometry . sphere = sphere print ( geometry ) geometry . mesh = mesh print ( geometry )","title":"Geometries"},{"location":"tutorials/parsers/urdf/geometries/#geometries","text":"Geometry entities are child elements of < visual > or < collision > elements. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element","title":"Geometries"},{"location":"tutorials/parsers/urdf/geometries/#basic-entities","text":"Demonstration of the basic URDF elements that can be generated with and without the optional parameters.","title":"Basic entities"},{"location":"tutorials/parsers/urdf/geometries/#geometries_1","text":"","title":"Geometries"},{"location":"tutorials/parsers/urdf/geometries/#box","text":"# Default box box = create_urdf_element ( 'box' ) print ( 'Default box' ) print ( box ) print ( 'Default box - as dict' ) print ( box . to_dict ()) print ( 'Default box - as URDF' ) print ( box . to_xml_as_str ()) # Changing the size box . size = [ 2 , 3 , 4 ] print ( 'Custom box' ) print ( box ) # Exporting # box.export_xml('/tmp/box.urdf')","title":"Box"},{"location":"tutorials/parsers/urdf/geometries/#cylinder","text":"# Default cylinder cylinder = create_urdf_element ( 'cylinder' ) print ( 'Default cylinder' ) print ( cylinder ) print ( 'Default cylinder - as dict' ) print ( cylinder . to_dict ()) print ( 'Default cylinder - as URDF' ) print ( cylinder . to_xml_as_str ()) # Changing the parameters cylinder . radius = 2 cylinder . length = 3 print ( 'Custom cylinder' ) print ( cylinder ) # Exporting # cylinder.export_xml('/tmp/cylinder.urdf')","title":"Cylinder"},{"location":"tutorials/parsers/urdf/geometries/#sphere","text":"# Default sphere sphere = create_urdf_element ( 'sphere' ) print ( 'Default sphere' ) print ( sphere ) print ( 'Default sphere - as dict' ) print ( sphere . to_dict ()) print ( 'Default sphere - as URDF' ) print ( sphere . to_xml_as_str ()) # Changing the parameters sphere . radius = 2 print ( 'Custom sphere' ) print ( sphere ) # Exporting # sphere.export_xml('/tmp/sphere.urdf')","title":"Sphere"},{"location":"tutorials/parsers/urdf/geometries/#mesh","text":"mesh = create_urdf_element ( 'mesh' ) print ( 'Default mesh - with default parameters' ) print ( mesh ) print ( 'Default mesh - as dict' ) print ( mesh . to_dict ()) print ( 'Default mesh - as URDF' ) print ( mesh . to_xml_as_str ()) # Changing the parameters mesh . filename = 'package://mesh.dae' print ( 'Custom mesh' ) print ( mesh ) # Exporting # mesh.export_xml('/tmp/mesh.urdf')","title":"Mesh"},{"location":"tutorials/parsers/urdf/geometries/#creating-a-geometry-entity","text":"# Initially, the geometry is created with a <box/> element geometry = create_urdf_element ( 'geometry' ) print ( geometry ) # Creating a geometry for each of the basic forms # The geometry entity has a separate mode for each possible geometry forms, since it cannot hold # multiple geometries # When a new geometry is set, the former one is deleted print ( 'All the geometry entity modes:' ) print ( geometry . get_modes ()) geometry . box = box print ( geometry ) geometry . cylinder = cylinder print ( geometry ) geometry . sphere = sphere print ( geometry ) geometry . mesh = mesh print ( geometry )","title":"Creating a geometry entity"},{"location":"tutorials/parsers/urdf/links_joints_sensors/","text":"Links, joints and sensors \u00b6 Links \u00b6 A physical link in the simulation contains inertia, collision and visual properties. A link must be a child of a robot and a robot can have multiple links. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element # The link is empty by default link = create_urdf_element ( 'link' ) print ( link ) # By using reset(), it is possible to see the optional elements of a link link . reset ( with_optional_elements = True ) print ( link ) # Let's create the elements dynamically at first link = create_urdf_element ( 'link' ) # The link's name must be unique in a model link . name = 'base_link' print ( link ) # Mass of the link in kg link . mass = 30 # The center of mass are the cartesian coordinates in link.inertial.pose link . origin = create_urdf_element ( 'origin' ) link . origin . xyz = [ 0 , 10 , 0 ] # The moments of inertia describe the elements of the 3x3 rotational inertial matrix link . inertia . ixx = 0.5 link . inertia . iyy = 0.5 link . inertia . izz = 0.5 print ( link ) Joints \u00b6 # The joint is empty by default joint = create_urdf_element ( 'joint' ) print ( joint ) # By using reset(), it is possible to see the optional elements of a joint joint . reset ( with_optional_elements = True ) print ( joint )","title":"Links, joints and sensors"},{"location":"tutorials/parsers/urdf/links_joints_sensors/#links-joints-and-sensors","text":"","title":"Links, joints and sensors"},{"location":"tutorials/parsers/urdf/links_joints_sensors/#links","text":"A physical link in the simulation contains inertia, collision and visual properties. A link must be a child of a robot and a robot can have multiple links. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element # The link is empty by default link = create_urdf_element ( 'link' ) print ( link ) # By using reset(), it is possible to see the optional elements of a link link . reset ( with_optional_elements = True ) print ( link ) # Let's create the elements dynamically at first link = create_urdf_element ( 'link' ) # The link's name must be unique in a model link . name = 'base_link' print ( link ) # Mass of the link in kg link . mass = 30 # The center of mass are the cartesian coordinates in link.inertial.pose link . origin = create_urdf_element ( 'origin' ) link . origin . xyz = [ 0 , 10 , 0 ] # The moments of inertia describe the elements of the 3x3 rotational inertial matrix link . inertia . ixx = 0.5 link . inertia . iyy = 0.5 link . inertia . izz = 0.5 print ( link )","title":"Links"},{"location":"tutorials/parsers/urdf/links_joints_sensors/#joints","text":"# The joint is empty by default joint = create_urdf_element ( 'joint' ) print ( joint ) # By using reset(), it is possible to see the optional elements of a joint joint . reset ( with_optional_elements = True ) print ( joint )","title":"Joints"},{"location":"tutorials/parsers/urdf/robots/","text":"Robots \u00b6 # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element robot = create_urdf_element ( 'robot' ) print ( robot ) robot . reset ( with_optional_elements = True ) print ( robot )","title":"Robots"},{"location":"tutorials/parsers/urdf/robots/#robots","text":"# Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element robot = create_urdf_element ( 'robot' ) print ( robot ) robot . reset ( with_optional_elements = True ) print ( robot )","title":"Robots"},{"location":"tutorials/parsers/urdf/visual/","text":"Visuals \u00b6 The < visual > element specifies the shape of the geometry for rendering. It is a child element from < link > and a link can have multiple visual elements. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element # The visual element is created with an empty geometry by default visual = create_urdf_element ( 'visual' ) print ( visual ) # Setting the parameters for the visual element visual . origin . xyz = [ 1 , 0 , 1 ] visual . origin . rpy = [ 0.2 , 0 , 0.6 ] print ( visual ) # Setting different geometries to the visual element visual . geometry . box = create_urdf_element ( 'box' ) print ( visual ) visual . geometry . sphere = create_urdf_element ( 'sphere' ) print ( visual ) visual . geometry . cylinder = create_urdf_element ( 'cylinder' ) print ( visual ) visual . geometry . mesh = create_urdf_element ( 'mesh' ) print ( visual )","title":"Visuals"},{"location":"tutorials/parsers/urdf/visual/#visuals","text":"The < visual > element specifies the shape of the geometry for rendering. It is a child element from < link > and a link can have multiple visual elements. # Import the element creator from pcg_gazebo.parsers.urdf import create_urdf_element # The visual element is created with an empty geometry by default visual = create_urdf_element ( 'visual' ) print ( visual ) # Setting the parameters for the visual element visual . origin . xyz = [ 1 , 0 , 1 ] visual . origin . rpy = [ 0.2 , 0 , 0.6 ] print ( visual ) # Setting different geometries to the visual element visual . geometry . box = create_urdf_element ( 'box' ) print ( visual ) visual . geometry . sphere = create_urdf_element ( 'sphere' ) print ( visual ) visual . geometry . cylinder = create_urdf_element ( 'cylinder' ) print ( visual ) visual . geometry . mesh = create_urdf_element ( 'mesh' ) print ( visual )","title":"Visuals"},{"location":"tutorials/simulation/building_a_model/","text":"Models \u00b6 from pcg_gazebo.simulation import create_object , SimulationModel # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) Mobile base tutorial \u00b6 Recreating the Gazebo tutorial for a mobile base # Creating the main body of the chassis chassis = create_object ( 'box' ) chassis . size = [ 2 , 1 , 0.3 ] chassis . add_inertial ( 20 ) chassis . visual . enable_property ( 'material' ) chassis . visual . set_xkcd_color () print ( chassis . to_sdf ( 'link' )) # Creating the caster wheel caster_wheel = create_object ( 'sphere' ) caster_wheel . radius = 0.125 caster_wheel . add_inertial ( 1 ) caster_wheel . visual . enable_property ( 'material' ) caster_wheel . visual . set_xkcd_color () # Setting friction parameters to zero caster_wheel . collision . enable_property ( 'friction' ) caster_wheel . collision . set_ode_friction_params ( mu = 0.0 , mu2 = 0.0 , slip1 = 0 , slip2 = 0 , fdir1 = [ 0 , 0 , 0 ] ) caster_wheel . collision . set_bullet_friction_params ( friction = 0.0 , friction2 = 0.0 , fdir1 = [ 0 , 0 , 0 ], rolling_friction = 1 ) print ( caster_wheel . to_sdf ( 'link' )) right_wheel = create_object ( 'cylinder' ) right_wheel . pose = [ 0.8 , - 0.5 - 0.025 , - 0.125 , 0 , 1.5707 , 1.5707 ] right_wheel . radius = 0.125 right_wheel . length = 0.05 right_wheel . add_inertial ( 1 ) right_wheel . visual . enable_property ( 'material' ) right_wheel . visual . set_xkcd_color () left_wheel = create_object ( 'cylinder' ) left_wheel . pose = [ 0.8 , 0.5 + 0.025 , - 0.125 , 0 , 1.5707 , 1.5707 ] left_wheel . radius = 0.125 left_wheel . length = 0.05 left_wheel . add_inertial ( 1 ) left_wheel . visual . enable_property ( 'material' ) left_wheel . visual . set_xkcd_color () print ( right_wheel . to_sdf ( 'link' )) # Assembling the robot mobile base mobile_base = SimulationModel ( 'mobile_base' ) # Adding chassis mobile_base . add_link ( 'chassis' , chassis ) # Adding caster wheel caster_wheel . pose = [ - 0.8 , 0 , - 0.125 , 0 , 0 , 0 ] mobile_base . add_link ( 'caster_wheel' , caster_wheel ) mobile_base . add_joint ( 'caster_wheel_joint' , parent = 'chassis' , child = 'caster_wheel' , joint_type = 'fixed' ) # Adding left wheel mobile_base . add_link ( 'left_wheel' , left_wheel ) mobile_base . add_joint ( 'left_wheel_joint' , parent = 'chassis' , child = 'left_wheel' , joint_type = 'revolute' ) # Adding right wheel mobile_base . add_link ( 'right_wheel' , right_wheel ) mobile_base . add_joint ( 'right_wheel_joint' , parent = 'chassis' , child = 'right_wheel' , joint_type = 'revolute' ) print ( mobile_base . to_sdf ()) print ( mobile_base . to_urdf ()) # Spawn model generator . spawn_model ( model = mobile_base , robot_namespace = 'mobile_base' , pos = [ 0 , 0 , 0.5 ])","title":"Building a model"},{"location":"tutorials/simulation/building_a_model/#models","text":"from pcg_gazebo.simulation import create_object , SimulationModel # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy )","title":"Models"},{"location":"tutorials/simulation/building_a_model/#mobile-base-tutorial","text":"Recreating the Gazebo tutorial for a mobile base # Creating the main body of the chassis chassis = create_object ( 'box' ) chassis . size = [ 2 , 1 , 0.3 ] chassis . add_inertial ( 20 ) chassis . visual . enable_property ( 'material' ) chassis . visual . set_xkcd_color () print ( chassis . to_sdf ( 'link' )) # Creating the caster wheel caster_wheel = create_object ( 'sphere' ) caster_wheel . radius = 0.125 caster_wheel . add_inertial ( 1 ) caster_wheel . visual . enable_property ( 'material' ) caster_wheel . visual . set_xkcd_color () # Setting friction parameters to zero caster_wheel . collision . enable_property ( 'friction' ) caster_wheel . collision . set_ode_friction_params ( mu = 0.0 , mu2 = 0.0 , slip1 = 0 , slip2 = 0 , fdir1 = [ 0 , 0 , 0 ] ) caster_wheel . collision . set_bullet_friction_params ( friction = 0.0 , friction2 = 0.0 , fdir1 = [ 0 , 0 , 0 ], rolling_friction = 1 ) print ( caster_wheel . to_sdf ( 'link' )) right_wheel = create_object ( 'cylinder' ) right_wheel . pose = [ 0.8 , - 0.5 - 0.025 , - 0.125 , 0 , 1.5707 , 1.5707 ] right_wheel . radius = 0.125 right_wheel . length = 0.05 right_wheel . add_inertial ( 1 ) right_wheel . visual . enable_property ( 'material' ) right_wheel . visual . set_xkcd_color () left_wheel = create_object ( 'cylinder' ) left_wheel . pose = [ 0.8 , 0.5 + 0.025 , - 0.125 , 0 , 1.5707 , 1.5707 ] left_wheel . radius = 0.125 left_wheel . length = 0.05 left_wheel . add_inertial ( 1 ) left_wheel . visual . enable_property ( 'material' ) left_wheel . visual . set_xkcd_color () print ( right_wheel . to_sdf ( 'link' )) # Assembling the robot mobile base mobile_base = SimulationModel ( 'mobile_base' ) # Adding chassis mobile_base . add_link ( 'chassis' , chassis ) # Adding caster wheel caster_wheel . pose = [ - 0.8 , 0 , - 0.125 , 0 , 0 , 0 ] mobile_base . add_link ( 'caster_wheel' , caster_wheel ) mobile_base . add_joint ( 'caster_wheel_joint' , parent = 'chassis' , child = 'caster_wheel' , joint_type = 'fixed' ) # Adding left wheel mobile_base . add_link ( 'left_wheel' , left_wheel ) mobile_base . add_joint ( 'left_wheel_joint' , parent = 'chassis' , child = 'left_wheel' , joint_type = 'revolute' ) # Adding right wheel mobile_base . add_link ( 'right_wheel' , right_wheel ) mobile_base . add_joint ( 'right_wheel_joint' , parent = 'chassis' , child = 'right_wheel' , joint_type = 'revolute' ) print ( mobile_base . to_sdf ()) print ( mobile_base . to_urdf ()) # Spawn model generator . spawn_model ( model = mobile_base , robot_namespace = 'mobile_base' , pos = [ 0 , 0 , 0.5 ])","title":"Mobile base tutorial"},{"location":"tutorials/simulation/materials/","text":"Visual properties \u00b6 from pcg_gazebo.simulation import create_object from pcg_gazebo.generators import WorldGenerator from time import sleep import random # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () Transparency \u00b6 obj = create_object ( 'box' ) obj . size = [ 1 , 1 , 1 ] obj . add_inertial ( 30 ) # Print the initial state of a box in the model option print ( obj . to_sdf ( 'model' )) obj . visual . transparency = 0.8 print ( obj . to_sdf ( 'model' )) # Create a simulation manager named default server . create_simulation ( 'transparency' ) simulation = server . get_simulation ( 'transparency' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) t = [ 0.1 , 0.3 , 0.5 , 0.7 , 1.0 ] for i in range ( len ( t )): obj . visual . transparency = t [ i ] generator . spawn_model ( model = obj , robot_namespace = 'box_transparency_{}' . format ( t [ i ]), pos = [ 0 , i * 1.5 , 2 ]) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks () Gazebo materials \u00b6 from pcg_gazebo.simulation.properties import Material # Find and retrieve all the default Gazebo materials print ( Material . _GAZEBO_MATERIALS ) print ( Material . get_gazebo_material_as_sdf ( 'Gazebo/PurpleGlow' )) # Create a simulation manager named default server . create_simulation ( 'gazebo_materials' ) simulation = server . get_simulation ( 'gazebo_materials' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) box = create_object ( 'box' ) box . size = [ 1 , 1 , 1 ] box . add_inertial ( 30 ) box . static = True box . visual . enable_property ( 'material' ) sphere = create_object ( 'sphere' ) sphere . radius = 0.5 sphere . add_inertial ( 30 ) sphere . static = True sphere . visual . enable_property ( 'material' ) for i in range ( len ( Material . _GAZEBO_MATERIALS )): box . visual . set_material_script ( Material . _GAZEBO_MATERIALS [ i ]) sphere . visual . set_material_script ( Material . _GAZEBO_MATERIALS [ i ]) color_name = Material . _GAZEBO_MATERIALS [ i ] . split ( '/' )[ - 1 ] . lower () generator . spawn_model ( model = box , robot_namespace = 'box_{}' . format ( color_name ), pos = [ 0 , i * 1.5 , 0.5 ]) generator . spawn_model ( model = sphere , robot_namespace = 'sphere_{}' . format ( color_name ), pos = [ 2.0 , i * 1.5 , 0.5 ]) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks () XKCD color pallete \u00b6 # Retrieve all XKCD pallete colors print ( Material . get_xkcd_colors_list ()) # Create a simulation manager named default server . create_simulation ( 'xkcd' ) simulation = server . get_simulation ( 'xkcd' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) box = create_object ( 'box' ) box . size = [ 1 , 1 , 1 ] box . add_inertial ( 30 ) box . static = True box . visual . enable_property ( 'material' ) sphere = create_object ( 'sphere' ) sphere . radius = 0.5 sphere . add_inertial ( 30 ) sphere . static = True sphere . visual . enable_property ( 'material' ) xkcd_colors = Material . get_xkcd_colors_list () for i , tag in zip ( range ( len ( xkcd_colors )), xkcd_colors . keys ()): if i > 50 : break # By omiting the name of the color, the material # instance will generate a random color box . visual . set_xkcd_color ( tag ) sphere . visual . set_xkcd_color ( tag ) generator . spawn_model ( model = box , robot_namespace = 'box_{}' . format ( tag ), pos = [ 0 , i * 1.5 , 0.5 ]) generator . spawn_model ( model = sphere , robot_namespace = 'sphere_{}' . format ( tag ), pos = [ 2.0 , i * 1.5 , 0.5 ]) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks ()","title":"Materials"},{"location":"tutorials/simulation/materials/#visual-properties","text":"from pcg_gazebo.simulation import create_object from pcg_gazebo.generators import WorldGenerator from time import sleep import random # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server ()","title":"Visual properties"},{"location":"tutorials/simulation/materials/#transparency","text":"obj = create_object ( 'box' ) obj . size = [ 1 , 1 , 1 ] obj . add_inertial ( 30 ) # Print the initial state of a box in the model option print ( obj . to_sdf ( 'model' )) obj . visual . transparency = 0.8 print ( obj . to_sdf ( 'model' )) # Create a simulation manager named default server . create_simulation ( 'transparency' ) simulation = server . get_simulation ( 'transparency' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) t = [ 0.1 , 0.3 , 0.5 , 0.7 , 1.0 ] for i in range ( len ( t )): obj . visual . transparency = t [ i ] generator . spawn_model ( model = obj , robot_namespace = 'box_transparency_{}' . format ( t [ i ]), pos = [ 0 , i * 1.5 , 2 ]) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks ()","title":"Transparency"},{"location":"tutorials/simulation/materials/#gazebo-materials","text":"from pcg_gazebo.simulation.properties import Material # Find and retrieve all the default Gazebo materials print ( Material . _GAZEBO_MATERIALS ) print ( Material . get_gazebo_material_as_sdf ( 'Gazebo/PurpleGlow' )) # Create a simulation manager named default server . create_simulation ( 'gazebo_materials' ) simulation = server . get_simulation ( 'gazebo_materials' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) box = create_object ( 'box' ) box . size = [ 1 , 1 , 1 ] box . add_inertial ( 30 ) box . static = True box . visual . enable_property ( 'material' ) sphere = create_object ( 'sphere' ) sphere . radius = 0.5 sphere . add_inertial ( 30 ) sphere . static = True sphere . visual . enable_property ( 'material' ) for i in range ( len ( Material . _GAZEBO_MATERIALS )): box . visual . set_material_script ( Material . _GAZEBO_MATERIALS [ i ]) sphere . visual . set_material_script ( Material . _GAZEBO_MATERIALS [ i ]) color_name = Material . _GAZEBO_MATERIALS [ i ] . split ( '/' )[ - 1 ] . lower () generator . spawn_model ( model = box , robot_namespace = 'box_{}' . format ( color_name ), pos = [ 0 , i * 1.5 , 0.5 ]) generator . spawn_model ( model = sphere , robot_namespace = 'sphere_{}' . format ( color_name ), pos = [ 2.0 , i * 1.5 , 0.5 ]) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks ()","title":"Gazebo materials"},{"location":"tutorials/simulation/materials/#xkcd-color-pallete","text":"# Retrieve all XKCD pallete colors print ( Material . get_xkcd_colors_list ()) # Create a simulation manager named default server . create_simulation ( 'xkcd' ) simulation = server . get_simulation ( 'xkcd' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) box = create_object ( 'box' ) box . size = [ 1 , 1 , 1 ] box . add_inertial ( 30 ) box . static = True box . visual . enable_property ( 'material' ) sphere = create_object ( 'sphere' ) sphere . radius = 0.5 sphere . add_inertial ( 30 ) sphere . static = True sphere . visual . enable_property ( 'material' ) xkcd_colors = Material . get_xkcd_colors_list () for i , tag in zip ( range ( len ( xkcd_colors )), xkcd_colors . keys ()): if i > 50 : break # By omiting the name of the color, the material # instance will generate a random color box . visual . set_xkcd_color ( tag ) sphere . visual . set_xkcd_color ( tag ) generator . spawn_model ( model = box , robot_namespace = 'box_{}' . format ( tag ), pos = [ 0 , i * 1.5 , 0.5 ]) generator . spawn_model ( model = sphere , robot_namespace = 'sphere_{}' . format ( tag ), pos = [ 2.0 , i * 1.5 , 0.5 ]) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks ()","title":"XKCD color pallete"},{"location":"tutorials/simulation/meshes/","text":"% matplotlib inline import trimesh from matplotlib import pyplot as plt from pcg_gazebo.simulation.properties import Mesh from pcg_gazebo.simulation import create_object , SimulationModel Box \u00b6 # Create model model = SimulationModel ( 'box' ) # Create box link model . add_cuboid_link ( 'box' , mass = 0.1 , size = [ 2 , 1.2 , 3 ]) print ( model . to_sdf ( 'model' )) scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show () # Set random orientation and plot footprints again model . set_random_orientation () scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show () Cylinder \u00b6 # Create model model = SimulationModel ( 'cylinder' ) # Create box link model . add_cylindrical_link ( 'cylinder' , mass = 0.1 , radius = 0.3 , length = 1 ) print ( model . to_sdf ( 'model' )) scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show () # Set random orientation and plot footprints again model . set_random_orientation () scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.1 , 0.1 ]) plt . show () Custom mesh \u00b6 model = SimulationModel . from_gazebo_model ( 'jersey_barrier' ) print ( model . to_sdf ( 'model' )) scene = model . create_scene ( mesh_type = 'collision' ) #scene.show() fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 , z_limits = [ 0.5 , 0.7 ]) plt . show () # Set random orientation and plot footprints again model . set_random_orientation () print ( model . pose ) scene = model . create_scene ( mesh_type = 'collision' ) #scene.show() fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show ()","title":"Meshes"},{"location":"tutorials/simulation/meshes/#box","text":"# Create model model = SimulationModel ( 'box' ) # Create box link model . add_cuboid_link ( 'box' , mass = 0.1 , size = [ 2 , 1.2 , 3 ]) print ( model . to_sdf ( 'model' )) scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show () # Set random orientation and plot footprints again model . set_random_orientation () scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show ()","title":"Box"},{"location":"tutorials/simulation/meshes/#cylinder","text":"# Create model model = SimulationModel ( 'cylinder' ) # Create box link model . add_cylindrical_link ( 'cylinder' , mass = 0.1 , radius = 0.3 , length = 1 ) print ( model . to_sdf ( 'model' )) scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show () # Set random orientation and plot footprints again model . set_random_orientation () scene = model . create_scene () #scene.show() fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( fig_width = 5 , fig_height = 5 , z_limits = [ - 0.1 , 0.1 ]) plt . show ()","title":"Cylinder"},{"location":"tutorials/simulation/meshes/#custom-mesh","text":"model = SimulationModel . from_gazebo_model ( 'jersey_barrier' ) print ( model . to_sdf ( 'model' )) scene = model . create_scene ( mesh_type = 'collision' ) #scene.show() fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 , z_limits = [ 0.5 , 0.7 ]) plt . show () # Set random orientation and plot footprints again model . set_random_orientation () print ( model . pose ) scene = model . create_scene ( mesh_type = 'collision' ) #scene.show() fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 ) plt . show () fig = model . plot_footprint ( mesh_type = 'collision' , fig_width = 5 , fig_height = 5 , z_limits = [ - 0.2 , 0.2 ]) plt . show ()","title":"Custom mesh"},{"location":"tutorials/simulation/model_generator/","text":"Model generator \u00b6 from pcg_gazebo.generators.creators import create_models_from_config from pcg_gazebo.task_manager import Server from pcg_gazebo.generators import WorldGenerator import random # Start an empty world Gazebo simulation server = Server () server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) simulation . create_gazebo_empty_world_task () print ( simulation . get_task_list ()) print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance # running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) def create_and_spawn ( config ): models = create_models_from_config ( config ) for model in models : generator . spawn_model ( model = model , robot_namespace = model . name , pos = [ 20 * random . random () - 10 , 20 * random . random () - 10 , 2 * random . random ()]) Box-shaped models \u00b6 Creating box models \u00b6 config = [ dict ( type = 'box' , args = dict ( size = [ 2 , 2 , 2 ], mass = 10 , name = 'box' , pose = [ 0 , 0 , 1 , 0 , 0 , 0 ], color = 'random' ) ) ] create_and_spawn ( config ) Creating multiple boxes models using fixed arguments \u00b6 config = [ dict ( type = 'box_factory' , args = dict ( size = [ [ 0.1 , 0.4 , 0.5 ], [ 1 , 2 , 3 ] ], name = 'box_static_var_size' , use_permutation = True , color = 'xkcd' ) ), dict ( type = 'box_factory' , args = dict ( size = [ [ 0.1 , 0.4 , 0.5 ], [ 1 , 2 , 3 ] ], mass = 12 , name = 'box_dynamic_var_size' , use_permutation = False , color = 'xkcd' ) ), dict ( type = 'box_factory' , args = dict ( size = [ [ 0.2 , 0.4 , 0.15 ], [ 1.2 , 0.25 , 0.7 ] ], mass = [ 5 , 2 ], name = 'box_dynamic_permutate_size_mass' , use_permutation = True , color = 'xkcd' ) ) ] create_and_spawn ( config ) Creating multiple boxes with lambda arguments \u00b6 config = [ dict ( type = 'box_factory' , args = dict ( size = \"__import__('numpy').random.random((2, 3))\" , use_permutation = True , name = 'box_static_lambdas' , color = 'random' ) ), dict ( type = 'box_factory' , args = dict ( size = \"__import__('numpy').random.random((4, 3))\" , mass = \"__import__('numpy').arange(1, 10, 4)\" , use_permutation = True , name = 'box_dynamic_lambdas' , color = 'random' ) ) ] create_and_spawn ( config ) Cylinder-shaped models \u00b6 config = [ dict ( type = 'cylinder' , args = dict ( radius = 3 , length = 2 , mass = 10 , name = 'cylinder' , pose = [ 0 , 0 , 1 , 0 , 0 , 0 ] ) ), dict ( type = 'cylinder_factory' , args = dict ( length = [ 0.3 , 0.5 ], radius = [ 0.2 , 0.4 ], mass = [ 5 , 2 ], name = 'cylinder_dynamic_permutate_radius_length_mass' , use_permutation = True , color = 'xkcd' ) ), dict ( type = 'cylinder_factory' , args = dict ( length = \"__import__('numpy').linspace(0.1, 10, 2)\" , radius = \"__import__('numpy').random.random(2)\" , mass = \"__import__('numpy').arange(1, 4, 1)\" , use_permutation = True , name = 'cylinder_dynamic_lambdas' , color = 'xkcd' ) ) ] create_and_spawn ( config ) Sphere-shaped models \u00b6 config = [ dict ( type = 'sphere' , args = dict ( radius = 3 , mass = 10 , name = 'sphere' , pose = [ 0 , 0 , 1.5 , 0 , 0 , 0 ] ) ), dict ( type = 'sphere_factory' , args = dict ( radius = [ 0.3 , 0.9 ], mass = [ 5 , 2 ], name = 'sphere_dynamic_permutate_radius_mass' , use_permutation = True , color = 'xkcd' ) ), dict ( type = 'sphere_factory' , args = dict ( radius = \"__import__('numpy').random.random(2) * 3\" , mass = \"__import__('numpy').arange(1, 4, 1)\" , use_permutation = True , name = 'sphere_dynamic_lambdas' , color = 'xkcd' ) ) ] create_and_spawn ( config ) Mesh models \u00b6 mesh_filename = 'package://pcg_examples/meshes/monkey_offset.dae' config = [ dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = False , name = 'monkey_static_no_approx_collision' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = False , mass = 10 , name = 'monkey_dynamic_no_approx_collision' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'box' , name = 'monkey_static_with_approx_collision_box' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'box' , mass = 20 , name = 'monkey_dynamic_with_approx_collision_box' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'cylinder' , name = 'monkey_static_with_approx_collision_cylinder' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , mass = 15 , approximated_collision_model = 'cylinder' , name = 'monkey_dynamic_with_approx_collision_cylinder' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'sphere' , name = 'monkey_static_with_approx_collision_sphere' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , mass = 3 , approximated_collision_model = 'sphere' , name = 'monkey_dynamic_with_approx_collision_sphere' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , mass = 3 , approximated_collision_model = 'sphere' , name = 'monkey_dynamic_defined_inertia' , color = 'xkcd' , use_approximated_inertia = False , inertia = dict ( ixx = 0.1 , iyy = 0.1 , izz = 0.1 ) ) ) ] create_and_spawn ( config )","title":"Model generator"},{"location":"tutorials/simulation/model_generator/#model-generator","text":"from pcg_gazebo.generators.creators import create_models_from_config from pcg_gazebo.task_manager import Server from pcg_gazebo.generators import WorldGenerator import random # Start an empty world Gazebo simulation server = Server () server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) simulation . create_gazebo_empty_world_task () print ( simulation . get_task_list ()) print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) simulation . run_all_tasks () # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance # running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) def create_and_spawn ( config ): models = create_models_from_config ( config ) for model in models : generator . spawn_model ( model = model , robot_namespace = model . name , pos = [ 20 * random . random () - 10 , 20 * random . random () - 10 , 2 * random . random ()])","title":"Model generator"},{"location":"tutorials/simulation/model_generator/#box-shaped-models","text":"","title":"Box-shaped models"},{"location":"tutorials/simulation/model_generator/#creating-box-models","text":"config = [ dict ( type = 'box' , args = dict ( size = [ 2 , 2 , 2 ], mass = 10 , name = 'box' , pose = [ 0 , 0 , 1 , 0 , 0 , 0 ], color = 'random' ) ) ] create_and_spawn ( config )","title":"Creating box models"},{"location":"tutorials/simulation/model_generator/#creating-multiple-boxes-models-using-fixed-arguments","text":"config = [ dict ( type = 'box_factory' , args = dict ( size = [ [ 0.1 , 0.4 , 0.5 ], [ 1 , 2 , 3 ] ], name = 'box_static_var_size' , use_permutation = True , color = 'xkcd' ) ), dict ( type = 'box_factory' , args = dict ( size = [ [ 0.1 , 0.4 , 0.5 ], [ 1 , 2 , 3 ] ], mass = 12 , name = 'box_dynamic_var_size' , use_permutation = False , color = 'xkcd' ) ), dict ( type = 'box_factory' , args = dict ( size = [ [ 0.2 , 0.4 , 0.15 ], [ 1.2 , 0.25 , 0.7 ] ], mass = [ 5 , 2 ], name = 'box_dynamic_permutate_size_mass' , use_permutation = True , color = 'xkcd' ) ) ] create_and_spawn ( config )","title":"Creating multiple boxes models using fixed arguments"},{"location":"tutorials/simulation/model_generator/#creating-multiple-boxes-with-lambda-arguments","text":"config = [ dict ( type = 'box_factory' , args = dict ( size = \"__import__('numpy').random.random((2, 3))\" , use_permutation = True , name = 'box_static_lambdas' , color = 'random' ) ), dict ( type = 'box_factory' , args = dict ( size = \"__import__('numpy').random.random((4, 3))\" , mass = \"__import__('numpy').arange(1, 10, 4)\" , use_permutation = True , name = 'box_dynamic_lambdas' , color = 'random' ) ) ] create_and_spawn ( config )","title":"Creating multiple boxes with lambda arguments"},{"location":"tutorials/simulation/model_generator/#cylinder-shaped-models","text":"config = [ dict ( type = 'cylinder' , args = dict ( radius = 3 , length = 2 , mass = 10 , name = 'cylinder' , pose = [ 0 , 0 , 1 , 0 , 0 , 0 ] ) ), dict ( type = 'cylinder_factory' , args = dict ( length = [ 0.3 , 0.5 ], radius = [ 0.2 , 0.4 ], mass = [ 5 , 2 ], name = 'cylinder_dynamic_permutate_radius_length_mass' , use_permutation = True , color = 'xkcd' ) ), dict ( type = 'cylinder_factory' , args = dict ( length = \"__import__('numpy').linspace(0.1, 10, 2)\" , radius = \"__import__('numpy').random.random(2)\" , mass = \"__import__('numpy').arange(1, 4, 1)\" , use_permutation = True , name = 'cylinder_dynamic_lambdas' , color = 'xkcd' ) ) ] create_and_spawn ( config )","title":"Cylinder-shaped models"},{"location":"tutorials/simulation/model_generator/#sphere-shaped-models","text":"config = [ dict ( type = 'sphere' , args = dict ( radius = 3 , mass = 10 , name = 'sphere' , pose = [ 0 , 0 , 1.5 , 0 , 0 , 0 ] ) ), dict ( type = 'sphere_factory' , args = dict ( radius = [ 0.3 , 0.9 ], mass = [ 5 , 2 ], name = 'sphere_dynamic_permutate_radius_mass' , use_permutation = True , color = 'xkcd' ) ), dict ( type = 'sphere_factory' , args = dict ( radius = \"__import__('numpy').random.random(2) * 3\" , mass = \"__import__('numpy').arange(1, 4, 1)\" , use_permutation = True , name = 'sphere_dynamic_lambdas' , color = 'xkcd' ) ) ] create_and_spawn ( config )","title":"Sphere-shaped models"},{"location":"tutorials/simulation/model_generator/#mesh-models","text":"mesh_filename = 'package://pcg_examples/meshes/monkey_offset.dae' config = [ dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = False , name = 'monkey_static_no_approx_collision' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = False , mass = 10 , name = 'monkey_dynamic_no_approx_collision' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'box' , name = 'monkey_static_with_approx_collision_box' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'box' , mass = 20 , name = 'monkey_dynamic_with_approx_collision_box' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'cylinder' , name = 'monkey_static_with_approx_collision_cylinder' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , mass = 15 , approximated_collision_model = 'cylinder' , name = 'monkey_dynamic_with_approx_collision_cylinder' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , approximated_collision_model = 'sphere' , name = 'monkey_static_with_approx_collision_sphere' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , mass = 3 , approximated_collision_model = 'sphere' , name = 'monkey_dynamic_with_approx_collision_sphere' , color = 'xkcd' ) ), dict ( type = 'mesh' , args = dict ( visual_mesh_filename = mesh_filename , visual_mesh_scale = [ 1 , 1 , 1 ], use_approximated_collision = True , mass = 3 , approximated_collision_model = 'sphere' , name = 'monkey_dynamic_defined_inertia' , color = 'xkcd' , use_approximated_inertia = False , inertia = dict ( ixx = 0.1 , iyy = 0.1 , izz = 0.1 ) ) ) ] create_and_spawn ( config )","title":"Mesh models"},{"location":"tutorials/simulation/objects/","text":"Objects \u00b6 The objects are models including basic and custom forms that can be spawned in the simulation. from pcg_gazebo.simulation import create_object # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) Geometries \u00b6 Box \u00b6 box = create_object ( 'box' ) # A box object comes initially with no inertial information and null size. print ( 'Size:' ) print ( box . size ) print ( 'Inertial:' ) print ( box . inertial ) # When generating the SDF elements for the box, a few options can be used print ( box . to_sdf ( 'box' )) print ( box . to_sdf ( 'geometry' )) print ( box . to_sdf ( 'collision' )) print ( box . to_sdf ( 'visual' )) print ( box . to_sdf ( 'link' )) print ( box . to_sdf ( 'model' )) # To set the inertial, use the function add_inertial giving the mass of the box, # the moments of inertia will be computed from the box's dimensions box . size = [ 0.3 , 0.6 , 0.2 ] box . add_inertial ( mass = 20 ) print ( box . inertial ) # The inertial information will be added to the SDF description in link and model modes print ( box . to_sdf ( 'link' )) print ( box . to_sdf ( 'model' )) model_counter = 0 for x in [ - 5 , 0 , 5 ]: for y in [ - 5 , 0 , 5 ]: box . visual . enable_property ( 'material' ) box . visual . set_xkcd_color () generator . spawn_model ( model = box , robot_namespace = 'box_{}' . format ( model_counter ), pos = [ x , y , 10 ]) model_counter += 1 # Using the Gazebo proxy created by the generator's constructor # it is possible to see that all models were created print ( generator . gazebo_proxy . get_model_names ()) # End the simulation by killing the Gazebo task # simulation.kill_task('gazebo') Sphere \u00b6 sphere = create_object ( 'sphere' ) # A sphere object comes initially with no inertial information and radius equal to 1. print ( 'Radius:' ) print ( sphere . radius ) print ( 'Inertial:' ) print ( sphere . inertial ) # When generating the SDF elements for the box, a few options can be used print ( sphere . to_sdf ( 'sphere' )) print ( sphere . to_sdf ( 'geometry' )) print ( sphere . to_sdf ( 'collision' )) print ( sphere . to_sdf ( 'visual' )) print ( sphere . to_sdf ( 'link' )) print ( sphere . to_sdf ( 'model' )) # To set the inertial, use the function add_inertial giving the mass of the sphere, # the moments of inertia will be computed from the sphere's dimensions sphere . radius = 0.3 sphere . add_inertial ( 20 ) print ( sphere . inertial ) # The inertial information will be added to the SDF description in link and model modes print ( sphere . to_sdf ( 'link' )) print ( sphere . to_sdf ( 'model' )) # Run Gazebo again, if not already running simulation . run_task ( 'gazebo' ) # Spawn sphere of different values for radius model_counter = 0 for _ in range ( 3 ): for _ in range ( 3 ): sphere . radius = random . random () * 2 sphere . add_inertial ( random . random () * 30 ) sphere . visual . enable_property ( 'material' ) sphere . visual . set_xkcd_color () generator . spawn_model ( model = sphere , robot_namespace = 'sphere_{}' . format ( model_counter ), pos = [( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 5 + 3 ]) model_counter += 1 # End the simulation by killing the Gazebo task # simulation.kill_all_tasks() Cylinder \u00b6 cylinder = create_object ( 'cylinder' ) # A sphere object comes initially with no inertial information, and length and radius equal to 1. print ( 'Radius:' ) print ( cylinder . radius ) print ( 'Length:' ) print ( cylinder . length ) # When generating the SDF elements for the cylinder, a few options can be used print ( cylinder . to_sdf ( 'cylinder' )) print ( cylinder . to_sdf ( 'geometry' )) print ( cylinder . to_sdf ( 'collision' )) print ( cylinder . to_sdf ( 'visual' )) print ( cylinder . to_sdf ( 'link' )) print ( cylinder . to_sdf ( 'model' )) # To set the inertial, use the function add_inertial giving the mass of the cylinder, # the moments of inertia will be computed from the cylinder's dimensions cylinder . radius = 0.3 cylinder . length = 0.8 cylinder . add_inertial ( 20 ) print ( cylinder . inertial ) # The inertial information will be added to the SDF description in link and model modes print ( cylinder . to_sdf ( 'link' )) print ( cylinder . to_sdf ( 'model' )) # Run Gazebo again, if not already running simulation . run_task ( 'gazebo' ) # Spawn sphere of different values for radius model_counter = 0 for _ in range ( 3 ): for _ in range ( 3 ): cylinder . length = random . random () * 3 cylinder . radius = random . random () * 0.5 cylinder . add_inertial ( random . random () * 30 ) cylinder . visual . enable_property ( 'material' ) cylinder . visual . set_xkcd_color () generator . spawn_model ( model = cylinder , robot_namespace = 'cylinder_{}' . format ( model_counter ), pos = [( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 5 + 10 ]) model_counter += 1 Plane \u00b6 plane = create_object ( 'plane' ) # A plane per default has normal [0, 0, 1] and size = [1, 1] print ( 'Normal:' ) print ( plane . normal ) print ( 'Size:' ) print ( plane . size ) # When generating the SDF elements for the plane, a few options can be used print ( plane . to_sdf ( 'plane' )) print ( plane . to_sdf ( 'geometry' )) print ( plane . to_sdf ( 'visual' )) print ( plane . to_sdf ( 'collision' )) print ( plane . to_sdf ( 'link' )) print ( plane . to_sdf ( 'model' )) # Run Gazebo again, if not already running simulation . run_task ( 'gazebo' ) # Spawning the plane # When there are other models in the simulation, # the spawning of a new plane with [0, 0, 1] and a plane as # collision geometry leads to # the new plane becoming the ground plane # To set the collision geometry, use # plane.generate_collision = True plane = create_object ( 'plane' ) plane . size = [ random . random () * 5 , random . random () * 5 ] p = random . random () plane . normal = [ 0 , 0 , 1 ] plane . visual . enable_property ( 'material' ) plane . visual . set_xkcd_color () generator . spawn_model ( model = plane , robot_namespace = 'new_plane' , pos = [( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 2 + 5 ]) The output should look like this","title":"Dynamically creating objects"},{"location":"tutorials/simulation/objects/#objects","text":"The objects are models including basic and custom forms that can be spawned in the simulation. from pcg_gazebo.simulation import create_object # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy )","title":"Objects"},{"location":"tutorials/simulation/objects/#geometries","text":"","title":"Geometries"},{"location":"tutorials/simulation/objects/#box","text":"box = create_object ( 'box' ) # A box object comes initially with no inertial information and null size. print ( 'Size:' ) print ( box . size ) print ( 'Inertial:' ) print ( box . inertial ) # When generating the SDF elements for the box, a few options can be used print ( box . to_sdf ( 'box' )) print ( box . to_sdf ( 'geometry' )) print ( box . to_sdf ( 'collision' )) print ( box . to_sdf ( 'visual' )) print ( box . to_sdf ( 'link' )) print ( box . to_sdf ( 'model' )) # To set the inertial, use the function add_inertial giving the mass of the box, # the moments of inertia will be computed from the box's dimensions box . size = [ 0.3 , 0.6 , 0.2 ] box . add_inertial ( mass = 20 ) print ( box . inertial ) # The inertial information will be added to the SDF description in link and model modes print ( box . to_sdf ( 'link' )) print ( box . to_sdf ( 'model' )) model_counter = 0 for x in [ - 5 , 0 , 5 ]: for y in [ - 5 , 0 , 5 ]: box . visual . enable_property ( 'material' ) box . visual . set_xkcd_color () generator . spawn_model ( model = box , robot_namespace = 'box_{}' . format ( model_counter ), pos = [ x , y , 10 ]) model_counter += 1 # Using the Gazebo proxy created by the generator's constructor # it is possible to see that all models were created print ( generator . gazebo_proxy . get_model_names ()) # End the simulation by killing the Gazebo task # simulation.kill_task('gazebo')","title":"Box"},{"location":"tutorials/simulation/objects/#sphere","text":"sphere = create_object ( 'sphere' ) # A sphere object comes initially with no inertial information and radius equal to 1. print ( 'Radius:' ) print ( sphere . radius ) print ( 'Inertial:' ) print ( sphere . inertial ) # When generating the SDF elements for the box, a few options can be used print ( sphere . to_sdf ( 'sphere' )) print ( sphere . to_sdf ( 'geometry' )) print ( sphere . to_sdf ( 'collision' )) print ( sphere . to_sdf ( 'visual' )) print ( sphere . to_sdf ( 'link' )) print ( sphere . to_sdf ( 'model' )) # To set the inertial, use the function add_inertial giving the mass of the sphere, # the moments of inertia will be computed from the sphere's dimensions sphere . radius = 0.3 sphere . add_inertial ( 20 ) print ( sphere . inertial ) # The inertial information will be added to the SDF description in link and model modes print ( sphere . to_sdf ( 'link' )) print ( sphere . to_sdf ( 'model' )) # Run Gazebo again, if not already running simulation . run_task ( 'gazebo' ) # Spawn sphere of different values for radius model_counter = 0 for _ in range ( 3 ): for _ in range ( 3 ): sphere . radius = random . random () * 2 sphere . add_inertial ( random . random () * 30 ) sphere . visual . enable_property ( 'material' ) sphere . visual . set_xkcd_color () generator . spawn_model ( model = sphere , robot_namespace = 'sphere_{}' . format ( model_counter ), pos = [( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 5 + 3 ]) model_counter += 1 # End the simulation by killing the Gazebo task # simulation.kill_all_tasks()","title":"Sphere"},{"location":"tutorials/simulation/objects/#cylinder","text":"cylinder = create_object ( 'cylinder' ) # A sphere object comes initially with no inertial information, and length and radius equal to 1. print ( 'Radius:' ) print ( cylinder . radius ) print ( 'Length:' ) print ( cylinder . length ) # When generating the SDF elements for the cylinder, a few options can be used print ( cylinder . to_sdf ( 'cylinder' )) print ( cylinder . to_sdf ( 'geometry' )) print ( cylinder . to_sdf ( 'collision' )) print ( cylinder . to_sdf ( 'visual' )) print ( cylinder . to_sdf ( 'link' )) print ( cylinder . to_sdf ( 'model' )) # To set the inertial, use the function add_inertial giving the mass of the cylinder, # the moments of inertia will be computed from the cylinder's dimensions cylinder . radius = 0.3 cylinder . length = 0.8 cylinder . add_inertial ( 20 ) print ( cylinder . inertial ) # The inertial information will be added to the SDF description in link and model modes print ( cylinder . to_sdf ( 'link' )) print ( cylinder . to_sdf ( 'model' )) # Run Gazebo again, if not already running simulation . run_task ( 'gazebo' ) # Spawn sphere of different values for radius model_counter = 0 for _ in range ( 3 ): for _ in range ( 3 ): cylinder . length = random . random () * 3 cylinder . radius = random . random () * 0.5 cylinder . add_inertial ( random . random () * 30 ) cylinder . visual . enable_property ( 'material' ) cylinder . visual . set_xkcd_color () generator . spawn_model ( model = cylinder , robot_namespace = 'cylinder_{}' . format ( model_counter ), pos = [( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 5 + 10 ]) model_counter += 1","title":"Cylinder"},{"location":"tutorials/simulation/objects/#plane","text":"plane = create_object ( 'plane' ) # A plane per default has normal [0, 0, 1] and size = [1, 1] print ( 'Normal:' ) print ( plane . normal ) print ( 'Size:' ) print ( plane . size ) # When generating the SDF elements for the plane, a few options can be used print ( plane . to_sdf ( 'plane' )) print ( plane . to_sdf ( 'geometry' )) print ( plane . to_sdf ( 'visual' )) print ( plane . to_sdf ( 'collision' )) print ( plane . to_sdf ( 'link' )) print ( plane . to_sdf ( 'model' )) # Run Gazebo again, if not already running simulation . run_task ( 'gazebo' ) # Spawning the plane # When there are other models in the simulation, # the spawning of a new plane with [0, 0, 1] and a plane as # collision geometry leads to # the new plane becoming the ground plane # To set the collision geometry, use # plane.generate_collision = True plane = create_object ( 'plane' ) plane . size = [ random . random () * 5 , random . random () * 5 ] p = random . random () plane . normal = [ 0 , 0 , 1 ] plane . visual . enable_property ( 'material' ) plane . visual . set_xkcd_color () generator . spawn_model ( model = plane , robot_namespace = 'new_plane' , pos = [( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 10 , ( random . random () - 0.5 ) * 2 + 5 ]) The output should look like this","title":"Plane"},{"location":"tutorials/simulation/physics_engines/","text":"Physics engines \u00b6 Gazebo has interfaces with four physics engines ODE Simbody Bullet DART from which only DART has to be compiled separately. The modules presented below allow the generation of the necessary physics engine's SDF parameters using classes. Physics engine object \u00b6 The physics engine object holds the global parameters valid for all physics engines. If this modules is used to generate the SDF data, the default parameters of the physics engine chosen ( ode , bullet , simbody or dart ) will be used. from pcg_gazebo.simulation.physics import Physics physics = Physics () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's make a custom parameter set for the physics engine physics . max_step_size = 0.01 physics . real_time_factor = 1 physics . real_time_update_rate = 500 physics . max_contacts = 5 physics . name = 'custom_physics' print ( physics . to_sdf ()) # The resulting world file can be exported to an .world file and run in Gazebo # This shows how to create an SDF file from stratch sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics.world' sdf . export_xml ( filename = world_filename ) # Start a PCG server to run the world file in Gazebo from pcg_gazebo.task_manager import Server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with the parameters provided to run the world file created simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = 'ode' , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Check if the parameters were initialized correctly # We need a Gazebo proxy object to check it from pcg_gazebo.task_manager import GazeboProxy # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # It is important to note that the default get_physics_properties service from Gazebo # returns only the global and the ODE engine parameters print ( gazebo_proxy . get_physics_properties ()) simulation . wait () simulation . kill_all_tasks () ODE \u00b6 It is possible to create an instance of the physics engine configuration for each engine available. The ODE is presented on the following sections. from pcg_gazebo.simulation.physics import ODE physics = ODE () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's change some parameters physics . max_step_size = 0.005 physics . friction_model = 'box_model' physics . sor = 1.5 physics . max_contacts = 10 physics . name = 'custom_ode' print ( physics . to_sdf ()) # Exporting this world configuration to a file allows running the # configured physics engine in Gazebo sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics_ode.world' sdf . export_xml ( filename = world_filename ) # Remove old gazebo task server . create_simulation ( 'ode' ) simulation = server . get_simulation ( 'ode' ) # Create new task simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = physics . engine , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Check if the parameters were initialized correctly gazebo_proxy = simulation . get_gazebo_proxy () # It is important to note that the default get_physics_properties service from Gazebo # returns only the global and the ODE engine parameters print ( gazebo_proxy . get_physics_properties ()) simulation . wait () simulation . kill_all_tasks () Bullet \u00b6 from pcg_gazebo.simulation.physics import Bullet physics = Bullet () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's change some parameters physics . max_step_size = 0.005 physics . cfm = 0.01 physics . sor = 1.5 physics . max_contacts = 5 physics . name = 'custom_bullet' physics . real_time_update_rate = 500 print ( physics . to_sdf ()) # Exporting this world configuration to a file allows running the # configured physics engine in Gazebo sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics_bullet.world' sdf . export_xml ( filename = world_filename ) # Remove old gazebo task server . create_simulation ( 'bullet' ) simulation = server . get_simulation ( 'bullet' ) # Create new task simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = physics . engine , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # The get_physics_properties service does not support bullet parameters yet simulation . wait () simulation . kill_all_tasks () Simbody \u00b6 from pcg_gazebo.simulation.physics import Simbody physics = Simbody () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's change some parameters physics . max_step_size = 0.005 physics . max_contacts = 8 physics . name = 'custom_simbody' physics . static_friction = 1.0 physics . real_time_update_rate = 500 print ( physics . to_sdf ()) # Exporting this world configuration to a file allows running the # configured physics engine in Gazebo sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics_simbody.world' sdf . export_xml ( filename = world_filename ) server . create_simulation ( 'simbody' ) simulation = server . get_simulation ( 'simbody' ) # Create new task simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = physics . engine , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # The get_physics_properties service does not support simbody parameters yet simulation . wait () simulation . kill_all_tasks ()","title":"Setting up different physics engines"},{"location":"tutorials/simulation/physics_engines/#physics-engines","text":"Gazebo has interfaces with four physics engines ODE Simbody Bullet DART from which only DART has to be compiled separately. The modules presented below allow the generation of the necessary physics engine's SDF parameters using classes.","title":"Physics engines"},{"location":"tutorials/simulation/physics_engines/#physics-engine-object","text":"The physics engine object holds the global parameters valid for all physics engines. If this modules is used to generate the SDF data, the default parameters of the physics engine chosen ( ode , bullet , simbody or dart ) will be used. from pcg_gazebo.simulation.physics import Physics physics = Physics () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's make a custom parameter set for the physics engine physics . max_step_size = 0.01 physics . real_time_factor = 1 physics . real_time_update_rate = 500 physics . max_contacts = 5 physics . name = 'custom_physics' print ( physics . to_sdf ()) # The resulting world file can be exported to an .world file and run in Gazebo # This shows how to create an SDF file from stratch sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics.world' sdf . export_xml ( filename = world_filename ) # Start a PCG server to run the world file in Gazebo from pcg_gazebo.task_manager import Server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with the parameters provided to run the world file created simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = 'ode' , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Check if the parameters were initialized correctly # We need a Gazebo proxy object to check it from pcg_gazebo.task_manager import GazeboProxy # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # It is important to note that the default get_physics_properties service from Gazebo # returns only the global and the ODE engine parameters print ( gazebo_proxy . get_physics_properties ()) simulation . wait () simulation . kill_all_tasks ()","title":"Physics engine object"},{"location":"tutorials/simulation/physics_engines/#ode","text":"It is possible to create an instance of the physics engine configuration for each engine available. The ODE is presented on the following sections. from pcg_gazebo.simulation.physics import ODE physics = ODE () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's change some parameters physics . max_step_size = 0.005 physics . friction_model = 'box_model' physics . sor = 1.5 physics . max_contacts = 10 physics . name = 'custom_ode' print ( physics . to_sdf ()) # Exporting this world configuration to a file allows running the # configured physics engine in Gazebo sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics_ode.world' sdf . export_xml ( filename = world_filename ) # Remove old gazebo task server . create_simulation ( 'ode' ) simulation = server . get_simulation ( 'ode' ) # Create new task simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = physics . engine , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # Check if the parameters were initialized correctly gazebo_proxy = simulation . get_gazebo_proxy () # It is important to note that the default get_physics_properties service from Gazebo # returns only the global and the ODE engine parameters print ( gazebo_proxy . get_physics_properties ()) simulation . wait () simulation . kill_all_tasks ()","title":"ODE"},{"location":"tutorials/simulation/physics_engines/#bullet","text":"from pcg_gazebo.simulation.physics import Bullet physics = Bullet () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's change some parameters physics . max_step_size = 0.005 physics . cfm = 0.01 physics . sor = 1.5 physics . max_contacts = 5 physics . name = 'custom_bullet' physics . real_time_update_rate = 500 print ( physics . to_sdf ()) # Exporting this world configuration to a file allows running the # configured physics engine in Gazebo sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics_bullet.world' sdf . export_xml ( filename = world_filename ) # Remove old gazebo task server . create_simulation ( 'bullet' ) simulation = server . get_simulation ( 'bullet' ) # Create new task simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = physics . engine , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # The get_physics_properties service does not support bullet parameters yet simulation . wait () simulation . kill_all_tasks ()","title":"Bullet"},{"location":"tutorials/simulation/physics_engines/#simbody","text":"from pcg_gazebo.simulation.physics import Simbody physics = Simbody () # Iterate through all parameters for name in physics . get_parameter_names (): print ( '{}: {}' . format ( name , physics . get_parameter ( name ))) # The description of the parameters is also available for name in physics . get_parameter_names (): physics . print_description ( name ) # It is also possible to generate the SDF files. # The SDF object can also be retrieved and altered if necessary print ( physics . to_sdf ( 'physics' )) print ( physics . to_sdf ( 'world' )) # Let's change some parameters physics . max_step_size = 0.005 physics . max_contacts = 8 physics . name = 'custom_simbody' physics . static_friction = 1.0 physics . real_time_update_rate = 500 print ( physics . to_sdf ()) # Exporting this world configuration to a file allows running the # configured physics engine in Gazebo sdf = physics . to_sdf ( 'sdf' ) print ( sdf ) # Export to a .world file world_filename = '/tmp/physics_simbody.world' sdf . export_xml ( filename = world_filename ) server . create_simulation ( 'simbody' ) simulation = server . get_simulation ( 'simbody' ) # Create new task simulation . create_gazebo_task ( name = 'gazebo' , world = world_filename , gui = True , physics = physics . engine , paused = False , required = True , process_timeout = 10 ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () # The get_physics_properties service does not support simbody parameters yet simulation . wait () simulation . kill_all_tasks ()","title":"Simbody"},{"location":"tutorials/simulation/sensors/","text":"Sensors \u00b6 from pcg_gazebo.simulation import create_object , SimulationModel from pcg_gazebo.task_manager import get_rostopic_list # If there is a Gazebo instance running, you can spawn the box # into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' , ros_port = 11311 , gazebo_port = 11345 ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () simulation . create_rqt_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) Sensors \u00b6 Standalone IMU sensor \u00b6 imu_model = SimulationModel ( name = 'default_imu' ) # Default IMU sensor imu_model . add_imu_sensor ( add_visual = True , add_collision = True , visualize = True , mass = 0.01 , size = [ 0.1 , 0.1 , 0.1 ], topic = '/imu' , link_shape = 'cuboid' , link_name = 'imu_link' ) print ( imu_model . to_sdf ()) # Spawn IMU standalone model generator . spawn_model ( model = imu_model , robot_namespace = 'default_imu' , pos = [ 0 , 0 , 0.05 ]) print ( 'List of ROS topics:' ) for topic in simulation . get_rostopic_list (): print ( ' - ' + topic ) Standalone ray sensor \u00b6 ray_model = SimulationModel ( name = 'default_ray' ) # Default ray sensor ray_model . add_ray_sensor ( add_visual = True , add_collision = True , add_ros_plugin = False , mass = 0.01 , radius = 0.05 , link_shape = 'spherical' , link_name = 'ray_link' ) print ( ray_model . to_sdf ()) # Spawn ray sensor standalone model generator . spawn_model ( model = ray_model , robot_namespace = 'default_ray' , pos = [ 0 , 0.3 , 0.05 ]) print ( 'List of ROS topics:' ) for topic in simulation . get_rostopic_list (): print ( ' - ' + topic ) Standalone contact sensor \u00b6 contact_sensor = SimulationModel ( name = 'contact_standalone' ) contact_sensor . add_contact_sensor ( add_visual = True , add_collision = True , add_ros_plugin = True , mass = 0.01 , radius = 0.05 , length = 0.1 , link_shape = 'cylindrical' , link_name = 'contact_link' ) print ( contact_sensor . to_sdf ()) # Spawn ray sensor standalone model generator . spawn_model ( model = contact_sensor , robot_namespace = 'contact_standalone' , pos = [ 0 , 0.6 , 0.05 ]) Standalone camera \u00b6 camera_sensor = SimulationModel ( name = 'camera_standalone' ) camera_sensor . static = True camera_sensor . add_camera_sensor ( add_visual = True , add_collision = True , add_ros_plugin = True , visualize = True , mass = 0.01 , size = [ 0.1 , 0.1 , 0.1 ], link_shape = 'cuboid' , link_name = 'camera_link' ) print ( camera_sensor . to_sdf ()) # Spawn camera standalone model generator . spawn_model ( model = camera_sensor , robot_namespace = 'camera_standalone' , pos = [ 0 , 0.9 , 0.5 ]) print ( 'List of ROS topics:' ) for topic in simulation . get_rostopic_list (): print ( ' - ' + topic ) # End the simulation by killing the Gazebo task simulation . kill_all_tasks ()","title":"Sensors"},{"location":"tutorials/simulation/sensors/#sensors","text":"from pcg_gazebo.simulation import create_object , SimulationModel from pcg_gazebo.task_manager import get_rostopic_list # If there is a Gazebo instance running, you can spawn the box # into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' , ros_port = 11311 , gazebo_port = 11345 ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () simulation . create_rqt_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' )))","title":"Sensors"},{"location":"tutorials/simulation/sensors/#sensors_1","text":"","title":"Sensors"},{"location":"tutorials/simulation/sensors/#standalone-imu-sensor","text":"imu_model = SimulationModel ( name = 'default_imu' ) # Default IMU sensor imu_model . add_imu_sensor ( add_visual = True , add_collision = True , visualize = True , mass = 0.01 , size = [ 0.1 , 0.1 , 0.1 ], topic = '/imu' , link_shape = 'cuboid' , link_name = 'imu_link' ) print ( imu_model . to_sdf ()) # Spawn IMU standalone model generator . spawn_model ( model = imu_model , robot_namespace = 'default_imu' , pos = [ 0 , 0 , 0.05 ]) print ( 'List of ROS topics:' ) for topic in simulation . get_rostopic_list (): print ( ' - ' + topic )","title":"Standalone IMU sensor"},{"location":"tutorials/simulation/sensors/#standalone-ray-sensor","text":"ray_model = SimulationModel ( name = 'default_ray' ) # Default ray sensor ray_model . add_ray_sensor ( add_visual = True , add_collision = True , add_ros_plugin = False , mass = 0.01 , radius = 0.05 , link_shape = 'spherical' , link_name = 'ray_link' ) print ( ray_model . to_sdf ()) # Spawn ray sensor standalone model generator . spawn_model ( model = ray_model , robot_namespace = 'default_ray' , pos = [ 0 , 0.3 , 0.05 ]) print ( 'List of ROS topics:' ) for topic in simulation . get_rostopic_list (): print ( ' - ' + topic )","title":"Standalone ray sensor"},{"location":"tutorials/simulation/sensors/#standalone-contact-sensor","text":"contact_sensor = SimulationModel ( name = 'contact_standalone' ) contact_sensor . add_contact_sensor ( add_visual = True , add_collision = True , add_ros_plugin = True , mass = 0.01 , radius = 0.05 , length = 0.1 , link_shape = 'cylindrical' , link_name = 'contact_link' ) print ( contact_sensor . to_sdf ()) # Spawn ray sensor standalone model generator . spawn_model ( model = contact_sensor , robot_namespace = 'contact_standalone' , pos = [ 0 , 0.6 , 0.05 ])","title":"Standalone contact sensor"},{"location":"tutorials/simulation/sensors/#standalone-camera","text":"camera_sensor = SimulationModel ( name = 'camera_standalone' ) camera_sensor . static = True camera_sensor . add_camera_sensor ( add_visual = True , add_collision = True , add_ros_plugin = True , visualize = True , mass = 0.01 , size = [ 0.1 , 0.1 , 0.1 ], link_shape = 'cuboid' , link_name = 'camera_link' ) print ( camera_sensor . to_sdf ()) # Spawn camera standalone model generator . spawn_model ( model = camera_sensor , robot_namespace = 'camera_standalone' , pos = [ 0 , 0.9 , 0.5 ]) print ( 'List of ROS topics:' ) for topic in simulation . get_rostopic_list (): print ( ' - ' + topic ) # End the simulation by killing the Gazebo task simulation . kill_all_tasks ()","title":"Standalone camera"},{"location":"tutorials/simulation/surface_collision_properties/","text":"Surface and collision properties \u00b6 The simulation objects can include collision properties such as friction, bounce and contact parameters set to an individual link. from pcg_gazebo.simulation import create_object # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'friction' ) simulation = server . get_simulation ( 'friction' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) Friction \u00b6 obj = create_object ( 'box' ) # By changing the size, collision, visual and inertial # properties are already going to be updated obj . size = [ 0.8 , 0.7 , 0.9 ] obj . add_inertial ( 30 ) # Print the initial state of a box in the model option print ( obj . to_sdf ( 'model' )) # Set default friction parameters obj . collision . enable_property ( 'friction' ) print ( obj . to_sdf ( 'model' )) obj . collision . set_ode_friction_params ( mu = 0.9 , mu2 = 0.5 , slip1 = 0.3 , slip2 = 0.5 , fdir1 = [ 0 , 0 , 0 ] ) print ( obj . to_sdf ( 'model' )) obj . collision . set_bullet_friction_params ( friction = 0.8 , friction2 = 0.9 , fdir1 = [ 0 , 0 , 0 ], rolling_friction = 1 ) print ( obj . to_sdf ( 'model' )) # Set default bounce parameters obj . collision . enable_property ( 'bounce' ) print ( obj . to_sdf ( 'model' )) mu = [ 0.1 , 0.3 , 0.5 , 0.7 , 1.0 ] for i in range ( len ( mu )): obj . collision . set_ode_friction_params ( mu = mu [ i ], mu2 = mu [ i ]) generator . spawn_model ( model = obj , robot_namespace = 'box_mu_{}' . format ( mu [ i ]), pos = [ 0 , i , 2 ]) from time import sleep sleep ( 2 ) for i in range ( len ( mu )): gazebo_proxy . apply_body_wrench ( model_name = 'box_mu_{}' . format ( mu [ i ]), link_name = 'box' , force = [ 300 , 0 , 0 ], torque = [ 0 , 0 , 0 ], start_time = 0 , duration = 2 ) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks () The cuboids are created with different friction parameters and therefore will travel different distances when subjected to a horizontal force applied on their center of mass.","title":"Surface and collision properties"},{"location":"tutorials/simulation/surface_collision_properties/#surface-and-collision-properties","text":"The simulation objects can include collision properties such as friction, bounce and contact parameters set to an individual link. from pcg_gazebo.simulation import create_object # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'friction' ) simulation = server . get_simulation ( 'friction' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task () # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () from pcg_gazebo.generators import WorldGenerator import random # Create a Gazebo proxy gazebo_proxy = simulation . get_gazebo_proxy () # Use the generator to spawn the model to the Gazebo instance running at the moment generator = WorldGenerator ( gazebo_proxy = gazebo_proxy )","title":"Surface and collision properties"},{"location":"tutorials/simulation/surface_collision_properties/#friction","text":"obj = create_object ( 'box' ) # By changing the size, collision, visual and inertial # properties are already going to be updated obj . size = [ 0.8 , 0.7 , 0.9 ] obj . add_inertial ( 30 ) # Print the initial state of a box in the model option print ( obj . to_sdf ( 'model' )) # Set default friction parameters obj . collision . enable_property ( 'friction' ) print ( obj . to_sdf ( 'model' )) obj . collision . set_ode_friction_params ( mu = 0.9 , mu2 = 0.5 , slip1 = 0.3 , slip2 = 0.5 , fdir1 = [ 0 , 0 , 0 ] ) print ( obj . to_sdf ( 'model' )) obj . collision . set_bullet_friction_params ( friction = 0.8 , friction2 = 0.9 , fdir1 = [ 0 , 0 , 0 ], rolling_friction = 1 ) print ( obj . to_sdf ( 'model' )) # Set default bounce parameters obj . collision . enable_property ( 'bounce' ) print ( obj . to_sdf ( 'model' )) mu = [ 0.1 , 0.3 , 0.5 , 0.7 , 1.0 ] for i in range ( len ( mu )): obj . collision . set_ode_friction_params ( mu = mu [ i ], mu2 = mu [ i ]) generator . spawn_model ( model = obj , robot_namespace = 'box_mu_{}' . format ( mu [ i ]), pos = [ 0 , i , 2 ]) from time import sleep sleep ( 2 ) for i in range ( len ( mu )): gazebo_proxy . apply_body_wrench ( model_name = 'box_mu_{}' . format ( mu [ i ]), link_name = 'box' , force = [ 300 , 0 , 0 ], torque = [ 0 , 0 , 0 ], start_time = 0 , duration = 2 ) # End the simulation by killing the Gazebo task sleep ( 5 ) simulation . kill_all_tasks () The cuboids are created with different friction parameters and therefore will travel different distances when subjected to a horizontal force applied on their center of mass.","title":"Friction"},{"location":"tutorials/task_manager/gazebo_proxy/","text":"Gazebo proxy \u00b6 The Gazebo proxy is an implementation of interfaces with all services provided by the gazebo_ros_pkgs . It allows easy use and from of the simulation through Python. It can be configured for different ROS_MASTER_URI and GAZEBO_MASTER_URI environment variables to access instances of Gazebo running in other hosts/ports. The tutorial below will make use of the simulation manager to start instances of Gazebo. # Importing the Gazebo proxy from pcg_gazebo.task_manager import GazeboProxy The Gazebo proxy may also work with an instance of Gazebo that has been started external to the scope of this package, for example by running roslaunch gazebo_ros empty_world . launch The only instance will be found by using the input hostname and ports for which they are running. Here we will use the simulation manager. # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters if not simulation . create_gazebo_empty_world_task (): raise RuntimeError ( 'Task for gazebo empty world could not be created' ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () Adding some models to the simulation to demonstrate the Gazebo proxy methods. # Now create the Gazebo proxy with the default parameters. # If these input arguments are not provided, they will be used per default. gazebo_proxy = simulation . get_gazebo_proxy () # The timeout argument will be used raise an exception in case Gazebo # fails to start from pcg_gazebo.simulation import create_object from pcg_gazebo.generators import WorldGenerator generator = WorldGenerator ( gazebo_proxy ) box = create_object ( 'box' ) box . add_inertial ( mass = 20 ) print ( box . to_sdf ( 'model' )) generator . spawn_model ( model = box , robot_namespace = 'box_1' , pos = [ - 2 , - 2 , 3 ]) generator . spawn_model ( model = box , robot_namespace = 'box_2' , pos = [ 2 , 2 , 3 ]) Pausing/unpausing the simulation \u00b6 from time import time , sleep pause_timeout = 10 # seconds start_time = time () # Pausing simulation gazebo_proxy . pause () print ( 'Simulation time before pause={}' . format ( gazebo_proxy . sim_time )) while time () - start_time < pause_timeout : print ( 'Gazebo paused, simulation time={}' . format ( gazebo_proxy . sim_time )) sleep ( 1 ) print ( 'Unpausing simulation!' ) gazebo_proxy . unpause () sleep ( 2 ) print ( 'Simulation time after pause={}' . format ( gazebo_proxy . sim_time )) Get world properties \u00b6 The world properties return Simulation time ( sim_time ) List of names of models ( model_names ) Is rendering enabled flag ( rendering_enabled ) The return of this function is simply the service object GetWorldProperties . # The world properties returns the following gazebo_proxy . get_world_properties () Model properties \u00b6 # Get list of models gazebo_proxy . get_model_names () # Get model properties for model in gazebo_proxy . get_model_names (): print ( model ) print ( gazebo_proxy . get_model_properties ( model )) print ( '-----------------' ) # Get model state for model in gazebo_proxy . get_model_names (): print ( model ) print ( gazebo_proxy . get_model_state ( model_name = model , reference_frame = 'world' )) print ( '-----------------' ) # Check if model exists print ( 'Does ground_plane exist? {}' . format ( gazebo_proxy . model_exists ( 'ground_plane' ))) print ( 'Does my_model exist? {}' . format ( gazebo_proxy . model_exists ( 'my_model' ))) # Get list of link names for a model for model in gazebo_proxy . get_model_names (): print ( model ) print ( gazebo_proxy . get_link_names ( model )) print ( '-----------------' ) # Test if model has a link print ( 'Does ground_plane have a link named link? {}' . format ( gazebo_proxy . has_link ( model_name = 'ground_plane' , link_name = 'link' ))) # Get link properties for model in gazebo_proxy . get_model_names (): print ( model ) for link in gazebo_proxy . get_link_names ( model_name = model ): print ( ' - ' + link ) print ( gazebo_proxy . get_link_properties ( model_name = model , link_name = link )) print ( '-----------------' ) print ( '==================' ) # Get link state for model in gazebo_proxy . get_model_names (): print ( model ) for link in gazebo_proxy . get_link_names ( model_name = model ): print ( ' - ' + link ) print ( gazebo_proxy . get_link_state ( model_name = model , link_name = link )) print ( '-----------------' ) print ( '==================' ) Get physics properties \u00b6 The physics properties returns the GetPhysicsProperties response with the current parameters for the physics engine. Currently only the parameters for the ODE engine can be retrieved. print ( gazebo_proxy . get_physics_properties ()) Apply wrench \u00b6 # Applying wrench to a link in the simulation # The input arguments are # - model_name # - link_name # - force: force vector [x, y, z] # - torque: torque vector [x, y, z] # - start_time: in seconds, if it is a value lower than simulation time, the wrench will be applied as soon as possible # - duration: in seconds # if duration < 0, apply wrench continuously without end # if duration = 0, do nothing # if duration < step size, apply wrench for one step size # - reference_point: [x, y, z] coordinate point where wrench will be applied wrt the reference frame # - reference_frame: reference frame for the reference point, if None it will be set as the provided model_name::link_name gazebo_proxy . apply_body_wrench ( model_name = 'box_1' , link_name = 'box' , force = [ 100 , 0 , 0 ], torque = [ 0 , 0 , 100 ], start_time = 0 , duration = 5 , reference_point = [ 0 , 0 , 0 ], reference_frame = None ) gazebo_proxy . apply_body_wrench ( model_name = 'box_2' , link_name = 'box' , force = [ 10 , 0 , 200 ], torque = [ 0 , 0 , 150 ], start_time = 0 , duration = 4 , reference_point = [ 0 , 0 , 0 ], reference_frame = None ) start_time = time () while time () - start_time < 10 : sleep ( 1 ) Move models in the simulation \u00b6 gazebo_proxy . move_model ( model_name = 'box_1' , pos = [ 2 , 2 , 15 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' ) gazebo_proxy . move_model ( model_name = 'box_2' , pos = [ - 2 , - 1 , 4 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' ) # End the simulation by killing the Gazebo task simulation . kill_all_tasks ()","title":"Gazebo proxy"},{"location":"tutorials/task_manager/gazebo_proxy/#gazebo-proxy","text":"The Gazebo proxy is an implementation of interfaces with all services provided by the gazebo_ros_pkgs . It allows easy use and from of the simulation through Python. It can be configured for different ROS_MASTER_URI and GAZEBO_MASTER_URI environment variables to access instances of Gazebo running in other hosts/ports. The tutorial below will make use of the simulation manager to start instances of Gazebo. # Importing the Gazebo proxy from pcg_gazebo.task_manager import GazeboProxy The Gazebo proxy may also work with an instance of Gazebo that has been started external to the scope of this package, for example by running roslaunch gazebo_ros empty_world . launch The only instance will be found by using the input hostname and ports for which they are running. Here we will use the simulation manager. # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters if not simulation . create_gazebo_empty_world_task (): raise RuntimeError ( 'Task for gazebo empty world could not be created' ) # A task named 'gazebo' the added to the tasks list print ( simulation . get_task_list ()) # But it is still not running print ( 'Is Gazebo running: {}' . format ( simulation . is_task_running ( 'gazebo' ))) # Run Gazebo simulation . run_all_tasks () Adding some models to the simulation to demonstrate the Gazebo proxy methods. # Now create the Gazebo proxy with the default parameters. # If these input arguments are not provided, they will be used per default. gazebo_proxy = simulation . get_gazebo_proxy () # The timeout argument will be used raise an exception in case Gazebo # fails to start from pcg_gazebo.simulation import create_object from pcg_gazebo.generators import WorldGenerator generator = WorldGenerator ( gazebo_proxy ) box = create_object ( 'box' ) box . add_inertial ( mass = 20 ) print ( box . to_sdf ( 'model' )) generator . spawn_model ( model = box , robot_namespace = 'box_1' , pos = [ - 2 , - 2 , 3 ]) generator . spawn_model ( model = box , robot_namespace = 'box_2' , pos = [ 2 , 2 , 3 ])","title":"Gazebo proxy"},{"location":"tutorials/task_manager/gazebo_proxy/#pausingunpausing-the-simulation","text":"from time import time , sleep pause_timeout = 10 # seconds start_time = time () # Pausing simulation gazebo_proxy . pause () print ( 'Simulation time before pause={}' . format ( gazebo_proxy . sim_time )) while time () - start_time < pause_timeout : print ( 'Gazebo paused, simulation time={}' . format ( gazebo_proxy . sim_time )) sleep ( 1 ) print ( 'Unpausing simulation!' ) gazebo_proxy . unpause () sleep ( 2 ) print ( 'Simulation time after pause={}' . format ( gazebo_proxy . sim_time ))","title":"Pausing/unpausing the simulation"},{"location":"tutorials/task_manager/gazebo_proxy/#get-world-properties","text":"The world properties return Simulation time ( sim_time ) List of names of models ( model_names ) Is rendering enabled flag ( rendering_enabled ) The return of this function is simply the service object GetWorldProperties . # The world properties returns the following gazebo_proxy . get_world_properties ()","title":"Get world properties"},{"location":"tutorials/task_manager/gazebo_proxy/#model-properties","text":"# Get list of models gazebo_proxy . get_model_names () # Get model properties for model in gazebo_proxy . get_model_names (): print ( model ) print ( gazebo_proxy . get_model_properties ( model )) print ( '-----------------' ) # Get model state for model in gazebo_proxy . get_model_names (): print ( model ) print ( gazebo_proxy . get_model_state ( model_name = model , reference_frame = 'world' )) print ( '-----------------' ) # Check if model exists print ( 'Does ground_plane exist? {}' . format ( gazebo_proxy . model_exists ( 'ground_plane' ))) print ( 'Does my_model exist? {}' . format ( gazebo_proxy . model_exists ( 'my_model' ))) # Get list of link names for a model for model in gazebo_proxy . get_model_names (): print ( model ) print ( gazebo_proxy . get_link_names ( model )) print ( '-----------------' ) # Test if model has a link print ( 'Does ground_plane have a link named link? {}' . format ( gazebo_proxy . has_link ( model_name = 'ground_plane' , link_name = 'link' ))) # Get link properties for model in gazebo_proxy . get_model_names (): print ( model ) for link in gazebo_proxy . get_link_names ( model_name = model ): print ( ' - ' + link ) print ( gazebo_proxy . get_link_properties ( model_name = model , link_name = link )) print ( '-----------------' ) print ( '==================' ) # Get link state for model in gazebo_proxy . get_model_names (): print ( model ) for link in gazebo_proxy . get_link_names ( model_name = model ): print ( ' - ' + link ) print ( gazebo_proxy . get_link_state ( model_name = model , link_name = link )) print ( '-----------------' ) print ( '==================' )","title":"Model properties"},{"location":"tutorials/task_manager/gazebo_proxy/#get-physics-properties","text":"The physics properties returns the GetPhysicsProperties response with the current parameters for the physics engine. Currently only the parameters for the ODE engine can be retrieved. print ( gazebo_proxy . get_physics_properties ())","title":"Get physics properties"},{"location":"tutorials/task_manager/gazebo_proxy/#apply-wrench","text":"# Applying wrench to a link in the simulation # The input arguments are # - model_name # - link_name # - force: force vector [x, y, z] # - torque: torque vector [x, y, z] # - start_time: in seconds, if it is a value lower than simulation time, the wrench will be applied as soon as possible # - duration: in seconds # if duration < 0, apply wrench continuously without end # if duration = 0, do nothing # if duration < step size, apply wrench for one step size # - reference_point: [x, y, z] coordinate point where wrench will be applied wrt the reference frame # - reference_frame: reference frame for the reference point, if None it will be set as the provided model_name::link_name gazebo_proxy . apply_body_wrench ( model_name = 'box_1' , link_name = 'box' , force = [ 100 , 0 , 0 ], torque = [ 0 , 0 , 100 ], start_time = 0 , duration = 5 , reference_point = [ 0 , 0 , 0 ], reference_frame = None ) gazebo_proxy . apply_body_wrench ( model_name = 'box_2' , link_name = 'box' , force = [ 10 , 0 , 200 ], torque = [ 0 , 0 , 150 ], start_time = 0 , duration = 4 , reference_point = [ 0 , 0 , 0 ], reference_frame = None ) start_time = time () while time () - start_time < 10 : sleep ( 1 )","title":"Apply wrench"},{"location":"tutorials/task_manager/gazebo_proxy/#move-models-in-the-simulation","text":"gazebo_proxy . move_model ( model_name = 'box_1' , pos = [ 2 , 2 , 15 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' ) gazebo_proxy . move_model ( model_name = 'box_2' , pos = [ - 2 , - 1 , 4 ], rot = [ 0 , 0 , 0 ], reference_frame = 'world' ) # End the simulation by killing the Gazebo task simulation . kill_all_tasks ()","title":"Move models in the simulation"},{"location":"tutorials/task_manager/process_manager/","text":"Process manager \u00b6 The process manager allows the construction of sets of tasks to be run, which can be (but are not limited to) launch files or ROS nodes to bring up a system that may include an instance of Gazebo. Each instance of the process manager can be set with a different ROS_MASTER_URI and GAZEBO_MASTER_URI , so that multiple roscore and gazebo instances can be initialized on the same host at the same time. Starting a process manager with default parameters \u00b6 from pcg_gazebo.task_manager import ProcessManager # A process manager can be started by itself with an empty list of tasks process_manager = ProcessManager () # At this point neither Gazebo or roscore are running # When no arguments are given, the default hostname and port # arguments are going to be used. print ( 'ROS network configuration:' ) print ( process_manager . ros_config ) # At first, no tasks are available in the tasks list print ( process_manager . get_task_list ()) print ( 'Check all the process stages available' ) print ( process_manager . stages ) # You can start roscore by calling the method below process_manager . create_ros_core_task () # Now the roscore task can be found in the list print ( process_manager . get_task_list ()) # The task can be started using the method below # Running individual tasks will not use the stage order process_manager . run_task ( 'roscore' ) # Check if the task is running print ( 'Is task running? {}' . format ( process_manager . is_task_running ( 'roscore' ))) # Creating an RViz task with a timeout # The required flag, like the flag for ROS nodes, says that once this task dies, # all other tasks must be killed. # The process timeout starts a timer and will kill the task in the amount of seconds # given by process_timeout # IMPORTANT: process_timeout is based on the machine clock, not the simulation clock # process_timeout=None means that the process will run without a timeout process_manager . create_rviz_task ( required = True , process_timeout = 10 ) print ( process_manager . get_task_list ()) # After 10 seconds all tasks will be killed along with rviz process_manager . run_task ( 'rviz' ) process_manager . wait () process_manager . kill_all_tasks () del process_manager Running Gazebo \u00b6 Similar to RViz, Gazebo can also be started. The same process will be repeated to start Gazebo with the empty world scenario. # At first, no tasks are available in the tasks list # A process manager can be started by itself with an empty list of tasks # When ros_port and/or gazebo_port is given as None, a random port will be chosen process_manager = ProcessManager ( ros_port = None , gazebo_port = None ) print ( 'ROS network configuration:' ) print ( process_manager . ros_config ) # A Gazebo task can also be started with a process timeout process_manager . create_gazebo_empty_world_task ( required = True , process_timeout = 10 ) print ( 'Check all tasks available' ) print ( process_manager . get_task_list ()) print ( 'Check all the process stages available' ) print ( process_manager . stages ) process_manager . run_all_tasks () # A roscore stage should be automatically added to the process manager list print ( process_manager . stages ) process_manager . wait () process_manager . kill_all_tasks () del process_manager # But a task that contains a Gazebo instance can also be started with a simulation timeout # meaning that the process will be killed only when the simulation time reaches a timeout # At first, no tasks are available in the tasks list # A process manager can be started by itself with an empty list of tasks # When ros_port and/or gazebo_port is given as None, a random port will be chosen process_manager = ProcessManager ( ros_port = None , gazebo_port = None ) print ( 'ROS network configuration:' ) print ( process_manager . ros_config ) process_manager . create_gazebo_empty_world_task ( required = True , simulation_timeout = 10 ) process_manager . run_all_tasks () process_manager . wait () print ( 'Is task running? {}' . format ( process_manager . is_task_running ( 'gazebo' )))","title":"Process manager"},{"location":"tutorials/task_manager/process_manager/#process-manager","text":"The process manager allows the construction of sets of tasks to be run, which can be (but are not limited to) launch files or ROS nodes to bring up a system that may include an instance of Gazebo. Each instance of the process manager can be set with a different ROS_MASTER_URI and GAZEBO_MASTER_URI , so that multiple roscore and gazebo instances can be initialized on the same host at the same time.","title":"Process manager"},{"location":"tutorials/task_manager/process_manager/#starting-a-process-manager-with-default-parameters","text":"from pcg_gazebo.task_manager import ProcessManager # A process manager can be started by itself with an empty list of tasks process_manager = ProcessManager () # At this point neither Gazebo or roscore are running # When no arguments are given, the default hostname and port # arguments are going to be used. print ( 'ROS network configuration:' ) print ( process_manager . ros_config ) # At first, no tasks are available in the tasks list print ( process_manager . get_task_list ()) print ( 'Check all the process stages available' ) print ( process_manager . stages ) # You can start roscore by calling the method below process_manager . create_ros_core_task () # Now the roscore task can be found in the list print ( process_manager . get_task_list ()) # The task can be started using the method below # Running individual tasks will not use the stage order process_manager . run_task ( 'roscore' ) # Check if the task is running print ( 'Is task running? {}' . format ( process_manager . is_task_running ( 'roscore' ))) # Creating an RViz task with a timeout # The required flag, like the flag for ROS nodes, says that once this task dies, # all other tasks must be killed. # The process timeout starts a timer and will kill the task in the amount of seconds # given by process_timeout # IMPORTANT: process_timeout is based on the machine clock, not the simulation clock # process_timeout=None means that the process will run without a timeout process_manager . create_rviz_task ( required = True , process_timeout = 10 ) print ( process_manager . get_task_list ()) # After 10 seconds all tasks will be killed along with rviz process_manager . run_task ( 'rviz' ) process_manager . wait () process_manager . kill_all_tasks () del process_manager","title":"Starting a process manager with default parameters"},{"location":"tutorials/task_manager/process_manager/#running-gazebo","text":"Similar to RViz, Gazebo can also be started. The same process will be repeated to start Gazebo with the empty world scenario. # At first, no tasks are available in the tasks list # A process manager can be started by itself with an empty list of tasks # When ros_port and/or gazebo_port is given as None, a random port will be chosen process_manager = ProcessManager ( ros_port = None , gazebo_port = None ) print ( 'ROS network configuration:' ) print ( process_manager . ros_config ) # A Gazebo task can also be started with a process timeout process_manager . create_gazebo_empty_world_task ( required = True , process_timeout = 10 ) print ( 'Check all tasks available' ) print ( process_manager . get_task_list ()) print ( 'Check all the process stages available' ) print ( process_manager . stages ) process_manager . run_all_tasks () # A roscore stage should be automatically added to the process manager list print ( process_manager . stages ) process_manager . wait () process_manager . kill_all_tasks () del process_manager # But a task that contains a Gazebo instance can also be started with a simulation timeout # meaning that the process will be killed only when the simulation time reaches a timeout # At first, no tasks are available in the tasks list # A process manager can be started by itself with an empty list of tasks # When ros_port and/or gazebo_port is given as None, a random port will be chosen process_manager = ProcessManager ( ros_port = None , gazebo_port = None ) print ( 'ROS network configuration:' ) print ( process_manager . ros_config ) process_manager . create_gazebo_empty_world_task ( required = True , simulation_timeout = 10 ) process_manager . run_all_tasks () process_manager . wait () print ( 'Is task running? {}' . format ( process_manager . is_task_running ( 'gazebo' )))","title":"Running Gazebo"},{"location":"tutorials/task_manager/stage_conditions/","text":"Simulation stage conditions \u00b6 # If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task ( paused = True , simulation_timeout = 10 ) from pcg_gazebo.simulation import create_object from pcg_gazebo.generators import WorldGenerator def model_exists ( name ): print ( 'Testing if model {} exists' . format ( name )) gazebo_proxy = simulation . get_gazebo_proxy () success = name in gazebo_proxy . get_model_names () print ( 'Model {} exists? {}' . format ( name , success )) return success def spawn_model (): print ( 'Spawning box into Gazebo' ) obj = create_object ( 'box' ) obj . size = [ 0.8 , 0.7 , 0.9 ] obj . add_inertial ( 30 ) gazebo_proxy = simulation . get_gazebo_proxy () generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) for x in [ - 5 , 0 , 5 ]: for y in [ - 5 , 0 , 5 ]: generator . spawn_model ( model = obj , robot_namespace = 'box_{}_{}' . format ( x , y ), pos = [ x , y , 10 ]) print ( 'Spawning box finished' ) return True def unpause (): print ( 'Unpause simulation' ) gazebo_proxy = simulation . get_gazebo_proxy () gazebo_proxy . unpause () return True # Adding a stage starting condition to the gazebo stage to check # if roscore is running simulation . add_stage_start_condition ( 'gazebo' , simulation . is_roscore_running ) # Add stage end condition to be sure Gazebo is running simulation . add_stage_end_condition ( 'gazebo' , simulation . is_gazebo_running ) # Add pre-stage function to spawn the models simulation . add_post_stage_fcn ( 'gazebo' , spawn_model ) # Adding final empty stage to check if model was created simulation . add_stage ( 'post-init' ) # Adding stage end condition where the model must exist in # Gazebo simulation . add_stage_start_condition ( 'post-init' , lambda : model_exists ( 'box_0_0' )) simulation . add_post_stage_fcn ( 'post-init' , unpause ) for tag in simulation . stages : print ( 'Stage: {}' . format ( tag )) for task in simulation . get_tasks_from_stage ( tag ): print ( ' - {}' . format ( task )) simulation . run_all_tasks () simulation . wait ()","title":"Stage conditions"},{"location":"tutorials/task_manager/stage_conditions/#simulation-stage-conditions","text":"# If there is a Gazebo instance running, you can spawn the box into the simulation from pcg_gazebo.task_manager import Server # First create a simulation server server = Server () # Create a simulation manager named default server . create_simulation ( 'default' ) simulation = server . get_simulation ( 'default' ) # Run an instance of the empty.world scenario # This is equivalent to run # roslaunch gazebo_ros empty_world.launch # with all default parameters simulation . create_gazebo_empty_world_task ( paused = True , simulation_timeout = 10 ) from pcg_gazebo.simulation import create_object from pcg_gazebo.generators import WorldGenerator def model_exists ( name ): print ( 'Testing if model {} exists' . format ( name )) gazebo_proxy = simulation . get_gazebo_proxy () success = name in gazebo_proxy . get_model_names () print ( 'Model {} exists? {}' . format ( name , success )) return success def spawn_model (): print ( 'Spawning box into Gazebo' ) obj = create_object ( 'box' ) obj . size = [ 0.8 , 0.7 , 0.9 ] obj . add_inertial ( 30 ) gazebo_proxy = simulation . get_gazebo_proxy () generator = WorldGenerator ( gazebo_proxy = gazebo_proxy ) for x in [ - 5 , 0 , 5 ]: for y in [ - 5 , 0 , 5 ]: generator . spawn_model ( model = obj , robot_namespace = 'box_{}_{}' . format ( x , y ), pos = [ x , y , 10 ]) print ( 'Spawning box finished' ) return True def unpause (): print ( 'Unpause simulation' ) gazebo_proxy = simulation . get_gazebo_proxy () gazebo_proxy . unpause () return True # Adding a stage starting condition to the gazebo stage to check # if roscore is running simulation . add_stage_start_condition ( 'gazebo' , simulation . is_roscore_running ) # Add stage end condition to be sure Gazebo is running simulation . add_stage_end_condition ( 'gazebo' , simulation . is_gazebo_running ) # Add pre-stage function to spawn the models simulation . add_post_stage_fcn ( 'gazebo' , spawn_model ) # Adding final empty stage to check if model was created simulation . add_stage ( 'post-init' ) # Adding stage end condition where the model must exist in # Gazebo simulation . add_stage_start_condition ( 'post-init' , lambda : model_exists ( 'box_0_0' )) simulation . add_post_stage_fcn ( 'post-init' , unpause ) for tag in simulation . stages : print ( 'Stage: {}' . format ( tag )) for task in simulation . get_tasks_from_stage ( tag ): print ( ' - {}' . format ( task )) simulation . run_all_tasks () simulation . wait ()","title":"Simulation stage conditions"}]}