#!/usr/bin/env python
# Copyright (c) 2019 - The Procedural Generation for Gazebo authors
# For information on the respective copyright owner see the NOTICE file
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""**Description**

**Input parameters**

**Examples**

"""
from __future__ import print_function
import rospy
from pcg_gazebo.generators import load_gazebo_models, get_gazebo_models
from pcg_gazebo.generators import Generator
from pcg_gazebo.simulation import SimulationModel
from pcg_gazebo.task_manager import Server
from pcg_msgs.msg import SimulationModel, WorldModels
from pcg_msgs.srv import AddSimulationModels, AddSimulationModelsResponse, GetActiveSimulation, \
    GetActiveSimulationResponse, GetSimulationsList, GetSimulationsListResponse, ExportWorld, \
    ExportWorldResponse, CreateNewSimulation, CreateNewSimulationResponse, RunSimulation, \
    RunSimulationResponse
from std_srvs.srv import Trigger
from visualization_msgs.msg import Marker, MarkerArray
from geometry_msgs.msg import TransformStamped
from threading import Event
import tf2_ros
import yaml
import os
import signal

PCG_GENERATOR = None

class PCGSimulationServer:
    def __init__(self):
        self._server = Server()
        self._generators = dict()
        self._active_simulation = None

        self._namespace = rospy.get_param('~namespace', '')

        self._ros_prefix = '' if len(self._namespace) == 0 else '/{}/'.format(
            self._namespace)

        self._services = dict()
        self._services['get_simulations_list'] = rospy.Service(
            self._get_name_with_ros_prefix('get_simulations_list'), 
            GetSimulationsList, 
            self.get_simulations_list)
        self._services['get_active_simulation'] = rospy.Service(
            self._get_name_with_ros_prefix('get_active_simulation'),
            GetActiveSimulation,
            self.get_active_simulation)
        self._services['add_simulation_models'] = rospy.Service(
            self._get_name_with_ros_prefix('add_simulation_models'),
            AddSimulationModels,
            self.add_simulation_models)       
        self._services['create_new_simulation'] = rospy.Service(
            self._get_name_with_ros_prefix('create_new_simulation'),
            CreateNewSimulation,
            self.create_new_simulation)
        self._services['run_simulation'] = rospy.Service(
            self._get_name_with_ros_prefix('run_simulation'),
            RunSimulation,
            self.run_simulation)

        self._publishers = dict()
        self._publishers['world_models'] = rospy.Publisher(
            self._get_name_with_ros_prefix('world_models'),
            WorldModels)
        self._publishers['model_markers'] = rospy.Publisher(
            self._get_name_with_ros_prefix('model_markers'),
            MarkerArray)

        self._tf_broadcaster = tf2_ros.TransformBroadcaster()

        self._updating_models = Event()
        self._publishing_world_info = Event()

        self._update_timer = rospy.Timer(
            rospy.Duration(0.5), 
            self._update_model_output)

    def _publish_tf_frames(self):
        if self._active_simulation is None:
            return

        for tag in self._generators[self._active_simulation].world.models:
            model = self._generators[self._active_simulation].world.models[tag]            

            for tf_transform in model.get_tf_transforms():
                self._tf_broadcaster.sendTransform(tf_transform)

    def _get_name_with_ros_prefix(self, input_str):
        return self._ros_prefix + input_str

    def _publish_world_info(self):
        if self._active_simulation is None:
            return

        if self._publishers['world_models'].get_num_connections() == 0:
            return 

        world_models_msg = WorldModels()
        for tag in self._generators[self._active_simulation].world.models:
            model = self._generators[self._active_simulation].world.models[tag]
            model_msg = SimulationModel()
            model_msg.name = model.name
            # Set pose
            model_msg.pose.position.x = model.pose.position[0]
            model_msg.pose.position.y = model.pose.position[1]
            model_msg.pose.position.z = model.pose.position[2]

            model_msg.pose.orientation.x = model.pose.quat.x
            model_msg.pose.orientation.y = model.pose.quat.y
            model_msg.pose.orientation.z = model.pose.quat.z
            model_msg.pose.orientation.w = model.pose.quat.w

            model_msg.is_gazebo_model = model.is_gazebo_model
            model_msg.source_model_name = model.source_model_name
            
            if not model.is_gazebo_model:
                model_msg.sdf = model.to_sdf(type='sdf')

            world_models_msg.models.append(model_msg)

        self._publishers['world_models'].publish(world_models_msg)

    def _publish_visual_markers(self):
        if self._active_simulation is None:
            return

        if self._publishers['model_markers'].get_num_connections() == 0:
            return 

        markers = MarkerArray()
        for tag in self._generators[self._active_simulation].world.models:
            model = self._generators[self._active_simulation].world.models[tag]
            markers.markers += model.to_markers()
            
        self._publishers['model_markers'].publish(markers)        

    def _update_model_output(self, event):
        if self._active_simulation is None:
            return

        if self._updating_models.is_set():
            self._updating_models.wait() 

        self._publishing_world_info.set()

        # Publish the TF frames of each world model
        self._publish_tf_frames()
        # Publish the models' information in the ROS parameters server
        self._publish_world_info()
        # Publish the visual markers
        self._publish_visual_markers()

        self._publishing_world_info.clear()

    def _create_new_simulation(self, name, ros_host='localhost',
        ros_port=None, gazebo_host='localhost', gazebo_port=None, 
        anonymous=False, output_log_dir=None):
        if self._server.has_simulation(name):
            rospy.logwarn('Simulation <{}> already exists')
        else:
            self._generators[name] = Generator()
            self._server.create_simulation(name, ros_host, ros_port, 
                gazebo_host, gazebo_port, anonymous, output_log_dir)
            rospy.loginfo('New simulation instance <{}> created'.format(name))

    def _export_world(self, simulation_name, output_dir='/tmp', filename=None, 
        with_default_ground_plane=False, with_default_sun=True):
        world_filename = self._generators[simulation_name].export_world(
            output_dir=output_dir,
            filename=filename, 
            with_default_ground_plane=with_default_ground_plane,
            with_default_sun=with_default_sun)
        rospy.loginfo('World file for simulation <{}> stored in {}'.format(
            simulation_name, world_filename))
        return world_filename

    def _run_world(self, simulation_name, output_dir='/tmp', filename=None, 
        with_default_ground_plane=False, with_default_sun=True):
        assert self._server.has_simulation(simulation_name), \
            'Simulation setup {} cannot be found'.format(simulation_name)

        # Export world to SDF file
        world_filename = self._export_world(
            simulation_name, output_dir, filename, 
            with_default_ground_plane, with_default_sun)

        simulation = self._server.get_simulation(simulation_name)
        # Run an instance of the empty.world scenario
        # This is equivalent to run
        #      roslaunch gazebo_ros empty_world.launch
        # with the parameters provided to run the world file created
        simulation.create_gazebo_task(
            name='gazebo',
            world=world_filename,
            gui=True,
            physics='ode',
            paused=False,
            required=True)

        simulation.init_task(
            name='simulation_tf_manager',
            command='roslaunch pcg_libraries start_pcg_simulation_tf_manager.launch',
            has_gazebo=False,
            type='roslaunch',
            stage='gazebo',
            params=dict(
                namespace="pcg",
                gazebo_topic="/gazebo/model_states"
            ))

        # Run Gazebo
        simulation.run_all_tasks()

    def kill_simulation(self):
        for tag in self._server.simulations:
            try:
                self._server.simulations[tag].kill_all_tasks()
            except Exception as ex:
                print(ex)

    def run_simulation(self, req):
        if not self._server.has_simulation(req.simulation_name):
            return RunSimulationResponse(
                    'Simulation with name <{}> does not exist'.format(
                        req.simulation_name), False)

        self._run_world(
            str(req.simulation_name),
            '/tmp/gazebo_worlds' if req.world_output_dir == '' else str(req.world_output_dir),
            str(req.simulation_name) if req.world_filename == '' else str(req.world_filename),
            req.with_default_ground_plane,
            req.with_default_sun
        )

        return RunSimulationResponse('Success', True)

    def get_simulations_list(self, req):
        return GetSimulationsListResponse([tag for tag in self._server.simulation_names])

    def get_active_simulation(self, req):
        if self._active_simulation is None:
            return GetActiveSimulationResponse('')
        else:
            return GetActiveSimulationResponse(self._active_simulation)    

    def create_new_simulation(self, req):
        if self._server.has_simulation(req.simulation_name):
            return CreateNewSimulationResponse(
                    'Simulation with name <{}> already exists'.format(
                        req.simulation_name), False)
        
        ros_host = 'localhost'
        if len(req.ros_host) > 0:
            ros_host = req.ros_host
        ros_port = 11311
        if req.ros_port > 0:
            ros_port = req.ros_port
        gazebo_host = 'localhost'
        if len(req.gazebo_host) > 0:
            gazebo_host = req.gazebo_host
        gazebo_port = 11345
        if req.gazebo_port > 0:
            gazebo_port = req.gazebo_port
        output_log_dir = None
        if len(req.output_log_dir) > 0:
            output_log_dir = req.output_log_dir

        self._create_new_simulation(
            req.simulation_name,
            ros_host=ros_host,
            ros_port=ros_port,
            gazebo_host=gazebo_host,
            gazebo_port=gazebo_port,
            anonymous=req.anonymous,
            output_log_dir=output_log_dir)

        rospy.loginfo('New simulation setup created:')
        rospy.loginfo('\t Name={}'.format(req.simulation_name))
        rospy.loginfo('\t Config=')
        rospy.loginfo(self._server.simulations[req.simulation_name].ros_config)
        rospy.loginfo('\t Log folder={}'.format(output_log_dir))

        return CreateNewSimulationResponse('Success', True)

    def add_simulation_models(self, req):
        if not self._server.has_simulation(req.simulation_name):
            return AddSimulationModelsResponse(
                'Simulation setup <{}> does not exist'.format(req.simulation_name),
                False)
        if self._active_simulation != req.simulation_name:
            self._active_simulation = req.simulation_name
            rospy.loginfo('New active simulation={}'.format(req.simulation_name))

        if self._publishing_world_info.is_set():
            self._publishing_world_info.wait() 

        self._updating_models.set()

        output_message = ''
        for item in req.models:
            rospy.loginfo('Adding model {} to simulation world {}'.format(
                item.name, req.simulation_name))
            pose = [
                item.pose.position.x,
                item.pose.position.y,
                item.pose.position.z,
                item.pose.orientation.w,
                item.pose.orientation.x,
                item.pose.orientation.y,
                item.pose.orientation.z
            ]
            if item.is_gazebo_model:
                try:
                    self._generators[req.simulation_name].add_gazebo_model(item.name, pose)
                except AssertionError as ex:
                    rospy.logerr('Error adding Gazebo model <{}> to the '
                                 'simulation <{}>, message={}'.format(item.name, req.simulation_name, ex))
                    if len(output_message) == 0:
                        output_message = 'Failed to load models='
                    output_message += '{} '.format(item.name)
            else:
                if len(item.sdf) == 0:
                    rospy.logerr('No SDF XML content found for model <{}>'.format(item.name))
                else:
                    try:
                        model = SimulationModel.from_sdf(item.sdfreq)
                        self._generators[req.simulation_name].add_model(model, pose)
                    except AssertionError as ex:
                        rospy.logerr('Error importing SDF file for model <{}>, message={}'.format(
                            item.name, ex))
                    if len(output_message) == 0:
                        output_message = 'Failed to load models='
                    output_message += '{} '.format(item.name)

        self._updating_models.clear()

        if len(output_message) == 0:
            output_message = 'Models successfully loaded to simulation <{}>'.format(req.simulation_name)
            return AddSimulationModelsResponse(True, output_message)
        else:
            return AddSimulationModelsResponse(False, output_message)

def signal_handler(signal, handler):
    print('SIGNAL RECEIVED={}'.format(int(signal)))
    if PCG_GENERATOR is not None:
        PCG_GENERATOR.kill_simulation()
    
if __name__ == '__main__':
    rospy.init_node('pcg_simulation_server')

    PCG_GENERATOR = PCGSimulationServer()

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    try:
        rospy.spin()
    except rospy.ROSInterruptException:
        print('PCG simulation server exiting')
