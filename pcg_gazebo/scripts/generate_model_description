#!/usr/bin/env python
# Copyright (c) 2019 - The Procedural Generation for Gazebo authors
# For information on the respective copyright owner see the NOTICE file
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""**Description**

Script that converts SDF-Jinja or URDF-Jinja templates into SDF or URDF robot
description.

**Input parameters**

* `include-dir` (*type:* `str`): Path to Jinja2 template includes folder
* `templates-dir` (*type:* `str`): Path to Jinja2 templates folder
* `param-file` (*type:* `str`, `optional`): YAML parameter file to be set in the model
* `param` (`optional`): Single parameters to be parsed in the Jinja2 templates as --param foo=1. Multiple `param` entries are accepted.
* `model-template` (*type:* `str`): Robot model file template
* `sdf`: Indicates that the templates will be used to generate a SDF robot description
* `urdf`: Indicates that the templates will be used to generate a URDF robot description
* `sdf-output-param` (*type:* `str`, *default:* `/robot_description_sdf`): Name of the ROS parameters to store the SDF robot description in case `--sdf` was provided
* `urdf-output-param` (*type:* `str`, *default:* `/robot_description`): Name of the ROS parameters to store the URDF robot description in case `--urdf` was provided
* `output-topic` (*type:* `str`, `optional`): Optional output topic to publish the resulting XML
* `output-filename` (*type:* `str`, `optional`): Optional output file to store the parsed file
* `spawn-sdf-model-srv` (*type:* `str`, `optional`): Service to be used to trigger the spawning of the SDF model

**Examples**

"""
from __future__ import print_function
import os
import argparse
import rospy
import subprocess
import sys
import re
import yaml
import rospkg
from time import time, sleep
from std_msgs.msg import String
from std_srvs.srv import Trigger
from pcg_gazebo.parsers import parse_sdf, parse_urdf
from jinja2 import FileSystemLoader, Environment, \
    TemplateSyntaxError, TemplateAssertionError, BaseLoader, \
    TemplateNotFound


TEMPLATES_DIR = None

ROSPKG = rospkg.RosPack()


class AbsFileSystemLoader(BaseLoader):
    def __init__(self, path):
        self.path = path

    def get_source(self, environment, template):        
        if os.path.isfile(template):
            path = template
        else:
            path = os.path.join(self.path, template)
            if not os.path.isfile(path):
                raise TemplateNotFound(template)
        mtime = os.path.getmtime(path)
        with open(path) as f:
            source = f.read().decode('utf-8')
        return source, path, lambda: mtime == os.path.getmtime(path)


def find_ros_package(pkg_name):
    try:
        pkg_path = ROSPKG.get_path(pkg_name)
    except rospkg.ResourceNotFound as ex:
        print('Error finding package {}, message={}'.format(pkg_name, ex))
        sys.exit(-1)    
    return pkg_path


def pretty_print_xml(xml):
    proc = subprocess.Popen(
        ['xmllint', '--format', '/dev/stdin'],
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        )
    (output, error_output) = proc.communicate(xml)
    return output


def parse_package_paths(xml):
    # Finding patterns package://
    result = re.findall('package://\w+/', xml)
    output_xml = xml
    for item in result:        
        pkg_name = item.replace('package://', '').replace('/', '')
        try:
            pkg_path = ROSPKG.get_path(pkg_name)
        except rospkg.ResourceNotFound as ex:
            print('Error finding package {}, message={}'.format(pkg_name, ex))
            sys.exit(-1)

        output_xml = output_xml.replace(item, 'file://' + pkg_path + '/')

    # Finding patterns $(find pkg)
    result = re.findall(r'\$\(find \w+\)', output_xml)        
    for item in result:                
        pkg_name = item.split()[1].replace(')', '')
        try:
            pkg_path = ROSPKG.get_path(pkg_name)
        except rospkg.ResourceNotFound as ex:
            print('Error finding package {}, message={}'.format(pkg_name, ex))
            sys.exit(-1)

        output_xml = output_xml.replace(item, 'file://' + pkg_path + '/')
    return output_xml        
    

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Generate SDF model from Jinja2 template files')
    parser.add_argument(
        '--include-dir', '-i', type=str, 
        help='Path to Jinja2 template includes folder')
    parser.add_argument(
        '--templates-dir', '-t', type=str, 
        help='Path to Jinja2 templates folder')
    parser.add_argument(
        '--param-file', '-f', type=str, 
        help='YAML parameter file to be set in the model')
    parser.add_argument(
        '--param', '-p', action='append', 
        help='Model parameter to be replaced in the SDF file')
    parser.add_argument(
        '--model-template', '-m', type=str, 
        help='Robot model file template')
    parser.add_argument(
        '--sdf', action='store_true', 
        help='Flag to signal that the input template is for a SDF file')
    parser.add_argument(
        '--urdf', action='store_true')
    parser.add_argument(
        '--sdf-output-param', type=str, default='/robot_description_sdf', help='')
    parser.add_argument(
        '--urdf-output-param', type=str, default='/robot_description', help='')
    parser.add_argument(
        '--output-topic', type=str,
        help='Optional output topic to publish the resulting XML')
    parser.add_argument(
        '--output-filename', '-o', type=str,
        help='Output file to store the parsed file')
    parser.add_argument(
        '--spawn-sdf-model-srv', type=str,
        help='Service to be used to trigger the spawning of the SDF model')
    args = parser.parse_args(rospy.myargv()[1:])

    assert os.path.isdir(args.include_dir), \
        'Invalid include directory, value={}'.format(args.include_dir)
    assert os.path.isdir(args.templates_dir), \
        'Invalid templates directory, value={}'.format(args.templates_dir)
    assert os.path.isfile(os.path.join(args.templates_dir, args.model_template)), \
        'Invalid model template file, value={}'.format(args.model_template)

    if not args.sdf and not args.urdf:
        print('Neither the --sdf nor the --urdf flags were set')
        sys.exit(-1)

    if rospy.is_shutdown():
            raise rospy.ROSInitException('ROS master is not running!')
            sys.exit(-1)

    rospy.init_node('generate_model_description', anonymous=True)

    base_loader = FileSystemLoader(args.templates_dir)
    includes_loader = AbsFileSystemLoader(args.include_dir)

    base_env = Environment(loader=base_loader)
    # Add Jinja function similar to $(find <package>) in XACRO
    base_env.filters['find_ros_package'] = find_ros_package

    model_template = base_env.get_template(args.model_template)
    model_template.environment.loader = includes_loader

    params = dict()
    
    if os.path.isfile(args.param_file):
        print('Importing parameters from file: {}'.format(args.param_file))
        with open(args.param_file, 'r') as p_file:
            params = yaml.load(p_file)
    if args.param:
        if len(args.param):
            for item in args.param:
                param = item.split('=')
                assert len(param) == 2, 'Parameter must be provided as <param_name>=<param_value>'
                params[param[0]] = param[1]

    # Generate robot description
    output_xml = pretty_print_xml(model_template.render(**params))
    output_xml = parse_package_paths(output_xml)    
    
    if args.sdf:                
        sdf = parse_sdf(output_xml)
        
        if args.sdf_output_param is not None and len(args.sdf_output_param) > 0:
            # Publish SDF robot description
            rospy.set_param(args.sdf_output_param, output_xml)

            if args.spawn_sdf_model_srv:
                rospy.wait_for_service(args.spawn_sdf_model_srv, timeout=30)

                spawn_sdf_model = rospy.ServiceProxy(args.spawn_sdf_model_srv, Trigger)

                output = spawn_sdf_model()

                if output.success:
                    rospy.loginfo('SDF model was spawned')
                else:
                    rospy.loginfo('Failed to spawn model')
        if args.output_filename:
            sdf.export_xml(args.output_filename)
            rospy.loginfo('SDF file exported to: {}'.format(args.output_filename))

    elif args.urdf:
        urdf = parse_urdf(output_xml)
        
        if args.urdf_output_param is not None and len(args.urdf_output_param) > 0:
            # Convert file to URDF
            rospy.set_param(args.urdf_output_param, output_xml)            
        if args.output_filename:
            # Export file
            urdf.export_xml(args.output_filename)
            rospy.loginfo('URDF file exported to: ', args.output_filename)

    if args.output_topic:      
        pub = rospy.Publisher(args.output_topic, String, queue_size=1)
        
        start_time = time()
        # Wait for 30 seconds until another node is subscribed
        while pub.get_num_connections() == 0 and time() - start_time < 30:
            sleep(0.1)
        pub.publish(output_xml)




    